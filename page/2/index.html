<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://www.jiyoung.cn">
  <title>JY</title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    
    <!-- <meta name="keywords" content="">
    <meta name="description" content="克己"> -->
  
  <meta name="description" content="克己">
<meta property="og:type" content="website">
<meta property="og:title" content="JY">
<meta property="og:url" content="http://www.jiyoung.cn/page/2/index.html">
<meta property="og:site_name" content="JY">
<meta property="og:description" content="克己">
<meta property="og:locale">
<meta property="article:author" content="KangLeon">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="JY" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.a5fda8.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script src="/lib/clickLove.js"></script>
  
  

<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();

</script>



  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #4d4d4d;background: url('/img/biubiubiu.gif') no-repeat ;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/head.jpg" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">KangLeon</a></h1>
		</hgroup>
		
		<p class="header-subtitle"> iOS Devloper、flutter、Go</p>
		

		<nav class="header-menu">
			<ul>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
				
			
				
					<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
				
			
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					
						<a class="github" href="https://github.com/KangLeon" 
												title="GitHub" target="_blank"><i class="icon-github"></i></a>
					
				
			</div>
		
			
			
			
			
			<div>
				<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="240" height="86" src="//music.163.com/outchain/player?type=2&id=4341314&auto=1&height=66"></iframe>
			</div>
			
		
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
      <a class="forkMe" style="position:absolute;z-index:999;top:0;right:0.5em;" 
        href="https://github.com/KangLeon" target="_blank">
        <img src="/img/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/img/head.jpg" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">KangLeon</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i> iOS Devloper、flutter、Go<i class="icon icon-quo-right"></i></p>
			
			
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						
						<a class="github" target="_blank" 
							href="https://github.com/KangLeon" title="GitHub"><i class="icon-github"></i></a>
						
					
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            

  
    <article id="post-Objective-C需要记忆的知识点" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2019/08/26/Objective-C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank">Objective-C需要记忆的知识点</a>
  
    </h1>
  


  
  
<a href="/2019/08/26/Objective-C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/" class="archive-article-date">
        <time datetime="2019-08-26T02:08:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-08-26</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h1 id="Objective-C需要记忆的知识点"><a href="#Objective-C需要记忆的知识点" class="headerlink" title="Objective-C需要记忆的知识点"></a>Objective-C需要记忆的知识点</h1><h4 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h4><blockquote>
<ul>
<li>类是一组具有相同特性和行为的某一类事和物的集合.</li>
<li>对象是类的实例化.</li>
</ul>
</blockquote>
<h4 id="2-property有关语法"><a href="#2-property有关语法" class="headerlink" title="2.property有关语法"></a>2.property有关语法</h4><blockquote>
<ol>
<li>readwrite 是可读可写特征;需要生成getter方法和setter方法.</li>
<li>readonly 是只读特性  只会生成getter方法 不会生成setter方法.     </li>
<li>assign 赋值特性,setter方法将传入参数赋值给实例变量.（弱引用）（基本数据类型）       </li>
<li>retain 表示持有特性,setter方法将传入参数先保留,再赋值,并且变量retaincount+1;（强引用）</li>
<li>copy   通过copy将对象复制一份,之前的对象会释放.(强引用)          </li>
<li>nonatomic 表示单线程安全.         </li>
<li>atomic 表示多线程安全.</li>
</ol>
</blockquote>
<h4 id="3-property相关注意事项："><a href="#3-property相关注意事项：" class="headerlink" title="3.property相关注意事项："></a>3.property相关注意事项：</h4><h5 id="property后面有哪些修饰符："><a href="#property后面有哪些修饰符：" class="headerlink" title="@property后面有哪些修饰符："></a>@property后面有哪些修饰符：</h5><blockquote>
<ol>
<li>线程安全的：atomic、nonatomic</li>
<li>访问权限的：readonly、readwrite</li>
<li>内存管理（ARC）assign、strong、weak、copy</li>
<li>内存管理（MRC）assign、retain、release</li>
<li>指定方法名称  setter = getter =</li>
</ol>
</blockquote>
<h5 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h5><h6 id="一、线程安全的：多线程存在安全隐患"><a href="#一、线程安全的：多线程存在安全隐患" class="headerlink" title="一、线程安全的：多线程存在安全隐患"></a>一、线程安全的：多线程存在安全隐患</h6><blockquote>
<p>1.一块资源可能会被多个线程共享，也就是多个线程可能同时访问同一资源，</p>
<p>如：<br>多线程访问同一个对象，同一个变量，同一个文件</p>
<p>2.当多线程访问同一块资源的时候，很容易引发数据错乱和数据安全问题<br>———原子性——— ：默认</p>
<p>这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量的读写不同步问题，提供多线程安全，即多线程中只能有一个线程对它进行访问。</p>
<p>注意：</p>
<p>1.atomic原子性指的是一个操作不可以被CPU中途暂停，然后再调度。即不能被中断，要么就执行完，要么就不执行<br>2.atomic是自旋锁，当上一线程没有执行完毕的时候（被锁住），下一个线程会一直等待（不会进入睡眠状态），当上一线程任务执行完毕，下一线程立即执行。它区别于互斥锁，互斥锁在等待的时候，会进入睡眠状态，当被上一线程执行完毕后，会被唤醒，然后再执行。<br>3.atomic只给setter方法上锁，getter不会加锁<br>4.atomic需要消耗大量的资源，执行效率低<br>———非原子性———</p>
<p>nonatomic：非原子性，非线程安全，多个线程可以同时对其进行访问，使用该属性编译器会少生成加锁代码，提高性能和效率，使用频率高，一般都是放弃安全，提高性能。</p>
</blockquote>
<h6 id="二、访问权限"><a href="#二、访问权限" class="headerlink" title="二、访问权限"></a>二、访问权限</h6><blockquote>
<ul>
<li>readwrite  默认  拥有getter/setter方法  可读可写</li>
<li>readonly  只读属性， 只会生成getter方法，不会生成setter方法</li>
</ul>
</blockquote>
<h6 id="三、内存管理-ARC"><a href="#三、内存管理-ARC" class="headerlink" title="三、内存管理(ARC)"></a>三、内存管理(ARC)</h6><blockquote>
<p>1.assign 默认<br>  适用于基本数据类型：NSInteger、CGFloat和C数据类型 int、float等</p>
<p>2.strong 对应MRC中的retain<br>强引用，只有OC对象才能够使用该属性，它使对象的引用计数加1</p>
<p>3.weak<br>弱引用，只是单纯引用某个对象，但是并未拥有该对象<br>即一个对象被持有无数个弱引用，只要没有强引用指向它，那么它就会被清除释放</p>
<p>4.copy<br>为减少对上下文的依赖而引入的机制，可以理解为内容的拷贝<br>内容被拷贝后，内存中会有两个存储空间存储相同的内容。指针不是同一个地址<br>———UI控件使用weak的原因———：<br>UI控件之所以可以使用弱指针，是因为控制器有强指针指向UIView  <br>UIView 有强指针指向Subviews数组，数组中由强指针指向控件</p>
</blockquote>
<p> <img src="/uploads/images/Objective-C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE%E7%89%87/UI%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%BC%B1%E9%A5%AE%E7%94%A8.png"></p>
<blockquote>
<ul>
<li>代理必须是weak，因为代理一般都是指向控制器，会造成循环引用，无法释放，造成内存泄露</li>
<li>结论：一般，控件的代理都是控制器，而控制器又拥有着该控件，所以，为了不引发循环引用的问题，代理一般都使用weak；</li>
</ul>
<p>———关于weak 与assign———：</p>
<ul>
<li>在ARC，出现循环引用的时候，必须有一端使用weak</li>
<li>weak修饰的对象销毁的时候，指针会自动设置为nil</li>
<li>而assign不会，assign可以用于非OC对象，而weak必须用于OC对象</li>
</ul>
<p>———关于copy与strong———：<br>问：NSString、NSArray、NSDictionary常用copy，为什么不用strong？<br>strong是强引用，指向的是同一个内存地址，copy是内容拷贝，会另外开辟内存空间，指针指向一个不同的内存地址，copy返回的是一    个不可变对象，如果使用strong修饰可变对象，那么对象就会有可能被不经意间修改，有时不是我们想要的，而copy不会发生这种意外。<br>问：关于ARC下，不显示指定属性关键字时，默认关键字有哪些？<br>1.基本数据类型：atomic    readwrite    assign（多线程安全，可读写，弱引用）<br>2.普通OC对象：   atomic    readwrite    strong（多线程，可读写，强引用）<br>———关于@property的作用———：<br>使用@property，编译器会自动为我们添加getter和setter方法。<br>另附一张图：（关于深拷贝和浅拷贝）<br><img src="/uploads/images/Objective-C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%BE%E7%89%87/%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D.png"></p>
</blockquote>
<h4 id="4-变量作用域"><a href="#4-变量作用域" class="headerlink" title="4.变量作用域"></a>4.变量作用域</h4><blockquote>
<ul>
<li>@protected 表示只有该类和其子类可以访问该类的变量.</li>
<li>@public 表示无论是自身还是子类的对象,还是其它类型的对象均能访问该类的变量.</li>
<li>@private 表示只有该类本身的对象可以访问该类的变量.</li>
</ul>
</blockquote>
<h4 id="5-面向对象三大特征"><a href="#5-面向对象三大特征" class="headerlink" title="5.面向对象三大特征:"></a>5.面向对象三大特征:</h4><blockquote>
<ul>
<li>封装:隐藏内部实现,稳定外部接口.</li>
<li>继承:子类继承父类的所有非私有的方法和属性.</li>
<li>多态:不同类型的对象,对同一方法名的不同响应.<br>注意:</li>
<li>要点一:oc中不允许多继承(一个类有多个父类),但允许多重继承(一个类的父类也拥有其自身的父类).</li>
<li>要点二:一个类调用方法时,先从本类方法找,找不到再从父类找,一直往上直到找到NSObject类中.（方法调用链）</li>
</ul>
</blockquote>
<h4 id="6-self、super、id"><a href="#6-self、super、id" class="headerlink" title="6.self、super、id"></a>6.self、super、id</h4><blockquote>
<ul>
<li>self:是指向当前对象的指针.</li>
<li>super:调用父类的方法.</li>
<li>id:是一个指向任何一个继承了NSObject类的对象.</li>
</ul>
</blockquote>
<h4 id="7-开闭原则和里氏替换原则"><a href="#7-开闭原则和里氏替换原则" class="headerlink" title="7.开闭原则和里氏替换原则"></a>7.开闭原则和里氏替换原则</h4><blockquote>
<p>(1)开闭原则(OCP Open Closed Principle):</p>
<p>核心是:对扩展开放,对修改关闭.改变一个软件时,应该通过扩展的方式来改变软件,而不应该修改                    原有的代码来实现变化.</p>
<p>(2)里氏替换原则(LSP Liskov Substitution Principle):(is A)原则:任何基类可以出现的地方,子类一定可以出现.</p>
<p>注意：</p>
<ul>
<li>a.继承必须确保超类所拥有的性质子类中仍然成立.</li>
<li>b.子类对象总是可以替换父类对象.</li>
</ul>
</blockquote>
<h4 id="8-内存管理"><a href="#8-内存管理" class="headerlink" title="8.内存管理"></a>8.内存管理</h4><blockquote>
<p>(1)黄金法则:凡是对象使用了alloc,new,copy和retain,那么必须有相对应的release和autorelease.</p>
<ul>
<li>引用计数机制：对象创建后，运行时系统通过对象维护的一个计数器来描述有多少个其他对象在使用自己，当计数器为0时，释放该对象占用的内存空间（该对象调用dealloc方法）。<br>(2)深复制和浅复制</li>
<li>浅复制:指针拷贝,只复制指向对象的指针,拷贝后原来对象的引用计数会+1.</li>
<li>深复制:对象拷贝,复制引用对象,重新开辟一块内存,原来对象的引用计数不变.<br>(3)OC采用的是引用计数机制管理对象所占的内存.<br>(4)ARC(automotic reference counting)自动引用计数:它会自动加入内存的控制代码,控制对象的生命周期.隐式的管理内存,编译器会在适当的地方自动插入retain,release和autorelease消息.<br>ARC新特征:增加了竖向定义关键字,用strong代替retain,用weak代替assign.<br>(5)内存检测等快捷键</li>
<li>释放内存是dealloc.</li>
<li>内存泄露的快捷键:command+shift+b.</li>
<li>内存泄露检测仪:command+I.<br>(6)字符串内存管理</li>
</ul>
</blockquote>
<pre><code>        //常量字符串,引用计数为-1或无穷大的数
      NSString *str111 =@&quot;kevin&quot;;//常量字符串的声明
      
      [str111 retain];//引用计数对常量字符串没有影响
      
      NSLog(@&quot;%ld&quot;,[str111 retainCount]);
      
      [str111 release];
      
      //用initWithString创建字符串,引用计数为-1或无穷大的数
      
      NSString *str2 = [[NSString alloc]initWithString:@&quot;alen&quot;];
      
      [str2 retain];
      
      NSLog(@&quot;%ld&quot;,[str2 retainCount]);
     
      [str2 release];
      
      [str2 release];
      
      //用initWithFormat创建字符串,引用计数为1(符合引用计数机制)
      NSString *str333 = [[NSString alloc]initWithFormat:@&quot;steven&quot;];
     
      [str333 retain];
      
      NSLog(@&quot;%ld&quot;,[str3 retainCount]);
      
      [str333 release];
      
      [str333 release];
</code></pre>
<blockquote>
<p>注意:OC中的引用计数永远不可能为0.<br>(7)程序在内存中运行,分几个区?各自用途?</p>
<ul>
<li>a.栈区  由编译器自动分配释放存放函数的参数值,局部变量值等.（比较小，存量有限）</li>
<li>b.堆区  一般由程序员手动分配释放,如果不释放可由系统释放.</li>
<li>c.数据区 存储全局和静态变量.</li>
<li>d.代码区 存放函数体的二进制代码.<br>(8)引用和指针的区别?</li>
<li>引用是给变量起一个别名,也就是一个变量有两个名字,他们是同一块空间.</li>
<li>指针是分配一块内存用来保存变量的地址,间接引用变量.</li>
</ul>
</blockquote>
<h4 id="9-类别-类拓展-协议"><a href="#9-类别-类拓展-协议" class="headerlink" title="9.类别,类拓展,协议"></a>9.类别,类拓展,协议</h4><blockquote>
<ul>
<li>类别(category):为已有的类添加方法.（不能添加实例变量。）（命名方法为：类名+类别名）</li>
<li>类拓展(extension):为类添加私有方法.（不必实现所有方法，可以添加实例变量）</li>
<li>协议(protocol):就是类A不方便实现的方法,委托类B实现.协议有两个修饰词:@required(必须实现的方法),@optional(选择实现的方法)</li>
</ul>
</blockquote>
<h4 id="10-KVC-KVO以及通知中心"><a href="#10-KVC-KVO以及通知中心" class="headerlink" title="10.KVC,KVO以及通知中心"></a>10.KVC,KVO以及通知中心</h4><blockquote>
<p>(1)KVC(key-value Coding)键值编码,是一种间接访问对象属性的方法.包括:setVaule: forKey: 和 valueForKey: 两个方法.<br>(2)KVO(key-value OBserving)键值监听,它提供了一种监测属性变化的方法.</p>
</blockquote>
<pre><code>//注册监听者
     -(void)addobserver&#123;
     [self addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];
     &#125;
     
     //监听后返回消息
     -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123;
     NSLog(@&quot;%@ %@&quot;,context,change);
     &#125;
     
     //移除监听者
     -(void)dealloc&#123;
     //[self removeObserver:self forKeyPath:@&quot;name&quot;];
     [name release];
     [super dealloc];
     &#125;
   
</code></pre>
<p>(3)通知(Notification)      </p>
<pre><code>     &#123;
       //注册通知
     -(void)registerNotification&#123;
     NSNotification *notification;
     notification = [[NSNotification alloc]initWithName:MEETINGNOTIFICATION object:nil userInfo:nil];
     &#125;

       //添加监听者
     -(void)addObserver:(Workers *)worker&#123;
     [[NSNotificationCenter defaultCenter] addObserver:worker selector:@selector(getNotification) name:MEETINGNOTIFICATION object:nil];
     &#125;
     
       //创建并发送通知
     -(void)postNotification&#123;
     [[NSNotificationCenter defaultCenter] postNotificationName:MEETINGNOTIFICATION object:nil];
     &#125;
     
       //移除监听者
     -(void)removrNotification:(Workers *)worker&#123;
     [[NSNotificationCenter defaultCenter] removeObserver:worker name:MEETINGNOTIFICATION object:nil];
     &#125;
     
</code></pre>
<blockquote>
<p>另外一种实现通知传值的方法（简书）</p>
</blockquote>
<pre><code>        第1步：在发送者中实现一个方法进行发送通知。
        NSDicitionary *dict=@&#123;@“color”:coloe,@“userName”:@“haha”&#125;;
        
        [[NSNotificationCenter defaultCenter] postNotificationName:@“chandeBgColor” object：nil
                                        userInfo:dict];
                                        
        //postNotificationName:之后的参数就是这个通知的名字，要和接受者的名字一样，擦能让接收者            正确接收。
        
        //object:接收对象
        
        //userInfo：携带的参数，在例子中我携带了一个字典，因为有时候我们要传递的参数不只是一个    ,所以把东西全部都放在通知里面，在接收着中，根据字典里面的键来取出里面的值。
        
        //在字典中传递的color是一个已经实例化后的对象
        
        第2步：在接收者中注册通知，也就是接收者要进行接收通知，接收通知和发送通知的名字要一致。
        
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeBgColor:)                                name:@“changeBgColor”
                object:nil];
                
        //注意：务必让接收者中name后面的参数和发送者中的name后面参数一样。
        
        第3步：在接收者中实现通知中的方法
        
        //参数类型是NSNotification
        -(void)changeBgcolor:(NSNotification *)notification&#123;
        
        NSLog(@“接收到通知，改变背景颜色”);
        
        //如果是传多个数据，那么需要哪个数据，就对应去除对应的数据即可
        
        self.view.backgroundColor=notification.userIfo[@“color”];
        
        UIlabel *label=(UILabel *)[self.view viewWithTag:100];

        label.text=notification.userInfo[@“username”];

        &#125;
</code></pre>
<h4 id="11-delegate和Notification的区别"><a href="#11-delegate和Notification的区别" class="headerlink" title="11. delegate和Notification的区别?"></a>11. delegate和Notification的区别?</h4><blockquote>
<ul>
<li>delegate针对one-to-one关系，并且reciever可以返回值给sender；</li>
<li>notification 可以针对one-to-one/many/none,reciever无法返回值给sender；</li>
<li>所以，delegate用于sender希望接受到reciever的某个功能反馈值，notification用于通            知多个object某个事件</li>
</ul>
</blockquote>
<h4 id="12-可变和不可变的具体意思"><a href="#12-可变和不可变的具体意思" class="headerlink" title="12.可变和不可变的具体意思?"></a>12.可变和不可变的具体意思?</h4><blockquote>
<p>不可变得意思是,当一个对象初始化后,它的内存里面存的值不能改变了(调用的时候,一般是把值    复制一份传个另一个变量).可变是,这个对象的内存值是可以改变的.</p>
</blockquote>
<h4 id="13-集合类"><a href="#13-集合类" class="headerlink" title="13.集合类"></a>13.集合类</h4><h5 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1.遍历"></a>1.遍历</h5><pre><code>//字典遍历
     for (int i = 0; i &lt; [[dict allValues] count]; i++) &#123;
     NSLog(@&quot;%@=%@&quot;,[[dict allKeys] objectAtIndex:i],[[dict allValues] objectAtIndex:i]);
     &#125;

//数组遍历
 方式一：
     for (int index = 0; index &lt; [arr3 count]; index++) &#123;
     NSLog(@&quot;%@&quot;,[arr3 objectAtIndex:index]);
     &#125;
     NSLog(@&quot;-------------------------------&quot;);
 方式二：
       快速枚举法
     for (id object in arr1) &#123;
     NSLog(@&quot;%@&quot;,object);
     &#125;
</code></pre>
<blockquote>
<p> 注意:<br>  a.{}表示字典  ()表示数组  {()}表示集<br>  b.键是唯一的,一个对象(value)可以对应多个键(key).<br>  c.集合是无序的.</p>
</blockquote>
<h5 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h5><pre><code>//数组排序
     方法一:
     NSArray *arr = @[[NSNumber numberWithInt:23],[NSNumber numberWithInt:16],                                [NSNumber numberWithInt:28],[NSNumber numberWithInt:90],                                [NSNumber numberWithInt:4]];//新语法(定义)
     NSArray *sortedArr = [arr sortedArrayUsingSelector:@selector(compare:)];
     NSLog(@&quot;%@&quot;,sortedArr);

      方法二:
     Student *stu1 =[[Student alloc]init];
     stu1.score=85;
     Student *stu2 = [[Student alloc]init];
     stu2.score=79;
     Student *stu3 = [[Student alloc]init];
     stu3.score=98;
     NSArray *stuArr =@[stu1,stu2,stu3];
     NSArray *sortedStuArr = [stuArr sortedArrayUsingSelector:
                                        @selector(compareStudent:)];
     for (int i = 0; i &lt; [sortedStuArr count]; i++) &#123;
     Student *stu = [sortedStuArr objectAtIndex:i] ;
     NSLog(@&quot;%lf&quot;,stu.score);
     &#125;
     //倒序排列:
     -(void)invert&#123;
     for (int i = 0; i &lt; [self count]/2; i++) &#123;
     [self exchangeObjectAtIndex:i withObjectAtIndex:[self count]-i-1];
     &#125;
     &#125;
</code></pre>
<h4 id="14-命名常量（Constants）"><a href="#14-命名常量（Constants）" class="headerlink" title="14.命名常量（Constants）"></a>14.命名常量（Constants）</h4><blockquote>
<p>如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。<br>建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a> 一文：</p>
</blockquote>
<pre><code>//定义一个枚举
typedef NS_ENUM(NSInteger, NSMatrixMode) &#123;
NSRadioModeMatrix,
NSHighlightModeMatrix,
NSListModeMatrix,
NSTrackModeMatrix
&#125;;
//定义bit map
typedef NS_OPTIONS(NSUInteger, NSWindowMask) &#123;
NSBorderlessWindowMask      = 0,
NSTitledWindowMask          = 1 &lt;&lt; 0,
NSClosableWindowMask        = 1 &lt;&lt; 1,
NSMiniaturizableWindowMask  = 1 &lt;&lt; 2,
NSResizableWindowMask       = 1 &lt;&lt; 3
&#125;;
</code></pre>
<blockquote>
<p>使用<code>const</code>定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同：<br>const float NSLightGray;<br>不要使用<code>#define</code>宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用<code>const</code>定义。<code>#define</code>通常用来给编译器决定是否编译某块代码，比如常用的：</p>
</blockquote>
<pre><code> #ifdef DEBUG
</code></pre>
<blockquote>
<p>注意到一般由编译器定义的宏会在前后都有一个<code>__</code>，比如*<code>__MACH__</code>*。</p>
</blockquote>
<h4 id="15-注释中引用参数名或者方法函数名"><a href="#15-注释中引用参数名或者方法函数名" class="headerlink" title="15.注释中引用参数名或者方法函数名"></a>15.注释中引用参数名或者方法函数名</h4><blockquote>
<p>如果在注释中要引用参数名或者方法函数名，使用<code>||</code>将参数或者方法括起来以避免歧义：</p>
</blockquote>
<pre><code>// Sometimes we need |count| to be less than zero.

// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|
</code></pre>
<h4 id="16-Public-API要尽量简洁"><a href="#16-Public-API要尽量简洁" class="headerlink" title="16.Public API要尽量简洁"></a>16.Public API要尽量简洁</h4><blockquote>
<p>共有接口要设计的简洁，满足核心的功能需求就可以了。不要设计很少会被用到，但是参数极其复杂的API。如果要定义复杂的方法，使用类别或者类扩展。 </p>
</blockquote>
<h4 id="17-import和-include"><a href="#17-import和-include" class="headerlink" title="17.#import和#include"></a>17.#import和#include</h4><blockquote>
<p>——-<code>#import</code>是Cocoa中常用的引用头文件的方式，它能自动防止重复引用文件，什么时候使用<code>#import</code>，什么时候使用<code>#include</code>呢——？</p>
<ul>
<li><p>当引用的是一个Objective-C或者Objective-C++的头文件时，使用<code>#import</code></p>
</li>
<li><p>当引用的是一个C或者C++的头文件时，使用<code>#include</code>，这时必须要保证被引用的文件提供了保护域（#define guard）。<br>栗子：</p>
<pre><code>          #import &lt;Cocoa/Cocoa.h&gt;
          #include &lt;CoreFoundation/CoreFoundation.h&gt;
          #import &quot;GTMFoo.h&quot;
          #include &quot;base/basictypes.h&quot;
</code></pre>
</li>
<li><p>—–为什么不全部使用<code>#import</code>呢——？<br>主要是为了保证代码在不同平台间共享时不出现问题。</p>
</li>
</ul>
</blockquote>
<h4 id="18-引用框架的根头文件"><a href="#18-引用框架的根头文件" class="headerlink" title="18.引用框架的根头文件"></a>18.引用框架的根头文件</h4><blockquote>
<p>上面提到过，每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。</p>
</blockquote>
<pre><code>    //正确，引用根头文件
    #import &lt;Foundation/Foundation.h&gt;

    //错误，不要单独引用框架内的其它头文件
    #import &lt;Foundation/NSArray.h&gt;
    #import &lt;Foundation/NSString.h&gt;
</code></pre>
<h4 id="19-BOOL的使用"><a href="#19-BOOL的使用" class="headerlink" title="19.BOOL的使用"></a>19.BOOL的使用</h4><blockquote>
<p>BOOL在Objective-C中被定义为<code>signed char</code>类型，这意味着一个BOOL类型的变量不仅仅可以表示<code>YES</code>(1)和<code>NO</code>(0)两个值，所以永远<strong>不要</strong>将BOOL类型变量直接和<code>YES</code>比较</p>
</blockquote>
<pre><code>//错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较
BOOL great = [foo isGreat];
if (great == YES)    
// ...be great!

//正确
BOOL great = [foo isGreat];
if (great)
 // ...be great!
</code></pre>
<blockquote>
<p>同样的，也不要将其它类型的值作为BOOL来返回，这种情况下，BOOL变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如<code>&amp;&amp;</code>,<code>||</code>,<code>!</code>的返回是可以直接赋给BOOL的：</p>
</blockquote>
<pre><code>//错误，不要将其它类型转化为BOOL返回
- (BOOL)isBold &#123;
  return [self fontTraits] &amp; NSFontBoldTrait;
&#125;
- (BOOL)isValid &#123;
  return [self stringValue];
&#125;

//正确
- (BOOL)isBold &#123;
      return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;
&#125;

//正确，逻辑操作符可以直接转化为BOOL
- (BOOL)isValid &#123;
   return [self stringValue] != nil;
&#125;
- (BOOL)isEnabled &#123;
   return [self isValid] &amp;&amp; [self isBold];
&#125;
</code></pre>
<blockquote>
<p>另外BOOL类型可以和<code>_Bool</code>,<code>bool</code>相互转化，但是<strong>不能</strong>和<code>Boolean</code>转化。</p>
</blockquote>
<h4 id="20-使用ARC"><a href="#20-使用ARC" class="headerlink" title="20.使用ARC"></a>20.使用ARC</h4><blockquote>
<p>除非想要兼容一些古董级的机器和操作系统，我们没有理由放弃使用ARC。在最新版的Xcode(6.2)中，ARC是自动打开的，所以直接使用就好了。<br>——— 在init和dealloc中不要用存取方法访问实例变量———–<br>当<code>init``dealloc</code>方法被执行时，类的运行时环境不是处于正常状态的，使用存取方法访问变量可能会导致不可预料的结果，因此应当在这两个方法内直接访问实例变量。</p>
</blockquote>
<pre><code>//正确，直接访问实例变量
- (instancetype)init &#123;
   self = [super init];
   if (self) &#123;
       _bar = [[NSMutableString alloc] init];
  &#125;
  return self;
  &#125;
- (void)dealloc &#123;
  [_bar release];
 [super dealloc];
 &#125;

//错误，不要通过存取方法访问
- (instancetype)init &#123;
self = [super init];
if (self) &#123;
self.bar = [NSMutableString string];
&#125;
return self;
&#125;
- (void)dealloc &#123;
self.bar = nil;
[super dealloc];
&#125;
</code></pre>
<h4 id="21-保证NSString在赋值时被复制"><a href="#21-保证NSString在赋值时被复制" class="headerlink" title="21.保证NSString在赋值时被复制"></a>21.保证NSString在赋值时被复制</h4><blockquote>
<p><code>NSString</code>非常常用，在它被传递或者赋值时应当保证是以复制（copy）的方式进行的，这样可以防止在不知情的情况下String的值被其它对象修改。</p>
</blockquote>
<pre><code>- (void)setFoo:(NSString *)aFoo &#123;
 _foo = [aFoo copy];
&#125;
</code></pre>
<h4 id="22-使用NSNumber的语法糖"><a href="#22-使用NSNumber的语法糖" class="headerlink" title="22.使用NSNumber的语法糖"></a>22.使用NSNumber的语法糖</h4><blockquote>
<p>使用带有<code>@</code>符号的语法糖来生成NSNumber对象能使代码更简洁：</p>
</blockquote>
<pre><code>NSNumber *fortyTwo = @42;（会自动完成转换）
NSNumber *piOverTwo = @(M_PI / 2);
enum &#123;
 kMyEnum = 2;
&#125;;
NSNumber *myEnum = @(kMyEnum);
</code></pre>
<h4 id="23-nil检查"><a href="#23-nil检查" class="headerlink" title="23.nil检查"></a>23.nil检查</h4><blockquote>
<p>因为在Objective-C中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。<br>另外，不要使用诸如<code>nil == Object</code>或者<code>Object == nil</code>的形式来判断。</p>
</blockquote>
<pre><code>//正确，直接判断
if (!objc) &#123;
    ...    
&#125;
//错误，不要使用nil == Object的形式
if (nil == objc) &#123;
    ...    
&#125;
</code></pre>
<h4 id="24-属性的线程安全"><a href="#24-属性的线程安全" class="headerlink" title="24.属性的线程安全"></a>24.属性的线程安全</h4><blockquote>
<p>定义一个属性时，编译器会自动生成线程安全的存取方法（Atomic），但这样会大大降低性能，特别是对于那些需要频繁存取的属性来说，是极大的浪费。所以如果定义的属性不需要线程保护，记得手动添加属性关键字<code>nonatomic</code>来取消编译器的优化。</p>
</blockquote>
<h4 id="25-点分语法的使用"><a href="#25-点分语法的使用" class="headerlink" title="25.点分语法的使用"></a>25.点分语法的使用</h4><blockquote>
<p>不要用点分语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题。</p>
</blockquote>
<pre><code>//正确，使用点分语法访问属性
NSString *oldName = myObject.name;
myObject.name = @&quot;Alice&quot;;

//错误，不要用点分语法调用方法
NSArray *array = [NSArray arrayWithObject:@&quot;hello&quot;];
NSUInteger numberOfItems = array.count;
array.release;
</code></pre>
<h4 id="26-Delegate要使用弱引用"><a href="#26-Delegate要使用弱引用" class="headerlink" title="26.Delegate要使用弱引用"></a>26.Delegate要使用弱引用</h4><blockquote>
<p>一个类的Delegate对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。</p>
</blockquote>
<pre><code>/** delegate */
@property (nonatomic, weak) id &lt;IPCConnectHandlerDelegate&gt; delegate;
</code></pre>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">Job Interview</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Written examination</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/面试、笔试//" class="article-tag-list-link color1">面试、笔试</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2019/08/26/Objective-C%E9%9C%80%E8%A6%81%E8%AE%B0%E5%BF%86%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ReactiveCocoa and MVVM, 一次不错的实践" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2019/02/21/ReactiveCocoa%20and%20MVVM,%20%E4%B8%80%E6%AC%A1%E4%B8%8D%E9%94%99%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank">A good application for ReactiveCocoa and MVVM</a>
  
    </h1>
  


  
  
<a href="/2019/02/21/ReactiveCocoa%20and%20MVVM,%20%E4%B8%80%E6%AC%A1%E4%B8%8D%E9%94%99%E7%9A%84%E5%AE%9E%E8%B7%B5/" class="archive-article-date">
        <time datetime="2019-02-21T01:52:04.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-02-21</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p>Description：</p>
<ul>
<li>标题是英文的，只是在为托福做准备，所以希望在任何可以的地方练习一下英文的说和写。</li>
<li>本篇不再介绍基础的MVVM和RAC知识，所以在看本篇文章时，请确定你已经读了上一篇关于RAC+MVVM的文章，或者你已经对MVVM和RAC已经有很多的了解，你也可以直接阅读。</li>
<li>请带着批判的眼光来审视这篇文章，因为没有什么是完美的，假如可以催生出你更多的想法，那我花时间来写这篇文章也是很有价值的，</li>
</ul>
<h2 id="使用MVVM和RAC会解决你什么问题？"><a href="#使用MVVM和RAC会解决你什么问题？" class="headerlink" title="使用MVVM和RAC会解决你什么问题？"></a>使用MVVM和RAC会解决你什么问题？</h2><p>这个要从结果来看：</p>
<h3 id="代码更加“紧密”："><a href="#代码更加“紧密”：" class="headerlink" title="代码更加“紧密”："></a>代码更加“紧密”：</h3><p>我的意思是说，你可以利用类似<strong>rac_signalForControlEvents：</strong>这样的方法将按钮或者其他控件的响应事件就写在<strong>subscribeNext</strong>：的block中，像下面这样：</p>
<pre><code>-(LeftImageButton *)subjectHomework_button&#123;
if (!_subjectHomework_button) &#123;
    _subjectHomework_button=[[LeftImageButton alloc] init];
    _subjectHomework_button.left_imageView.image=[UIImage imageNamed:@&quot;项目制学习作业&quot;];
    _subjectHomework_button.right_label.text=@&quot;项目制学习作业布置&quot;;
    _subjectHomework_button.backgroundColor=fifty_nine_BACKGROUND_COLOR;
    [[_subjectHomework_button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(__kindof UIControl * _Nullable x) &#123;
        SNSubjectHomeworkViewController *subjectHomework_VC=[[SNSubjectHomeworkViewController alloc] init];
        [self.navigationController pushViewController:subjectHomework_VC animated:true];
    &#125;];
&#125;
return _subjectHomework_button;
&#125;
</code></pre>
<p>按钮的点击事件写在了懒加载的部分，这样的代码在维护起来很便利，否则用addTarget: action:forControlEvents:实现点击事件的代码中，其他方法的点击事件也有很多，很杂，m文件会充斥着大量的代码，你不断的command+c和command+f，你会被一个.m文件就搞得晕头转向。<br>还有像下面这样将通知的实现也写在监听通知信号的订阅block中：</p>
<pre><code>[[[NSNotificationCenter defaultCenter] rac_addObserverForName:GOT_INFORMATION_NOTI object:nil] subscribeNext:^(NSNotification * _Nullable x) &#123;
    [self setHeadImage];
&#125;];
</code></pre>
<h3 id="VC真的瘦下来了："><a href="#VC真的瘦下来了：" class="headerlink" title="VC真的瘦下来了："></a>VC真的瘦下来了：</h3><p>对于一个处女座来说，在用了MVVM和RAC后我已经落下了几滴感动的眼泪。曾经一个燥热的午后，我在仿写QQ音乐App，为了设计那么美妙操作体验，我的VC不知不觉就1000+行，后来想要再更改操作逻辑时，简直是噩梦，除了上面所说的方法太多，跳来跳去，脑子就晕了。还有代码的分布没有一个规矩和风格，这在代码量少的时候无关紧要，但是在代码量多的时候，就会导致维护或更改时太痛苦了。</p>
<p>所以那个午后我终于明白了使VC瘦下来的必要性，同时也必须要形成一套编程风格。后来我的代码是这样组织的：</p>
<pre><code>#pragma mark - 初始化UI

#pragma mark - 懒加载

#pragma mark - 代理

#pragma mark - target action

#pragma mark - Maonry

#pragma mark - other 只有本页面会使用的工具方法
</code></pre>
<p>这是一个基本的组织方法，把对应的代码都组织在特定的方法组中，这样不仅便于自己开发，还对后来维护你项目的人也很友好。还有更好的一点，有时候出现了crash，在控制台的提示信息中你就可以知道哪一个部分出了问题，找到对应的方法组修改即可。</p>
<p>回到正题，VC真的瘦下来了，Model、ViewModel、View各司其职，HomeVC一般是最容易堆积代码的地方，但是在MVVM下，我的每一个VC基本都控制在500行以下，她真正的瘦下来了。如果减肥有这么简单就好了。</p>
<p>好的，下面会以邮箱功能做一个简单的阐述，这只是一个站内信的邮箱功能，没有很多代码。</p>
<p>在MVVM下，我是这样设计View层的，在SNTeacherMailViewController中有一个tableView用来显示邮箱列表：</p>
<pre><code>@property(nonatomic,strong)UITableView *tableView;
</code></pre>
<p>懒加载：</p>
<pre><code>-(UITableView *)tableView&#123;
if (!_tableView) &#123;
    _tableView=[[UITableView alloc] init];
    _tableView.delegate=self;
    _tableView.dataSource=self;
    _tableView.layer.cornerRadius=20.0;
    _tableView.backgroundColor=[UIColor whiteColor];
    _tableView.separatorInset=UIEdgeInsetsMake(0,SNTrueHeight(40), 0, SNTrueHeight(40));//top left bottom right 左右边距相同
    _tableView.separatorStyle=UITableViewCellSeparatorStyleSingleLine;
    
    [_tableView registerClass:[MailTableViewCell class] forCellReuseIdentifier:teacher_mail_cell_reuse];
&#125;
return _tableView;
&#125;
</code></pre>
<p>下面要实现tableView的数据源和代理方法，ok，但是数据从哪里拿？VC在MVVM下已经被划分到View层，所以在SNTeacherMailViewController中不会再写发送网络请求的代码，而ViewModel是呈现给View数据的一个好帮手，网络请求将会在ViewModel中实现，并通过把ViewModel当作VC的一个属性来让VC获得数据。所以在实现tabeView的数据源和代理方法前，先来看看ViewModel，这是TeacherMailViewModel的头文件，</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

NS_ASSUME_NONNULL_BEGIN

@interface TeacherMailViewModel : NSObject

@property(nonatomic,strong,readonly)RACCommand *command;
@property(nonatomic,strong,readonly)NSArray *mailArray;
/**
 获得邮箱数据
 */
-(void)getMailInformations;

@end
</code></pre>
<p>他需要给SNTeacherMailViewController提供数据，所以他通过暴露mailArray属性来给SNTeacherMailViewController的tableView提供数据，其他部分你应当好好看一看，我还又一个方法：</p>
<pre><code>-(void)getMailInformations;
</code></pre>
<p>这个方法不会直接在VC中调用获得数据的，注意到</p>
<pre><code>@property(nonatomic,strong,readonly)RACCommand *command;
</code></pre>
<p>了吗，这个就是发送网络请求的东西，所以getMailInformations：方法的实现将会是这样子：</p>
<pre><code>-(void)getMailInformations&#123;
@weakify(self);
self.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;
    @strongify(self);
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;
        @strongify(self);
        
        NSMutableDictionary *header=[NSMutableDictionary dictionaryWithObject:[[UserInfoHandler sharedUserInfoHandler] userToken] forKey:@&quot;token&quot;];
        NSMutableDictionary *body=[NSMutableDictionary dictionaryWithObject:@&quot;nothing&quot; forKey:@&quot;nothing&quot;];
        
        [[SNAFNetManager sharedManager] requestWithURLString:API_URL_messageTraining header:header parameters:body subModel:[TeacherMailModel class] success:^(BasicResponseModel * _Nonnull successData) &#123;
            self.mailArray=successData.data;
            //发送订阅信号
            [subscriber sendNext:@&quot;&quot;];
            //发送结束信号
            [subscriber sendCompleted];
        &#125; failure:^(BasicResponseModel * _Nonnull failureData) &#123;
            
        &#125; progressPercentBlock:^(float percent) &#123;
            
        &#125;];
        
        return nil;
    &#125;];
&#125;];
&#125;
</code></pre>
<p>在方法中，当需要发送请求时就通过封装好的网络类方法发送了一个请求，并且在success回调block中，把网络数据赋值到了self.mailArray中。</p>
<p>前面说过getMailInformations：这个方法不会直接在VC中调用获得数据的，那怎么触发这个网络请求呢？好，现在看VC</p>
<pre><code>@property(nonatomic,strong)TeacherMailViewModel *viewModel;    
</code></pre>
<p>就像前面说好的，需要一个viewModel属性。还需要初始化：</p>
<pre><code>-(TeacherMailViewModel *)viewModel&#123;
if (!_viewModel) &#123;
    _viewModel=[[TeacherMailViewModel alloc] init];
    
    [_viewModel getMailInformations];
&#125;
return _viewModel;
&#125;
</code></pre>
<p>诶诶诶？怎么getMailInformations：方法直接在viewModel的初始化方法里面调用了？其实他只是相当一个“注册”，真正想要执行command的内部信号的时候需要主动调用下:</p>
<pre><code>[command execute:nil]
</code></pre>
<p>好的，所以一切都做好后，那么需要执行command了，</p>
<pre><code>- (void)subscribeNextViewModel &#123;
@weakify(self);
//将命令执行后的数据交给controller
[self.viewModel.command.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123;
    @strongify(self);
    [self.tableView reloadData];
&#125;];

//执行command
[self.viewModel.command execute:nil];
&#125;
</code></pre>
<p>而且这里订阅了self.viewModel.command的信号，当网络请求里：</p>
<pre><code>[subscriber sendCompleted];
</code></pre>
<p>之后，这里将会订阅到信号，并且刷新一下表格数据：</p>
<pre><code>[self.viewModel.command.executionSignals.switchToLatest subscribeNext:^(id _Nullable x) &#123;
    @strongify(self);
    [self.tableView reloadData];
&#125;];
</code></pre>
<p>好的，实现tableView的数据源和代理方法吧，它会是这样子的：</p>
<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;
return self.viewModel.mailArray.count;
&#125;
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;
MailTableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:teacher_mail_cell_reuse];
if (cell==nil) &#123;
    cell=[[MailTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:teacher_mail_cell_reuse];
&#125;

cell.viewModel_teacher=self.viewModel.mailArray[indexPath.row];

return cell;
&#125;    
</code></pre>
<p>这里的自定义cell也有一个viewModel属性，实际上，他已经不算作一个viewModel了，只是一个单纯的Model，</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &quot;SNMailModel.h&quot;
#import &quot;TeacherMailModel.h&quot;
NS_ASSUME_NONNULL_BEGIN

@interface MailTableViewCell : UITableViewCell
@property(nonatomic,strong)TeacherMailModel *viewModel_teacher;
@end
</code></pre>
<p>没错吧。然后在自定义cell的实现文件中，绑定数据：</p>
<pre><code>//老师端数据绑定
[RACObserve(self, viewModel_teacher.content) subscribeNext:^(NSString *  _Nullable x) &#123;
    self.detail_label.text=x;
&#125;];
[RACObserve(self, viewModel_teacher.updateDate) subscribeNext:^(NSString *  _Nullable x) &#123;
    self.date_label.text=x;
&#125;];
</code></pre>
<p>最后，在SNTeacherMailViewController中就可多次的调用subscribeNextViewModel：方法了，不管是viewDidLoad或者viewWillAppear，或者你用了上拉刷新，下拉你都可以调用subscribeNextViewModel：方法，你只需要告诉他你需要数据了，然后他就会请求网络的到数据，然后他知道怎么填充数据，实际上有了RAC，数据改变都是通过类似管道一样的东西散发出去的，只要viewModel中提供数据的mailArray数组发生了改变，那么其他所有订阅了该信号的地方，也都会更改数据，函数响应式编程是个好东西。</p>
<p>你也许产生怀疑了🤨，对于这个场景，我在VC中写好一个网络请求方法，需要的时候调用不就ok了吗，为什么搞这么多东西。是的，MVVM在逻辑很少的情形下，的确感觉有点更麻烦了呢，不过你相信我，当你的VC有超过5个或者10个网络请求后，VC的代码也就开始爆增，而状态又很多的情况下，那么bug会更多，也会更加难维护，后面的维护人员，拿到你的代码2000行，3000，他不会钦佩你多么牛，他只会埋冤你写的代码真正的massive，因为他很难看懂你的代码，同时也很难改，生怕改错什么地方，这是开发了一段时间的人都会体验到的。</p>
<p>ok，你已经又大致的感觉了，但是其中的数据流向你可能还没有搞懂，理解不了数据流向，你可能只会照葫芦画瓢，但是不理解应该怎样用到自己的业务场景中。同时希望下面的图帮到你。</p>
<p><img src="/uploads/images/MVVM_IMAGE.png"></p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">RAC+MVVM</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/RAC-MVVM//" class="article-tag-list-link color4">RAC+MVVM</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2019/02/21/ReactiveCocoa%20and%20MVVM,%20%E4%B8%80%E6%AC%A1%E4%B8%8D%E9%94%99%E7%9A%84%E5%AE%9E%E8%B7%B5/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ReactiveCocoa and MVVM, an Introduction" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2019/02/20/ReactiveCocoa%20and%20MVVM,%20an%20Introduction/" target="_blank">ReactiveCocoa and MVVM, an Introduction.</a>
  
    </h1>
  


  
  
<a href="/2019/02/20/ReactiveCocoa%20and%20MVVM,%20an%20Introduction/" class="archive-article-date">
        <time datetime="2019-02-20T09:32:59.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-02-20</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p>以下内容引用自：<a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/"></a>，翻译自ReactiveCocoa and MVVM, an Introduction。这篇文章是MVVM最详尽的一个说明。非常建议多看几遍，完全理解其中的概念和思想。阅读该文章前需要掌握基本的ReactiveCocoa知识。</p>
<h1 id="什么是MVC以及为什么需要MVVM？"><a href="#什么是MVC以及为什么需要MVVM？" class="headerlink" title="什么是MVC以及为什么需要MVVM？"></a>什么是MVC以及为什么需要MVVM？</h1><p>任何一个正经开发过一阵子软件的人都熟悉<strong>MVC</strong>. 它意思是<strong>Model View Controller</strong>, 是一个在复杂应用设计中组织代码的公认模式. 它也被证实在 iOS 开发中有着第二种含义: <strong>Massive View Controller(重量级视图控制器)</strong>. 它让许多程序员绞尽脑汁如何去使代码被解耦和组织地让人满意. 总的来说, iOS 开发者已经得出结论: 他们需要给视图控制器瘦身, 并进一步分离事物;但该怎么做呢?</p>
<h1 id="MVVM来了"><a href="#MVVM来了" class="headerlink" title="MVVM来了"></a>MVVM来了</h1><p>于是<strong>MVVM</strong>流行起来, 它代表Model View View-Model, 它在这帮助我们创建更易处理, 更佳设计的代码.</p>
<p>有时候违背苹果建议的编码方式并不是个好做法. 我不是说不赞成这样子, 我指的是可能会弊大于利. 比如我不建议你去实现个自己的 view controller 基类并试着自己处理视图生命周期.</p>
<p>带着这种情绪, 我想提个问题: <strong>使用除苹果推荐的 MVC 之外的应用设计模式是愚蠢的么?</strong></p>
<p>不. 有两个原因.</p>
<p>苹果没有为解决重量级试图控制器问题提供真正的指导. 他们留给我们来解决如何向代码添加更多清晰的思路. 用 MVVM 来实现这个目的想必是极好哒. (在15年 WWDC 的一些视频中, 苹果工程师在屏幕上的示例代码的确少许出现了 view-model, 不知道是否因为有它才成为了示例代码)<br>MVVM, 至少是我将要在这里展示的 MVVM 的风格, 都跟 MVC 十分兼容. 仿佛我们将 MVC 进行到下一个逻辑步骤.</p>
<p>我不会提及 MVC/MVVM 的历史, 因为其他地方已经有所介绍, 并且我也不精通. 我将会关注如何用它进行 iOS/Mac 开发.</p>
<h2 id="定义-MVVM"><a href="#定义-MVVM" class="headerlink" title="定义 MVVM"></a>定义 MVVM</h2><ol>
<li><strong>Model</strong> - model 在 MVVM 中没有真正的变化. 取决于你的偏好, 你的 model 可能会或可能不会封装一些额外的业务逻辑工作. 我更倾向于把它当做一个容纳表现数据-模型对象信息的结构体, 并在一个单独的管理类中维护的创建/管理模型的统一逻辑.</li>
<li><strong>View</strong> - view 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作.</li>
<li><strong>View-Model</strong> - 这个术语本身会带来困惑, 因为它混搭了两个我们已知的术语, 但却是完全不同的东东. 它不是传统数据-模型结构中模型的意思(又来了, 只是我喜欢这个例子). 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据.</li>
</ol>
<h4 id="关于-view-model-的更多内容"><a href="#关于-view-model-的更多内容" class="headerlink" title="关于 view-model 的更多内容"></a>关于 view-model 的更多内容</h4><p><strong>view-model</strong> 一词的确不能充分表达我们的意图. 一个更好的术语可能是 “View Coordinator”. 你可以认为它就像是电视新闻主播背后的研究人员和作家团队. 它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象). 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用).</p>
<h2 id="MVC-世界中的-MVVM"><a href="#MVC-世界中的-MVVM" class="headerlink" title="MVC 世界中的 MVVM"></a>MVC 世界中的 MVVM</h2><p>我认为 MVVM 这个首字母缩写如同 view-model 术语一样, 对如何使用它们进行 iOS 开发体现得有点不太准确. 让我们再检查下这个首字母缩写, 了解下它是怎么与 MVC 融为一体的.</p>
<p>为了图解表示, 我们颠倒了 <strong>MVC</strong> 中的 <strong>V</strong>和 <strong>C</strong>, 于是首字母缩写更能准确地反映出组件间的关系方位, 给我们带来 <strong>MCV</strong>. 我也会对 <strong>MVVM</strong> 这么干, 将 <strong>V(iew)</strong> 移到 <strong>VM</strong> 的右边最终成为了 <strong>MVMV</strong>. (我相信这些首字母缩写起初不排成这样更合理的顺序是有原因的. )</p>
<p>这是这两种模式如何在 iOS 中组装在一起的简单映射:</p>
<p><img src="http://www.sprynthesis.com/assets/images/MCVMVMV.svg"></p>
<ul>
<li>我试图遵循区块尺寸(非常)大致对应它们负责的工作量.</li>
<li><strong>注意到视图控制器有多大**</strong>?**</li>
<li>你可以看到我们巨大的视图控制器和 view-model 之间有大块工作上的重合.</li>
<li>你也可以看看视图控制器在 MVVM 中的足迹有多大一部分是跟视图重合的.</li>
</ul>
<p>你大可安心获知我们并没有真的去除视图控制器的概念或抛弃 “controller” 术语来匹配 MVVM. (唷. )我们正要将重合的那块工作剥离到 view-model 中, 并让视图控制器的生活更加简单.</p>
<p>我们实际上最终以 <strong>MVMCV</strong> 告终. <strong>M</strong>odel <strong>V</strong>iew-<strong>M</strong>odel <strong>C</strong>ontroller <strong>V</strong>iew. 我确信我无拘无束的应用设计模式骇客行为会让人大吃一惊.</p>
<p><img src="http://www.sprynthesis.com/assets/images/MCVMVMV.gif"></p>
<h4 id="我们的结果"><a href="#我们的结果" class="headerlink" title="我们的结果:"></a>我们的结果:</h4><p><img src="http://www.sprynthesis.com/assets/images/MVMCV.svg"></p>
<p>现在视图控制器仅关注于用 view-model 的数据配置和管理各种各样的视图, 并在先关用户输入时让 view-model 获知并需要向上游修改数据. 视图控制器不需要了解关于网络服务调用, Core Data, 模型对象等. (事实上有时通过 view-model 头文件而不是复制一大堆属性来暴漏 model 是很务实的, 后面还会有)</p>
<p>view-model 会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.</p>
<p>帮助你理解我们如何把组件组装在一起还有组件对应职责的另一种方式, 就是着眼于我们新的应用构建模块层级图.</p>
<p><img src="http://www.sprynthesis.com/assets/images/mvvm-layers.svg"></p>
<h2 id="View-Model-和-View-Controller-在一起，但独立"><a href="#View-Model-和-View-Controller-在一起，但独立" class="headerlink" title="View-Model 和 View Controller, 在一起，但独立"></a>View-Model 和 View Controller, 在一起，但独立</h2><p>我们来看个简单的 view-model 头文件来对我们新构件的长相有个更好地概念. 为了情节简单, 我们构建按了一个伪造的推特客户端来查看任何推特用户的最新回复, 通过输入他们的姓名并点击 “Go”. 我们的样例界面将会是这样:</p>
<ul>
<li>有一个让用户输入他们姓名的 UITextField , 和一个写着 “Go” 的 UIButton</li>
<li>有显示被查看的当前用户头像和姓名的 UIImageView 和 UILabel 各一个</li>
<li>下面放着一个显示最新回复推文的 UITableView</li>
<li>允许无限滚动</li>
</ul>
<p><img src="http://www.sprynthesis.com/assets/images/tweeboatplus.svg"></p>
<h4 id="View-Model-实例"><a href="#View-Model-实例" class="headerlink" title="View-Model 实例"></a>View-Model 实例</h4><p>我们的 view-model 头文件应该长这样:</p>
<pre><code>//MYTwitterLookupViewModel.h
@interface MYTwitterLookupViewModel: NSObject

@property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;
@property (nonatomic, strong, readonly) NSString *userFullName;
@property (nonatomic, strong, readonly) UIImage *userAvatarImage;
@property (nonatomic, strong, readonly) NSArray *tweets;
@property (nonatomic, assign, readonly) BOOL allTweetsLoaded;

@property (nonatomic, strong, readwrite) NSString *username;

- (void) getTweetsForCurrentUsername;
- (void) loadMoreTweets;    
</code></pre>
<p>相当直截了当的填充. 注意到这些<strong>壮丽的 readonly 属性</strong>了么?这个 view-model 暴漏了视图控制器所必需的最小量信息, 视图控制器实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储.</p>
<h4 id="view-model-不做的事儿"><a href="#view-model-不做的事儿" class="headerlink" title="view-model 不做的事儿"></a>view-model 不做的事儿</h4><ul>
<li>对视图控制器以任何形式直接起作用或直接通告其变化</li>
</ul>
<h4 id="View-Controller-视图控制器-视图控制器从-view-model-获取的数据将用来"><a href="#View-Controller-视图控制器-视图控制器从-view-model-获取的数据将用来" class="headerlink" title="View Controller(视图控制器)视图控制器从 view-model 获取的数据将用来:"></a>View Controller(视图控制器)视图控制器从 view-model 获取的数据将用来:</h4><ul>
<li>当 usernameValid 的值发生变化时触发 “Go” 按钮的 enabled 属性</li>
<li>当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为 1.0)</li>
<li>更新 UILable 的 text 属性为字符串 userFullName 的值</li>
<li>更新 UIImageView 的 image 属性为 userAvatarImage 的值</li>
<li>用 tweets 数组中的对象设置表格视图中的 cell (后面会提到)</li>
<li>当滑到表格视图底部时如果 allTweetsLoaded 为 NO, 提供一个 显示 “loading” 的 cell</li>
</ul>
<h4 id="视图控制器将对-view-model-起如下作用"><a href="#视图控制器将对-view-model-起如下作用" class="headerlink" title="视图控制器将对 view-model 起如下作用:"></a>视图控制器将对 view-model 起如下作用:</h4><ul>
<li>每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username</li>
<li>当 “Go” 按钮被按下时调用 view-model 上的 getTweetsForCurrentUsername 方法</li>
<li>当到达表格中的 “loading” cell 时调用 view-model 上的 loadMoreTweets 方法</li>
</ul>
<h4 id="视图控制器不做的事儿"><a href="#视图控制器不做的事儿" class="headerlink" title="视图控制器不做的事儿:"></a>视图控制器不做的事儿:</h4><ul>
<li>发起网络服务调用</li>
<li>管理 tweets 数组</li>
<li>判定 username 内容是否有效</li>
<li>将用户的姓和名格式化为全名</li>
<li>下载用户头像并转成 UIImage(如果你习惯在 UIImageView 上使用类别从网络加载图片, 你可以暴漏 URL 而不是图片. 这样就给 view-model 与 UIKit 之间一个更清晰的划分, 但我视 UIImage 为数据而非数据的确切显示. 这些东西不是固定死的. )</li>
<li>苦力活</li>
</ul>
<p>请再次注意视图控制器总的责任是处理 view-model 中的变化.</p>
<h4 id="子-View-Model"><a href="#子-View-Model" class="headerlink" title="子 View-Model"></a>子 View-Model</h4><p>我提到过使用 view-model 上的 tweets 数组中的对象配置表格视图的 cell.通常你会期待展现 tweets 的是数据-模型对象. 你可能已经对其感到奇怪, 因为我们试图通过 MVVM 模式不暴漏数据-模型对象. (前面提到过的)</p>
<p><strong>view-model 不必在屏幕上显示所有东西</strong>. 你可用子 view-model 来代表屏幕上更小, 更潜在被封装的部分. 如果一个视图上的一小块儿(比如表格的 cell)在 app 中可以被重用以及(或)表现多个数据-模型对象, 子 view-model 会格外有利.</p>
<p>你不总是需要子 view-model. 比如, 我可能用表格 header 视图来渲染我们“tweetboat plus”应用的顶部. 它不是个可重用的组件, 所以我可能仅是将我们已经给视图控制器用过的相同的 view-model 传给那个自定义的 header 视图. 它会用到 view-model 中它需要的信息, 而无视余下的部分. 这对于保持子视图同步是极好的方式, 因为它们可以有效地与信息中相同确切的上下文作用, 并观察确切相同属性的更新.</p>
<p>在我们的例子中, tweets 数组将会被下面这样的子 view-model 充满:</p>
<pre><code>//MyTweetCellViewModel.h
@interface MYTweetCellViewModel: NSObject

@property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;
@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;
@property (nonatomic, strong, readonly) NSString *tweetContent;
</code></pre>
<p>你可能认为这也太像普通”推特”里的数据-模型对象了吧. 为啥要干将其转化成 view-model 的工作?即使类似, view-model 让我们限制信息只暴露给我们需要的地方, 提供额外数据转换的属性, 或为特定的视图计算数据. (此外, 当可以不暴露可变数据-模型对象时也是极好的, 因为我们希望 view-model 自己承担起更新它们的任务, 而不是靠视图或视图控制器. )</p>
<h4 id="View-Model-从哪来"><a href="#View-Model-从哪来" class="headerlink" title="View-Model 从哪来?"></a>View-Model 从哪来?</h4><p>那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么?</p>
<h4 id="View-Model-产生-View-Model"><a href="#View-Model-产生-View-Model" class="headerlink" title="View-Model 产生 View-Model"></a>View-Model 产生 View-Model</h4><p>严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model.</p>
<p><img src="http://www.sprynthesis.com/assets/images/child-view-models.svg"></p>
<p>加入我们想要在用户轻拍应用顶部的头像时添加一个资料视图控制器. 我们可以为一级 view-model 添加类似如下方法:</p>
<pre><code>- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser;
</code></pre>
<p>然后在我们的一级视图控制器中这么用它:</p>
<pre><code>//MYMainViewController.m 
- (IBAction) didTapPrimaryUserAvatar
&#123;
MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser];

MYTwitterUserProfileViewController *profileViewController = 
    [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel];
[self.navigationController pushViewController: profileViewController animated:YES];
&#125;
</code></pre>
<p>在这个例子中我将会展现当前用户的资料视图控制器, 但是我的资料视图控制器需要一个 view-model. 我这的主视图控制器不知道(也不该知道)用于创建关联相关用户 view-model 的全部必要数据, 所以它请求它自己的 view-model 来干这种创建新 view-model 的苦差事.</p>
<h4 id="View-Model-列表"><a href="#View-Model-列表" class="headerlink" title="View-Model 列表"></a>View-Model 列表</h4><p>至于我们的推特 cell, 当数据驱动屏幕(在这个例子中或许是通过网络服务调用)聚到一起时, 我将会代表性地提前为对应的 cell 创建所有的 view-model. 所以在我们这个方案中, tweets 将会是一个 MYTweetCellViewModel 对象数组. 在我的表格视图中的 cellForRowAtIndexPath 方法中, 我将会在正确的索引上简单地抓取 view-model, 并把它赋值给我的 cell 上的 view-model 属性</p>
<h2 id="Functional-Core-Imperative-Shell"><a href="#Functional-Core-Imperative-Shell" class="headerlink" title="Functional Core, Imperative Shell"></a>Functional Core, Imperative Shell</h2><p>view-model 这种通往应用设计的方法是一块应用设计之路上的垫脚石, 这种被称作“Functional Core, Imperative Shell”的应用设计由Gary Bernhardt创造. (我最近十分有幸去听Andy Matuschak关于这方面的演讲, 他为”胖的数值层, 瘦的对象层”提出充分理由. 虽然观点相似, 但关注于我们怎样移除对象和它们状态的边界影响性质, 并用 Swift 中的新数据结构构建更加函数式, 可测试的数值层. )</p>
<h4 id="Functional-Core"><a href="#Functional-Core" class="headerlink" title="Functional Core"></a>Functional Core</h4><p>view-model 就是 “functional core”, 尽管实际上在 iOS/Objective-C 中达到纯函数水平是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近). 大意是让我们的 view-model 尽可能少的对剩余的”应用世界”的依赖和影响. 那意味着什么?想起你第一次学编程时可能学到的简单函数吧. 它们可能接受一两个参数并输出一个结果. 数据输入, 数据输出.这个函数可能是做一些数学运算或是将姓和名结合到一起. 无论应用的其他地方发生啥, 这个函数总是对相同的输入产生相同的输出. 这就是函数式方面.</p>
<p>这就是我们为 view-model 谋求的东西. 他们富有逻辑和转换数据并将结果存到属性的功能. 理想上相同的输入(比如网络服务响应)将会导出相同的输出(属性的值). 这意味着尽可能多地消除由”应用世界”剩余部分带来的可能影响输出的因素, 比如使用一堆状态. <strong>一个好的第一步就是不要再 view-model 头文件中引入 UIKit.h.</strong>(这是个重大原则, 但也有些灰色区域. 比如, 你可能认为 UIImage 是数据而不是展示信息. PS: 我爱这么干. 既然这样的话就得引入 UIKit. h 以便使用 UIImage 类)UIKit 其性质就是将要影响许多应用世界. 它包含很多”副作用”, 凭借改变一个值或调用一个函数将触发很多间接(甚至未知)的改变.</p>
<p><strong>更新</strong>: 刚刚看了 Andy 在函数式 Swift 会议上给出的另一个超赞的演讲, 于是又想到了一些. 要清楚你的 view-model 仍然只是一个对象, 而不用维护一些状态(否则它将不会是你视图中非常好用的模型了. )但你仍该努力将尽可能多的逻辑移到无状态的函数”值”中. 再重复一次, Swift在这方面比 Objective-C 更加可行.</p>
<h4 id="Imperative-Declarative-Shell"><a href="#Imperative-Declarative-Shell" class="headerlink" title="Imperative (Declarative?) Shell"></a>Imperative (Declarative?) Shell</h4><p>命令式外壳 (Imperative Shell) 是我们需要做所有的状态转换, 应用世界改变的苦差事的地方, 为的是将 view-model 数据转成给用户在屏幕上看到的东西. 这是我们的视图(控制器), 实际上我们在这分离 UIKit 的工作. 我仍将特别注意尽可能消除状态并用 ReactiveCocoa 这种陈述性质的东西做这方面工作, 而 iOS 和 UIKit 在设计上是命令式的. (表格的 data source 就是个很好的例子, 因为它的委托模式强制将状态应用到委托中, 为了当请求发生时能够为表格视图提供信息. 实际上委托模式通常强制一大堆状态的使用)</p>
<h4 id="可测试的核心"><a href="#可测试的核心" class="headerlink" title="可测试的核心"></a>可测试的核心</h4><p>iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法)</p>
<p>这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 我们现在将我们的数据用获取/逻辑/转换提取出, 避免了视图控制器的复杂性. 那意味着构建棒棒哒测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有).</p>
<h2 id="连接一切"><a href="#连接一切" class="headerlink" title="连接一切"></a>连接一切</h2><p><strong>那么当 view-model 的共有属性发生变化时我们如何更新我们的视图呢?</strong></p>
<p>绝大部分时间我们用对应的 view-model 来初始化视图控制器, 有点类似我们刚刚在上文见到的:</p>
<pre><code>MYTwitterUserProfileViewController *profileViewController =
[[MYTwitterUserProfileViewController alloc] initWithViewModel:  userProfileViewModel];
</code></pre>
<p>有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在讨论中的视图(控制器)中暴露一个公有可写的 view-model 属性.</p>
<pre><code>MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath];
// grab the cell view-model from the vc view-model and assign it
cell.viewModel = self.viewModel.tweets[indexPath.row];
</code></pre>
<p>有时我们可以在钩子程序调用前传入 view-model, 比如 init 和 viewDidLoad, 我们可以从view-model 的属性初始化所有 UI 元素的状态.</p>
<pre><code>//dontDoThis1.m 
- (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123;
self = [super init];
if (!self) return nil;
_viewModel = viewModel;
return self;
&#125;
- (void) viewDidLoad &#123;
[super viewDidLoad];
_goButton.enabled = viewModel.isUsernameValid;
_goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5;
// etc
&#125;
</code></pre>
<p>好棒!我们已经配置好了初始值. 当 view-model 上的数据改变时怎么办? 当”go” 按钮在什么时候可用了怎么办?当用户标签和头像在什么时候从网络上下载并填充了怎么办?</p>
<p>我们可以将视图控制器暴露给 view-model, 以便于当相关数据变化或类似事件发送时它可以调用一个 “updateUI” 方法. (别这么干. )在 view-model 上将视图控制器作为一个委托?当 view-model 内容有变化时发个通知?(不不不不. )</p>
<p>我们的视图控制器会感知一些变化的发生. 我们可以使用从 UITextfield 得来的委托方法在每当有字符变化时通过检查 view-model 来更新按钮的状态.</p>
<pre><code>//dontDoThisEither.m
- (void)textFieldDidChange:(UITextField *)sender &#123;
// update the view-model
self.viewModel.username = sender.text;
// check if things are now valid
self.goButton.enabled = self.viewModel.isUsernameValid;
self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;
&#125;
</code></pre>
<p>这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样?对于 view-model 中的网络调用会怎么样?或许我们该为 view-model 上的方法加一个完成后回调处理, 这样我们此时就可以更新 UI 的一切东西了?使用珍贵而笨重的 KVO 方法怎么样?</p>
<p>我们或许最终使用多种多样我们熟悉的机制将 view-model 和视图控制器所有的接触点都连起来, 但你已经知道了标题上不是这么写的. 这样在代码中创建了大量的入口点, 仅仅为了简单的更新 UI 就要在代码中完全重新创建应用状态上下文.</p>
<h2 id="进入-ReactiveCocoa"><a href="#进入-ReactiveCocoa" class="headerlink" title="进入 ReactiveCocoa"></a>进入 ReactiveCocoa</h2><p>ReactiveCocoa(RAC) 是来拯救我们的, 并恰好返回给我们一点理智. 让我们看看如何做到.<br>思考在一个新的用户页面上控制信息的流动, 当表单合法时更新提交按钮的状态. 你现在可能会照下面这么做:</p>
<p><img src="http://www.sprynthesis.com/assets/images/new-user-form-imperative.svg"></p>
<p>你最后通过使用状态, 小心翼翼地代码中许多不同且零碎无关的内容穿到简单的逻辑上. 看看你信息流中所有不同的入口点?(这还只是一个 UI 元素中的一条逻辑线. )我们程序中现在用的抽象概念还不够厉害, 不能为我们追踪所有事物的关系, 所以我们停止自己去干这蛋疼事儿.</p>
<p>让我们看看陈述版本:</p>
<p><img src="http://www.sprynthesis.com/assets/images/new-user-form-declarative.svg"></p>
<p>这看起来可能像是为我们应用流程文档中的一张老旧的计算机科学图解. 通过陈述式的编程, 我们使用了更高层次的抽象, 来让我们实际编程更靠近我们在脑海中设计流程的方式. 我们让电脑为我们做更多工作. 实际的代码更加像这幅图了.</p>
<h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>RACSignal (信号)就 RAC 来说是构造单元. 它代表我们最终将要收到的信息. 当你能将未来某时刻收到的消息具体表示出来时, <strong>你可以开始预先(陈述性)运用逻辑并构建你的信息流</strong>,而不是必须等到事件发生(命令式).</p>
<p><strong>信号会为了控制通过应用的信息流而获得所有这些异步方法(委托, 回调 block, 通知, KVO, target/action 事件观察, 等)并将它们统一到一个接口下</strong>.这只是直观理解. 不仅是这些, 因为信息会流过你的应用, 它还提供给你轻松转换/分解/合并/过滤信息的能力.</p>
<p><img src="http://www.sprynthesis.com/assets/images/replace-async-tools.svg"></p>
<h4 id="那么什么是信号呢-这是一个信号"><a href="#那么什么是信号呢-这是一个信号" class="headerlink" title="那么什么是信号呢?这是一个信号:"></a>那么什么是信号呢?这是一个信号:</h4><p><img src="http://www.sprynthesis.com/assets/images/signal-no-subscribers.svg"></p>
<p>信号是一个发送一连串值的物体. 但是我们这儿的信号啥也不干, 因为它还没有订阅者. 如果有订阅者监听时(已订阅)信号才会发信息. 它将会向那个订阅者发送0或多个载有数值的”next”事件, 后面跟着一个”complete”事件或一个”error”事件. (信号类似于其他语言/工具包中的 “promise”, 但更强大, 因为它不仅限于向它的订阅者一次只传递一个返回值. )</p>
<p><img src="http://www.sprynthesis.com/assets/images/signal-with-subscriber.svg"></p>
<p>正如我之前提到的, 如果觉得需要的话你可以过滤, 转换, 分解和合并那些值. 不同的订阅者可能需要使用信号通过不同方式发送的值.</p>
<p><img src="http://www.sprynthesis.com/assets/images/signal-map.svg"></p>
<h4 id="信号发送的值是从哪获得的"><a href="#信号发送的值是从哪获得的" class="headerlink" title="信号发送的值是从哪获得的?"></a>信号发送的值是从哪获得的?</h4><p>信号是一些等待某事发生的异步代码, 然后把结果值发送给它们的订阅者. 你可以用 RACSignal 的类方法 createSignal: 手动创建信号:</p>
<pre><code>//networkSignal.m
RACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;
    NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@&quot;http://someurl&quot;];
    [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123;
        [subscriber sendNext:result];
        [subscriber sendCompleted];
    &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123;
        [subscriber sendError:error];
    &#125;];
</code></pre>
<p>我在这用一个具有成功和失败 block (伪造)的网络操作创建了一个信号. (如果我想让信号在被订阅时才让网络请求发生, 还可以用 RACSignal 的类方法 defer. )我在成功的 block 里使用提供的 subscriber 对象调用 sendNext: 和 sendCompleted: 方法, 或在失败的 block 中调用 sendError:. 现在我可以订阅这个信号并将在响应返回时接收到 json 值或是 error.</p>
<p>幸运的是, RAC 的创造者实际上使用它们自己的库来创建真的事物(捉摸一下), 所以对于我们在日常需要什么, 他们有很强烈的想法. 他们为我们提供了很多机制, 来从我们通常使用的现存的异步模式中拉取信号. 别忘了如果你有一个没有被某个内建信号覆盖到的异步任务, 你可以很容易地用 createSignal: 或类似方法来创建信号.</p>
<p>一个被提供的机制就是 RACObserve() 宏. (如果你不喜欢宏, 你可以简单地看看罩子下面并用稍微多些冗杂的描述. 这也非常好. 在我们得到 Swift 版本的替代之前, 这也有在 Swift 中使用 RAC 的解决方案. )这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve 会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化.</p>
<pre><code>RACSignal *usernameValidSignal = RACObserve(self.viewModel,  usernameIsValid);
</code></pre>
<p><img src="http://www.sprynthesis.com/assets/images/signal-racobserve.svg"></p>
<p>这仅是提供用于创建信号的一个工具. 这里有几个立即可用的方式, 来从内置控制流机制中拉取信号:</p>
<pre><code>//signals.m
RACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside];
// signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc)
// subscribeNext:^(UIButton *button) &#123; NSLog(@&quot;%@&quot;, button); // UIButton instance &#125;

RACSignal *textChange = [myTextField rac_textSignal];
// some special methods are provided for commonly needed control event values off certain controls
// subscribeNext:^(UITextField *textfield) &#123; NSLog(@&quot;%@&quot;, textfield.text); // &quot;Hello!&quot; &#125;

RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal];
// signals for some delegate methods send the delegate params as the value
// e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc
// (limited to methods that return void)
// subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@&quot;%@&quot;, buttonIndex); // &quot;1&quot; &#125;

RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)];
// signals for arbitrary selectors that return void, send the method params as the value
// works for built in or your own methods
// subscribeNext:^(NSNumber *animated) &#123; NSLog(@&quot;viewDidAppear %@&quot;, animated); // &quot;viewDidAppear
</code></pre>
<p>记住你也能轻松创建自己的信号, 包括替代那些没有内建支持的其他委托. 我们现在能够从所有这些不连贯的异步/控制流工具中拉取出信号并将他们合并, 试想想这该多酷!这些会成为我们之前看到的陈述性图表中的节点. 真是兴奋.</p>
<h4 id="什么是订阅者"><a href="#什么是订阅者" class="headerlink" title="什么是订阅者?"></a>什么是订阅者?</h4><p>简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 “complete” 和 “error” 事件. )</p>
<p>这有一个简单的订阅者, 是通过向信号的实例方法 subscribeNext 传入一个 block 来创建的. 我们在这通过 RACObserve() 宏创建信号来观察一个对象上属性的当前值, 并把它赋值给一个内部属性.</p>
<pre><code>- (void) viewDidLoad &#123;
  // . . . 
  // create and get a reference to the signal
  RACSignal *usernameValidSignal = RACObserve(self.viewModel,  isUsernameValid);
  // update the local property when this value changes
  [usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123;
      self.usernameIsValid = isValidNumber.boolValue
  &#125;];
&#125;
</code></pre>
<p>注意 RAC 只处理对象, 而不处理像 BOOL 这样的原始值. 不过不用担心, RAC 通常会帮你这些转换.</p>
<p>幸运的是 RAC 的创造者也意识到这种绑定行为的普遍必要性, 所以他们提供了另一个宏 RAC(). 与 RACObserve() 相同, 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值. 我们的例子现在看起来像这样:</p>
<pre><code>- (void) viewDidLoad &#123;
//. . . 
RAC(self,  usernameIsValid) = RACObserve(self.viewModel,  isUsernameValid);
&#125;
</code></pre>
<p>考虑下我们的目标, 这么干有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI.</p>
<h4 id="转换数据流"><a href="#转换数据流" class="headerlink" title="转换数据流"></a>转换数据流</h4><p>现在我们进入 RAC 为我们提供的用于转换数值流的方法. 我们将会利用 RACSignal 的实例方法 map.</p>
<pre><code>//transformingStreams.m
- (void) viewDidLoad &#123;
//...
RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid);
RAC(self.goButton, enabled) = usernameIsValidSignal;
RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid) &#123;
        return usernameIsValid.boolValue ? @1.0 : @0.5;
    &#125;];
&#125;
</code></pre>
<p>这样现在我们将 view-model 上的 isUsernameValid 发生的变化直接绑定到 goButton 的 enabled 属性上. 酷吧?对 alpha 的绑定更酷, 因为我们正在使用 map 方法将值转换成与 alpha 属性相关的值. (注意在这里我们返回的是一个 NSNumber 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来.</p>
<h4 id="多个订阅者-副作用-昂贵的操作"><a href="#多个订阅者-副作用-昂贵的操作" class="headerlink" title="多个订阅者, 副作用, 昂贵的操作"></a>多个订阅者, 副作用, 昂贵的操作</h4><p>订阅信号链时要明白重要的一件事是每当一个新值通过信号链被发送出去时, 实际上会给每个订阅者都发送一次. 直到意识到这就我们而言是有意义的, 信号发出的值不存储在任何地方(除了 RAC 在内部实现中). 当信号需要发送一个新的值时, 它会遍历所有的订阅者并给每个订阅者发送那个值. (这是对信号链实际工作的简化说明, 但基本想法是对的)</p>
<p>这为什么重要?这意味着信号链某处存在的任何副作用, 任何影响应用世界的转变, 将会发生多次. 这对新接触 RAC 的用户来说是意想不到的. (这也违反了函数式构建的理念-数据输入, 数据输出).</p>
<p>一个做作的例子可能是: 信号链某处的信号在每次按钮被按下时更新 self 中的一个计数器属性. 如果信号链有多个订阅者, 计数器的增长将会比你想的还要多. 你需要努力从信号链中尽可能剔除副作用. 当副作用不可避免时, 你可以使用一些恰当的预防机制. 我将会在另一篇文章中探索.</p>
<p>除副作用之外, 你需要注意带有昂贵操作和可变数据的信号链. 网络请求就是一个三者兼得的例子:</p>
<ol>
<li>网络请求影响了应用的网络层(副作用).</li>
<li>网络请求为信号链引入了可变数据. (两个完全一样请求可能返回了不同的数据. )</li>
<li>网络请求反应慢啊.</li>
</ol>
<p>例如, 你可能有个信号在每次按钮按下时发送一个值, 而你想将这个值转换成网络请求的结果. 如果有多个订阅者要这个处理信号链上返回的这个值, 你将发起多个网络请求.</p>
<p><img src="http://www.sprynthesis.com/assets/images/signal-side-effect.svg"></p>
<p>网络请求明显是经常需要的. 正如你所期望, RAC 提供这些情况的解决方案, 也就是 RACCommand 和多点广播. 我将会在下一篇文章中更深入地分析.</p>
<h2 id="Tweetboat-Plus"><a href="#Tweetboat-Plus" class="headerlink" title="Tweetboat Plus"></a>Tweetboat Plus</h2><p>既然简短的介绍(嗯哼)扯远了, 让我们着眼于如何用 ReactiveCocoa 将 view-model 与视图控制器连接起来.</p>
<pre><code>//
// View Controller
//

- (void) viewDidLoad &#123;
[super viewDidLoad];

RAC(self.viewModel,  username) = [myTextfield rac_textSignal];

RACSignal *usernameIsValidSignal = RACObserve(self.viewModel,  usernameValid);

RAC(self.goButton,  alpha) = [usernameIsValidSignal
    map:  ^(NSNumber *valid) &#123;
        return valid.boolValue ? @1 :  @0.5;
    &#125;];

RAC(self.goButton,  enabled) = usernameIsValidSignal;

RAC(self.avatarImageView,  image) = RACObserve(self.viewModel,  userAvatarImage);

RAC(self.userNameLabel,  text) = RACObserve(self.viewModel,  userFullName);

@weakify(self);
[[[RACSignal merge: @[RACObserve(self.viewModel,  tweets), 
                    RACObserve(self.viewModel,  allTweetsLoaded)]]
    bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]
    subscribeNext: ^(id value) &#123;
        @strongify(self);
        [self.tableView reloadData];
    &#125;];

[[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside]
    subscribeNext:  ^(id value) &#123;
        @strongify(self);
        [self.viewModel getTweetsForCurrentUsername];
    &#125;];
&#125;

-(UITableViewCell*)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath &#123;
// if table section is the tweets section
if (indexPath.section == 0) &#123;
    MYTwitterUserCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYTwitterUserCell&quot; forIndexPath: indexPath];
    
    // grab the cell view model from the vc view model and assign it
    cell.viewModel = self.viewModel.tweets[indexPath.row];
    return cell;
&#125; else &#123;
    // else if the section is our loading cell
    MYLoadingCell *cell = [self.tableView dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath: indexPath];
    [self.viewModel loadMoreTweets];
    return cell;
&#125;
&#125;


//
// MYTwitterUserCell
//

// this could also be in cell init
- (void) awakeFromNib &#123;
[super awakeFromNib];

RAC(self.avatarImageView, image) = RACObserve(self,  viewModel.tweetAuthorAvatarImage);
RAC(self.userNameLabel, text) = RACObserve(self,  viewModel.tweetAuthorFullName);
RAC(self.tweetTextLabel, text) = RACObserve(self,  viewModel.tweetContent);
&#125;
</code></pre>
<p>让我们过一遍这个例子.</p>
<pre><code>RAC(self.viewModel,  username) = [myTextfield rac_textSignal];
</code></pre>
<p>在这我们用 RAC 库中的方法从 UITextField 拉取一个信号. 这行代码将 view-model 上的可读写属性 username 绑定到文本框上的用户输入的任何更新.</p>
<pre><code>RACSignal *usernameIsValidSignal = RACObserve(self.viewModel,  usernameValid);

RAC(self.goButton,  alpha) = [usernameIsValidSignal
map:  ^(NSNumber *valid) &#123;
    return valid.boolValue ? @1 :  @0. 5;
&#125;];

RAC(self.goButton,  enabled) = usernameIsValidSignal;
</code></pre>
<p>在这我们用 RACObserve 方法在 view-model 的 usernameValid 属性上创建了一个信号 usernameIsValidSignal. 无论何时属性发生变化, 它将会沿着管道发送一个新的 @YES 或 @NO. 我们拿到那个值并将其绑定到 goButton 的两个属性上. 首先我们将 alpha 分别对应 YES 或 NO 更新到1或0.5(记着在这必须返回 NSNumber). 然后我们直接将信号绑定到 enabled 属性, 因为 YES 和 NO 在这无需转换就能完美地运作.</p>
<pre><code>RAC(self.avatarImageView,  image) = RACObserve(self.viewModel,  userAvatarImage);

RAC(self.userNameLabel,  text) = RACObserve(self.viewModel,  userFullName);
</code></pre>
<p>下面我们为表头的图像视图和用户标签创建绑定, 再次在 view-model 上对应的属性上用 RACObserve 宏创建信号.</p>
<pre><code>@weakify(self);
[[[RACSignal merge: @[RACObserve(self.viewModel,  tweets), 
                 RACObserve(self.viewModel,  allTweetsLoaded)]]
bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]
subscribeNext: ^(id value) &#123;
    @strongify(self);
    [self.tableView reloadData];
&#125;];
</code></pre>
<p>这货看上去有点诡异, 所以我们在这上多花点时间. 我们想在 view-model 上 tweets 数组或 allTweetsLoaded 属性发生变化时更新表格视图. (在这个例子中, 我们要用一个简单的方法来重新加载整张表. )所以我们将这两个属性被观察后创建的两个信号合并成一个更大的信号, 当两个属性中有一个发生变化, 这个信号就会发送值. (你一贯认为信号的值是同类型的, 不会像这个信号有一样混杂的值. 这很可能在 Swift 版本的 RAC 中强制要求, 但在这我们不关心发出的真实值, 我们只是用它来触发表格式图的重新加载. )</p>
<p>那么这儿看起来最吓人的部分可能是信号链中的 bufferWithTime: onScheduler: 方法. 需要它来围绕 UIKit 中的一个问题进行变通. tweets 和 allTweetsLoaded 这两个属性我们都需要追踪, 万一 tweets 变化和 allTweetsLoaded 为否(不管怎样我们都得重新加载表格). 有时两个属性都将在同一准确的时间发生变化, 意味着合并后的大信号中的两个信号都会发送一个值, 那么 reloadData 方法将会在同一个运行循环中被调用两次. UIKit 不喜欢这样. bufferWithTime: 在给明的时间内抓取所有下一个到来的值, 当给定的时间过后将所有值合在一起发给订阅者. 通过传入0作为时间, bufferWithTime: 将会抓取那个合并信号在特定的运行循环中发出的全部值, 并将他们一起发送出去. (NSTimer 以同样的方式工作, 这不是巧合, 因为 bufferWithTime: 是用 NSTimer 构建的. )暂时不用担心 scheduler, 试把它想做指明这些值必须在主线程上被发送. 现在我们确保 reloadData 每次运行循环只被调用一次.</p>
<p>注意我在这用 @weakify/@strongify 宏切换 strong 和 weak. 这在创建所有这些 block 时非常重要. 在 RAC 的 block 中使用 self 时self 将会被捕获为强引用并得到保留环, 除非你尤其意识到要破除保留环</p>
<pre><code>[[self.goButton rac_signalForControlEvents: UIControlEventTouchUpInside]
subscribeNext:  ^(id value) &#123;
    @strongify(self);
    [self.viewModel getTweetsForCurrentUsername];
&#125;];
</code></pre>
<p>我将会在下一篇文章中在这里引入 RACCommand, 但目前我们只是当按钮被触碰时手动调用 view-model 的 getTweetsForCurrentUsername 方法.</p>
<p>我们已经搞定了 cellForRowAtIndexPath 的第一部分, 那么我在这将只说下 loading cell:</p>
<pre><code>MYLoadingCell *cell = [self.tableView     dequeueReusableCellWithIdentifier: @&quot;MYLoadingCell&quot; forIndexPath:     indexPath];
[self.viewModel loadMoreTweets];
return cell;
</code></pre>
<p>这是另一块我们以后将利用到 RACCommand 的地方, 但目前我们只是调用 view-model 的 loadMoreTweets 方法. 我们将只是信任如果 cell 显示或隐藏多次的话 view-model 会避免多次内部调用.</p>
<pre><code>- (void) awakeFromNib &#123;
        [super awakeFromNib];
        RAC(self.avatarImageView, image) = RACObserve(self, viewModel.tweetAuthorAvatarImage);
        RAC(self.userNameLabel, text) = RACObserve(self,  viewModel.tweetAuthorFullName);
        RAC(self.tweetTextLabel, text) = RACObserve(self,  viewModel.tweetContent);
    &#125;
</code></pre>
<p>这段现在应该非常直接了, 除此之外我想指出一点. 我们正在将图片和文字绑定到 UI 上对应的属性, 但注意 viewModel 出现在 RACObserve 宏中逗号右边. 这些 cell 终将被重用, 新的 view-models 将会被赋值. 如果我们不将 viewModel 放在逗号右边, 那就会监听 viewModel 属性的变化然后每次都要重新设置绑定;如果放在逗号右边, RACObserve 将会为我们负责这些事儿. 因此我们只需要设定一次绑定并让 Reactive Cocoa 做剩余的部分. 这是在绑定表格 cell 时为了性能需要记住的好东西. 我在实践中即使是有很多表格 cell 依然没有出过问题.</p>
<h4 id="福利-消除更多的状态"><a href="#福利-消除更多的状态" class="headerlink" title="福利-消除更多的状态"></a>福利-消除更多的状态</h4><p>有时候你可以在 view-model 中暴露 RACSignal 对象来替代像字符串和图像这样的属性, 这能在 view-model 上消除更多的状态. 然后视图控制器就不需要自己用 RACObserve 创建信号了, 并只是直接影响这些信号. 要意识到如果你的信号在被 UI 订阅/绑定到 UI 之前发出过一个值, 那么你将不会收到那个”初始”的值.</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本文篇幅略长, 但别被吓着. 这还有好多没讲的, 而且是干货儿, 是舒展你大脑的好方法. 这毫无疑问是不同的编程风格. 花一会儿功夫停止机械地试图用命令式方案去解决问题. 即使你一开始不是经常用这种编程风格, 我认为这有助于理解和提醒我们有截然不同的途径来解决我们程序员的困惑.</p>
<p>下一次我将稍微深入 view-model 内部中本文没提到的内容, 并介绍下 RACCommand(希望篇幅能短很多). 然后我们将投入到一个真实案例中, 那是我的一个叫做Three Cents的 app 中的一个相当复杂的页面, 它混合了网络调用, CoreData, 多重 UI 状态, 等等!</p>
<p><img src="http://www.sprynthesis.com/assets/images/ThreeCentsExplore.gif"></p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">RAC+MVVM</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/RAC-MVVM//" class="article-tag-list-link color4">RAC+MVVM</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2019/02/20/ReactiveCocoa%20and%20MVVM,%20an%20Introduction/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-个人知识结构快速导航" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2019/02/20/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E5%AF%BC%E8%88%AA/" target="_blank">个人知识结构快速查阅</a>
  
    </h1>
  


  
  
<a href="/2019/02/20/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E5%AF%BC%E8%88%AA/" class="archive-article-date">
        <time datetime="2019-02-20T07:58:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-02-20</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p><img src="/uploads/images/PERSONAL_IMAGE.png"></p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">知识结构</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2019/02/20/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%BF%AB%E9%80%9F%E5%AF%BC%E8%88%AA/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-计算机基础书籍推荐" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2019/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" target="_blank">计算机基础书籍推荐</a>
  
    </h1>
  


  
  
<a href="/2019/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" class="archive-article-date">
        <time datetime="2019-01-27T08:53:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-01-27</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p>1.《图解HTTP》</p>
<p>总体阅读后评价：图片直观，作为了解HTTP相关知识一个比较好的入门书，但是太深的知识也没有太多涉及到。如果你的目标如此，那将会是一本合适的书籍。2014年出版。</p>
<p><img src="/uploads/images/IMG_BASE_BOOK_01.png"></p>
<p>2.《我的第一本算法书》</p>
<p>总体阅读后评价：图片直观，当初大学开课的时候虽然学过，但是工作后渐渐被遗忘了，不失为复习的一本好书。</p>
<p><img src="/uploads/images/IMG_BASE_BOOK_02.png"></p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">计算机基础</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/书籍推荐//" class="article-tag-list-link color5">书籍推荐</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2019/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-动画知识导图" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2018/11/18/%E5%8A%A8%E7%94%BB%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE/" target="_blank">iOS 动画</a>
  
    </h1>
  


  
  
<a href="/2018/11/18/%E5%8A%A8%E7%94%BB%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE/" class="archive-article-date">
        <time datetime="2018-11-18T12:22:34.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-11-18</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p><img src="/uploads/images/IMG_ANIMATION.png"></p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">动画</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/动画//" class="article-tag-list-link color3">动画</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2018/11/18/%E5%8A%A8%E7%94%BB%E7%9F%A5%E8%AF%86%E5%AF%BC%E5%9B%BE/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-BookRecommend" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2018/11/01/BookRecommend/" target="_blank">iOS学习书籍推荐</a>
  
    </h1>
  


  
  
<a href="/2018/11/01/BookRecommend/" class="archive-article-date">
        <time datetime="2018-11-01T09:57:26.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-11-01</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p>描述：以下书籍顺序是我学习后推荐的阅读顺序。</p>
<p>1.《Objective-C基础教程》</p>
<p>总体阅读后评价：总体比较严谨，符合思维模式，通过围绕同一个业务场景多角度分析问题，并合理转化为实质性代码，认真读完这本你的Objective-C的基础会特别扎实。</p>
<p><img src="/uploads/images/IMG_BOOK_01.png"></p>
<p>2.《精通iOS开发》</p>
<p>总体阅读后评价：作者的思维比较活跃，完全符合真实场景，如果是OC基础较差，学习起来会比较吃力，认真阅读几次跟着做示例Demo，学习完毕后相当于正式入门完毕。</p>
<p><img src="/uploads/images/IMG_BOOK_04.png"></p>
<p>3.《Objective-C高级编程：iOS与OS X多线程和内存管理（苹果源代码不会告诉你的Objective-C高级编程）》<br><img src="/uploads/images/IMG_BOOK_02.png"></p>
<p>总体阅读后评价：作者是日本人，一如既往的严谨，虽然代码较古老，但是对于原理的解析相当透彻，即使多年后再来看也不为过。</p>
<p>4.《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》</p>
<p><img src="/uploads/images/IMG_BOOK_03.png"></p>
<p>总体阅读后评价：作者一定是一个强迫症晚期加处女座，代码相当规范，52个tips帮助你写出赏心悦目的艺术品！</p>
<p>5.《高性能iOS应用开发》</p>
<p><img src="/uploads/images/IMG_BOOK_05.png"></p>
<p>总体阅读后评价：作者是一位印度人，这本书也是让你写出好的代码，但是，是从硬件层面来考虑的，怎样调用最少的硬件资源完成一项操作，虽然现在的手机性能越来越强劲，但是为什么不合理的利用我们所拥有的资源呢？</p>
<p>6.《iOS动画 核心技术与案例实战》</p>
<p><img src="/uploads/images/IMG_BOOK_06.png"></p>
<p>总体阅读评价：关于动画的知识该涉及到的内容基本都涉及到了，不是很深入，只有常规用法，可以算作网上示例大汇总。</p>
<p>7.《iOS开发进阶》</p>
<p><img src="/uploads/images/IMG_BOOK_07.png"></p>
<p>总体阅读评价：作者曾在新浪微博就职，这本书可以算作是他blog的一个整理，知识偏实战。只不过是更全面一些，但是内容偏散。可以做为补充阅读。</p>
<p>8.《iOS开发快速进阶与实战》</p>
<p><img src="/uploads/images/IMG_BOOK_08.png"></p>
<p>总体阅读评价：作者是饿了么iOS高级开发工程师，也是偏实战，出版时间2018年8月，这本书很符合我的思维节奏，知识内容很连贯，读完收获比预想中的大。</p>
<p>9.《ios 应用安全权威指南》</p>
<p><img src="/uploads/images/IMG_BOOK_09.png"></p>
<p>总体阅读评价：这本书可以让你从安全的角度来重新审视iOS开发，读完后的第一感受：原来我们日常开发在安全的考虑上是如此之少，在黑客面前，我们的应用基本上是naked。</p>
<p>10.《Swift学习手册》</p>
<p><img src="/uploads/images/IMG_BOOK_10.png"></p>
<p>总体阅读评价：在阅读这本书的时候，swift已经更新到5.0，这本书基于Swift 2.0，虽然Swift版本落后，但是大体上不影响学习。关键问题是，书本的demo功能包含iCloud的，没有一定开发经验这本书不是一个好的选择。</p>
<p>11.《iOS面试之道》</p>
<p><img src="/uploads/images/IMG_BOOK_11.png"></p>
<p>总体阅读评价：本书分为两部分，第一部分为算法部分，第二部分为开发经验杂谈，算法部分是胡胤道长写的，后面的杂谈应该是唐巧老师写的，可能自己也慢慢步入高级开发之路，觉得唐巧老师写的内容大部分都有点皮毛了。这本书收获略少。</p>
<p>12.《iOS UI 开发捷径》</p>
<p><img src="/uploads/images/IMG_BOOK_12.png"></p>
<p>总体阅读评价：大学开始学习iOS的时候，全是采用SB和XIB写UI，但是工作后大部分都是采用纯代码写，但是自己对苹果推荐的这种方式很喜欢，这本书对于SB和XIB还有nib写UI帮助很大，很全面，是作者多年积累的经验。</p>
<p>13.《App 架构师》</p>
<p><img src="/uploads/images/IMG_BOOK_13.png"></p>
<p>总体阅读评价：这本书是由其不推荐阅读的一本书，很没有价值，很粗略，介绍的知识很旧，介绍的工具基本都被废弃了，关于iOS的一笔带过，很可能作者是名安卓开发，后面转到iOS，大多数关于iOS的东西涉及的都很浅，在很多地方鄙视iOS的做法很垃圾，PS：我们当今国力越来越强大，但是人们还是很浮躁，这种书可能纯碎想把知识变现，而不是作为教学，或者传播知识。不推荐阅读。</p>
<p>14.《iOS程序员 面试笔试真题与解析》</p>
<p><img src="/uploads/images/IMG_BOOK_14.png"></p>
<p>总体阅读评价：这本书是对iOS知识点进行比较完整的一个总结了，参加面试笔试前应当仔细阅读的一本书。这本书还有姊妹篇，以下介绍。</p>
<p>15.《iOS程序员 面试笔试宝典》</p>
<p><img src="/uploads/images/IMG_BOOK_15.png"></p>
<p>总体阅读评价：这本书也是对iOS知识点的讲解，不过上面那本讲述方式是：先给题目，由此讲解。这本书是一个知识点一个知识点的过。两本书重合知识点蛮多，但是结合起来阅读相当不错。</p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Book</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/书籍推荐//" class="article-tag-list-link color5">书籍推荐</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2018/11/01/BookRecommend/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-EWO" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2018/08/27/EWO/" target="_blank">Everything will be ok</a>
  
    </h1>
  


  
  
<a href="/2018/08/27/EWO/" class="archive-article-date">
        <time datetime="2018-08-26T16:50:12.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-27</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <p>曾经是一路坦途，不曾尝过心酸与艰辛，但是来到上海，才领会了人外有人，天外有天。</p>
<p>我很想详细的整理下之前的经历，不过明天要上班，现在已经是午夜过半。</p>
<p>我会抽出一天时间来专门写这篇文章的。</p>
<p>但是现在明白了一些道理：</p>
<p>1.不要总是担心没有发生的事。</p>
<p>2.我很聪明，我可以应对所有的问题，并合理的解决。</p>
<p>3.成功合理性：只要能力达到了，就一定会顺理成章的达成目标。</p>
<p>4.Everything will be ok</p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/Diary//" class="article-tag-list-link color1">Diary</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2018/08/27/EWO/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-iOS面试题汇总" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2018/08/11/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" target="_blank">iOS面试题汇总</a>
  
    </h1>
  


  
  
<a href="/2018/08/11/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/" class="archive-article-date">
        <time datetime="2018-08-11T13:40:04.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-08-11</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h1 id="iOS面试题系列"><a href="#iOS面试题系列" class="headerlink" title="iOS面试题系列"></a>iOS面试题系列</h1><h4 id="1-import-跟-include、-class有什么区别？＃import-lt-gt-跟-import””又什么区别？"><a href="#1-import-跟-include、-class有什么区别？＃import-lt-gt-跟-import””又什么区别？" class="headerlink" title="1.import 跟 #include、@class有什么区别？＃import&lt;&gt; 跟 #import””又什么区别？"></a><strong>1.import 跟 #include、@class有什么区别？＃import&lt;&gt; 跟 #import””又什么区别？</strong></h4><blockquote>
<ul>
<li>#include 和#import其效果相同,都是查询类中定义的行为(方法);</li>
<li>#import不会引起交叉编译,确保头文件只会被导入一次；</li>
<li>@class 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；</li>
<li>@class 比#import 编译效率更高。</li>
<li>此外@class 和#import 的主要区别在于解决引用死锁的问题。</li>
<li>＃import&lt;&gt; 跟 #import””又什么区别在于，#import&lt;&gt;导入系统头文件，#import””导入项目头文件。</li>
</ul>
</blockquote>
<h4 id="2-对OC的理解与语言特性"><a href="#2-对OC的理解与语言特性" class="headerlink" title="2. 对OC的理解与语言特性"></a><strong>2. 对OC的理解与语言特性</strong></h4><blockquote>
<ul>
<li>OC作为一门面向对象的语言，自然具有面向对象的语言特性：封装、继承、多态。它既具有静态语言的特性（如C++），又有动态语言的效率（动态绑定、动态加载等）。总体来讲，OC确实是一门不错的编程语言，</li>
<li>Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>动态类型</strong>：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单来说就是id类型。事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛。静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。</p>
<p><strong>动态绑定</strong>：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。</p>
<p><strong>动态加载</strong>：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retina设备上加载@2x的图片，而在老一些的普通苹设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类。</p>
</blockquote>
<h4 id="3-简述内存管理基本原则"><a href="#3-简述内存管理基本原则" class="headerlink" title="3. 简述内存管理基本原则"></a>3. 简述内存管理基本原则</h4><blockquote>
<ul>
<li>之前：OC内存管理遵循“谁创建，谁释放，谁引用，谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）。</li>
<li>目前：iOS 5.0之后引用自动管理机制——自动引用计数（ARC），管理机制与手动机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。</li>
<li>如果使用alloc、copy(mutableCopy)或者retian一个对象时,你就有义务,向它发送一条release或者autorelease消息。其他方法创建的对象,不需要由你来管理内存。</li>
<li>向一个对象发送一条autorelease消息,这个对象并不会立即销毁, 而是将这个对象放入了自动释放池,待池子释放时,它会向池中每一个对象发送 一条release消息,以此来释放对象.</li>
<li>向一个对象发送release消息,并不意味着这个对象被销毁了,而是当这个对象的引用计数为0时,系统才会调用dealloc方法,释放该对象和对象本身它所拥有的实例。</li>
</ul>
<p> <strong>其他注意事项：</strong></p>
<ul>
<li>如果一个对象有一个_strong类型的指针指向着，这个对象就不会被释放。如果一个指针指向超出了它的作用域，就会被指向nil。如果一个指针被指向nil，那么它原来指向的对象就被释放了。当一个视图控制器被释放时，它内部的全局指针会被指向nil。用法“：不管全局变量还是局部变量用_strong描述就行。</li>
<li>局部变量：出了作用域，指针会被置为nil。</li>
<li>方法内部创建对象，外部使用需要添加_autorelease;</li>
<li>连线的时候，用_weak描述。</li>
<li>代理使用unsafe_unretained就相当于assign；</li>
<li>block中为了避免循环引用问题，使用_weak描述；</li>
<li>声明属性时，不要以new开头。如果非要以new开头命名属性的名字，需要自己定制get方法名，如</li>
<li>@property(getter=theString) NSString * newString;</li>
<li>如果要使用自动释放池，用@autoreleasepool{}</li>
<li>ARC只能管理Foundation框架的变量，如果程序中把Foundation中的变量强制换成COre Foundation中的变量需要交换管理权；</li>
<li>在非ARC工程中采用ARC去编译某些类：-fobjc-arc。</li>
<li>在ARC下的工程采用非ARC去编译某些类：-fno-fobjc-arc。</li>
</ul>
</blockquote>
<h4 id="4-如何理解MVC设计模式"><a href="#4-如何理解MVC设计模式" class="headerlink" title="4.如何理解MVC设计模式"></a><strong>4.如何理解MVC设计模式</strong></h4><blockquote>
<p>MVC是一种架构模式，M表示Model，V表示视图View，C表示控制器Controller：</p>
<ul>
<li>Model负责存储、定义、操作数据；</li>
<li>View用来展示书给用户，和用户进行操作交互；</li>
<li>Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，Model也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，Model发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。</li>
</ul>
</blockquote>
<h4 id="5-如何理解MVVM设计模式"><a href="#5-如何理解MVVM设计模式" class="headerlink" title="5.如何理解MVVM设计模式"></a>5.如何理解MVVM设计模式</h4><blockquote>
<ul>
<li>ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。</li>
<li>View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。</li>
</ul>
</blockquote>
<h4 id="6-Objective-C-中是否支持垃圾回收机制？"><a href="#6-Objective-C-中是否支持垃圾回收机制？" class="headerlink" title="6.Objective-C 中是否支持垃圾回收机制？"></a>6.Objective-C 中是否支持垃圾回收机制？</h4><blockquote>
<ul>
<li>OC是支持垃圾回收机制的(Garbage collection简称GC),但是apple的移动终端中,是不支持GC的,Mac桌面系统开发中是支持的.</li>
<li>移动终端开发是支持ARC（Automatic Reference Counting的简称）,ARC是在IOS5之后推出的新技术,它与GC的机制是不同的。我们在编写代码时, 不需要向对象发送release或者autorelease方法,也不可以调用delloc方法,编译器会在合适的位置自动给用户生成release消息(autorelease),ARC 的特点是自动引用技术简化了内存管理的难度.</li>
</ul>
</blockquote>
<h4 id="7-协议的基本概念和协议中方法默认为什么类型"><a href="#7-协议的基本概念和协议中方法默认为什么类型" class="headerlink" title="7.协议的基本概念和协议中方法默认为什么类型"></a>7.协议的基本概念和协议中方法默认为什么类型</h4><blockquote>
<ul>
<li>OC中的协议是一个方法列表,且多少有点相关。它的特点是可以被任何类使用(实现),但它并不是类(这里我们需要注意),自身不会实现这样方法, 而是又其他人来实现协议经常用来实现委托对象(委托设计模式)。如果一个类采用了一个协议,那么它必须实现协议中必须需要实现的方法,在协议中的方法默认是必须实现(@required),添加关键字@optional,表明一旦采用该协议,这些“可选”的方法是可以选择不实现的。</li>
</ul>
</blockquote>
<h4 id="8-简述类目category优点和缺点"><a href="#8-简述类目category优点和缺点" class="headerlink" title="8.简述类目category优点和缺点"></a>8.简述类目category优点和缺点</h4><blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>不需要通过增加子类而增加现有类的行为(方法),且类目中的方法与原始类方法基本没有区别;</li>
<li>通过类目可以将庞大一个类的方法进行划分,从而便于代码的日后的维护、更新以及提高代码的阅读性;</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法向类目添加实例变量,如果需要添加实例变量,只能通过定义子类的方式;</li>
<li>类目中的方法与原始类以及父类方法相比具有更高优先级,如果覆盖父类的方法,可能导致super消息的断裂。因此,最好不要覆盖原始类中的方法。</li>
</ul>
</blockquote>
<h4 id="9-类别的作用"><a href="#9-类别的作用" class="headerlink" title="9.类别的作用"></a>9.类别的作用</h4><blockquote>
<ul>
<li>给系统原有类添加方法，不能扩展属性。如果类别中方法的名字跟系统的方法名一样，在调用的时候类别中的方法优先级更高；</li>
<li>分散类的实现：如：</li>
</ul>
</blockquote>
<pre><code>          +(NSIndexPath *)indexPathForRow:(NSInteger)row
       inSection:(NSInteger)section
</code></pre>
<blockquote>
<p>原本属于NSIndexPath的方法，但因为这个方法经常使用的表的时候调用、跟表的关系特别密切，因此把这个方法一类别的形式、声明在UITableView.h中。</p>
<ul>
<li>声明私有方法，某一个方法只实现，不声明，相当于私有方法。</li>
<li>类别不能声明变量，类别不可以直接添加属性。property描述setter方法，就不会报错。</li>
</ul>
</blockquote>
<h4 id="10-循环引用的产生原因，以及解决方法"><a href="#10-循环引用的产生原因，以及解决方法" class="headerlink" title="10.循环引用的产生原因，以及解决方法"></a>10.循环引用的产生原因，以及解决方法</h4><blockquote>
<ul>
<li><p>产生原因：如下图所示，对象A和对象B相互引用了对方作为自己的成员变量，只有自己销毁的时候才能将成员变量的引用计数减1。对象A的销毁依赖于对象B的销毁，同时对象B销毁也依赖与对象A的销毁，从而形成循环引用，此时，即使外界没有任何指针访问它，它也无法释放。</p>
<p>  <img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p>
<pre><code>                          循环引用示例图
</code></pre>
</li>
</ul>
<p>多个对象间依然会存在循环引用问题，形成一个环，在编程中，形成的环越大越不容易察觉，如下图所示：</p>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png"></p>
<pre><code>                            多个对象引用示例图
</code></pre>
<p><strong>解决方法：</strong></p>
<ul>
<li>事先知道存在循环引用的地方，在合理的位置主动断开一个引用，是对象回收；</li>
<li>使用弱引用的方法。</li>
</ul>
</blockquote>
<h4 id="11-键路径-keyPath-、键值编码（KVC）、键值观察（KVO）"><a href="#11-键路径-keyPath-、键值编码（KVC）、键值观察（KVO）" class="headerlink" title="11.键路径(keyPath)、键值编码（KVC）、键值观察（KVO）"></a>11.键路径(keyPath)、键值编码（KVC）、键值观察（KVO）</h4><blockquote>
<p><strong>键路径</strong></p>
<ul>
<li>在一个给定的实体中,同一个属性的所有值具有相同的数据类型。</li>
<li>键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。 - 键路径是一个由用点作分隔符的键组成的字符串,用于指定一个连接在一起的对象性质序列。第一个键的性质是由先前的性质决定的,接下来每个键的值也是相对于其前面的性质。</li>
<li>键路径使您可以以独立于模型实现的方式指定相关对象的性质。通过键路径,您可以指定对象图中的一个任意深度的路径,使其指向相关对象的特定属性。</li>
</ul>
<p><strong>键值编码KVC</strong></p>
<ul>
<li>键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码；</li>
<li>KVC的缺点：一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。</li>
</ul>
<p><strong>键值观察KVO</strong></p>
<ul>
<li>键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码。</li>
<li>实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修改它的实例变量,这样才能被观察者观察到。因此,KVC是KVO的基础。</li>
</ul>
<p><strong>Demo</strong></p>
<p>比如我自定义的一个button</p>
</blockquote>
<pre><code>     [self addObserver:self forKeyPath:@&quot;highlighted&quot; options:0 context:nil];  
     
     //KVO
     
     -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 
     &#123; 
          if ([keyPath isEqualToString:@&quot;highlighted&quot;] ) &#123; 
           [self setNeedsDisplay]; 
     &#125; 
       &#125;
</code></pre>
<blockquote>
<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p>
<p><strong>KVC机制通过key找到value的原理</strong></p>
<ul>
<li>当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过下面几种不同的方式解析这个调用。</li>
<li>首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</li>
<li>补充：KVC查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。</li>
<li>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。</li>
</ul>
</blockquote>
<p><strong>12.在 Objective-C 中如何实现 KVO</strong></p>
<blockquote>
<ul>
<li>注册观察者(注意：观察者和被观察者不会被保留也不会被释放)</li>
</ul>
</blockquote>
<pre><code>  -(void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 
 options:(NSKeyValueObservingOptions)options 
 context:(void *)context; 
</code></pre>
<blockquote>
<ul>
<li>接收变更通知</li>
</ul>
</blockquote>
<pre><code>-(void)observeValueForKeyPath:(NSString *)keyPath
ofObject:(id)object change:(NSDictionary *)change context:(void )context;
</code></pre>
<blockquote>
<ul>
<li>移除对象的观察者身份</li>
</ul>
</blockquote>
<pre><code>  -(void)removeObserver:(NSObject *)observer
  forKeyPath:(NSString *)keyPath;
</code></pre>
<blockquote>
<ul>
<li>KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己。</li>
</ul>
</blockquote>
<h4 id="13-代理的作用"><a href="#13-代理的作用" class="headerlink" title="13.代理的作用"></a>13.代理的作用</h4><blockquote>
<ul>
<li>代理又叫委托，是一种设计模式，代理是对象与对象之间的通信交互，代理解除了对象之间的耦合性。</li>
<li>改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</li>
<li>另外一点，代理可以理解为java中的回调监听机制的一种类似。</li>
<li>代理的属性常是assign的原因：防止循环引用,以至对象无法得到正确的释放。</li>
</ul>
</blockquote>
<h4 id="14-NSNotification、Block、Delegate和KVO的区别"><a href="#14-NSNotification、Block、Delegate和KVO的区别" class="headerlink" title="14.NSNotification、Block、Delegate和KVO的区别"></a>14.NSNotification、Block、Delegate和KVO的区别</h4><blockquote>
<ul>
<li>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；</li>
<li>效率：Delegate比NSNOtification高；</li>
<li>Delegate和Block一般是一对一的通信；</li>
<li>Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；</li>
<li>Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；</li>
</ul>
</blockquote>
<h4 id="15-Objective-C中可修改和不可以修改类型"><a href="#15-Objective-C中可修改和不可以修改类型" class="headerlink" title="15.Objective-C中可修改和不可以修改类型"></a>15.Objective-C中可修改和不可以修改类型</h4><blockquote>
<ul>
<li>可修改不可修改的集合类，就是可动态添加修改和不可动态添加修改。</li>
<li>比如NSArray和NSMutableArray,前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间</li>
</ul>
</blockquote>
<h4 id="16-当我们调用一个静态方法时-需要对对象进行release吗"><a href="#16-当我们调用一个静态方法时-需要对对象进行release吗" class="headerlink" title="16.当我们调用一个静态方法时,需要对对象进行release吗?"></a>16.当我们调用一个静态方法时,需要对对象进行release吗?</h4><blockquote>
<ul>
<li>不需要,静态方法(类方法)创建一个对象时,对象已被放入自动释放池。在自动释放池被释放时,很有可能被销毁。</li>
</ul>
</blockquote>
<h4 id="17-当我们释放我们的对象时-为什么需要调用-super-dealloc-方法-它的位置又是如何的呢"><a href="#17-当我们释放我们的对象时-为什么需要调用-super-dealloc-方法-它的位置又是如何的呢" class="headerlink" title="17.当我们释放我们的对象时,为什么需要调用[super dealloc]方法,它的位置又是如何的呢?"></a>17.当我们释放我们的对象时,为什么需要调用[super dealloc]方法,它的位置又是如何的呢?</h4><blockquote>
<ul>
<li>因为子类的某些实例是继承自父类的,因此需要调用[super dealloc]方法, 来释放父类拥有的实例,其实也就是子类本身的。一般来说我们优先释放子类拥 有的实例,最后释放父类所拥有的实例。</li>
</ul>
</blockquote>
<h4 id="18-对谓词的认识"><a href="#18-对谓词的认识" class="headerlink" title="18.对谓词的认识"></a>18.对谓词的认识</h4><blockquote>
<ul>
<li>Cocoa 中提供了一个NSPredicate的类,该类主要用于指定过滤器的条件, 每一个对象通过谓词进行筛选,判断条件是否匹配。如果需要了解使用方法，请看谓词的具体使用.</li>
</ul>
</blockquote>
<h4 id="19-static、self、super关键字的作用"><a href="#19-static、self、super关键字的作用" class="headerlink" title="19.static、self、super关键字的作用"></a>19.static、self、super关键字的作用</h4><blockquote>
<ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值.</li>
<li>在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问.</li>
<li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明.</li>
<li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝.</li>
<li>self:当前消息的接收者。</li>
<li>super:向父类发送消息。</li>
</ul>
</blockquote>
<h4 id="20-public、-protected、-private-它们的含义与作用"><a href="#20-public、-protected、-private-它们的含义与作用" class="headerlink" title="20.@public、@protected、@private 它们的含义与作用"></a>20.@public、@protected、@private 它们的含义与作用</h4><blockquote>
<ul>
<li>@public:对象的实例变量的作用域在任意地方都可以被访问 ;</li>
<li>@protected:对象的实例变量作用域在本类和子类都可以被访问 ;</li>
<li>@private:实例变量的作用域只能在本类(自身)中访问 .</li>
</ul>
</blockquote>
<h4 id="21-解释id类型"><a href="#21-解释id类型" class="headerlink" title="21.解释id类型"></a>21.解释id类型</h4><blockquote>
<ul>
<li>任意类型对象，程序运行时才决定对象的类型。</li>
</ul>
</blockquote>
<h4 id="22-switch语句if语句区别与联系"><a href="#22-switch语句if语句区别与联系" class="headerlink" title="22.switch语句if语句区别与联系"></a>22.switch语句if语句区别与联系</h4><blockquote>
<ul>
<li>均表示条件的判断,switch语句表达式只能处理的是整型、字符型和枚举类型,而选择流程语句则没有这样的限制。但switch语句比选择流程控制语句效率更高。</li>
</ul>
</blockquote>
<h4 id="23-isMemberOfClass-和-isKindOfClass-联系与区别"><a href="#23-isMemberOfClass-和-isKindOfClass-联系与区别" class="headerlink" title="23.isMemberOfClass 和 isKindOfClass 联系与区别"></a>23.isMemberOfClass 和 isKindOfClass 联系与区别</h4><blockquote>
<ul>
<li>联系：两者都能检测一个对象是否是某个类的成员</li>
<li>区别：isKindOfClass 不仅用来确定一个对象是否是一个类的成员,也可以用来确定一个对象是否派生自该类的类的成员 ,而isMemberOfClass 只能做到第一点。</li>
<li>举例：如 ClassA派 生 自NSObject 类 , ClassA *a = [ClassA alloc] init];,[a isKindOfClass:[NSObject class]] 可以检查出 a 是否是 NSObject派生类 的成员,但 isMemberOfClass 做不到。</li>
</ul>
</blockquote>
<h4 id="24-iOS开发中数据持久性有哪几种"><a href="#24-iOS开发中数据持久性有哪几种" class="headerlink" title="24.iOS开发中数据持久性有哪几种?"></a>24.iOS开发中数据持久性有哪几种?</h4><p><strong>数据存储的核心都是写文件。</strong></p>
<blockquote>
<ul>
<li>属性列表：只有NSString、NSArray、NSDictionary、NSData可writeToFile；存储依旧是plist文件。plist文件可以存储的7中数据类型：array、dictionary、string、bool、data、date、number。</li>
<li>对象序列化（对象归档）：对象序列化通过序列化的形式，键值关系存储到本地，转化成二进制流。通过runtime实现自动化归档/解档，请参考这个文章。实现NSCoding协议必须实现的两个方法：</li>
</ul>
</blockquote>
<ul>
<li>1.编码（对象序列化）：把不能直接存储到plist文件中得到数据，转化为二进制数据，NSData，可以存储到本地；</li>
<li>2.解码（对象反序列化）：把二进制数据转化为本来的类型。<blockquote>
<ul>
<li>SQLite 数据库：大量有规律的数据使用数据库。</li>
<li>CoreData ：通过管理对象进行增、删、查、改操作的。它不是一个数据库，不仅可以使用SQLite数据库来保持数据，也可以使用其他的方式来存储数据。如：XML。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>CoreData的介绍：</strong></p>
<blockquote>
<ul>
<li>CoreData是面向对象的API，CoreData是iOS中非常重要的一项技术，几乎在所有编写的程序中，CoreData都作为数据存储的基础。</li>
<li>CoreData是苹果官方提供的一套框架，用来解决与对象声明周期管理、对象关系管理和持久化等方面相关的问题。</li>
<li>大多数情况下，我们引用CoreData作为持久化数据的解决方案，并利用它作为持久化数据映射为内存对象。提供的是对象-关系映射功能，也就是说，CoreData可以将Objective-C对象转换成数据，保存到SQL中，然后将保存后的数据还原成OC对象。</li>
</ul>
</blockquote>
<p><strong>CoreData的特征：</strong></p>
<blockquote>
<ul>
<li>通过CoreData管理应用程序的数据模型，可以极大程度减少需要编写的代码数量。</li>
<li>将对象数据存储在SQLite数据库已获得性能优化。</li>
<li>提供NSFetchResultsController类用于管理表视图的数据，即将Core Data的持久化存储在表视图中，并对这些数据进行管理：增删查改。</li>
<li>管理undo/redo操纵；</li>
<li>检查托管对象的属性值是否正确。</li>
</ul>
</blockquote>
<p><strong>Core Data的6成员对象</strong></p>
<blockquote>
<ul>
<li>1.NSManageObject:被管理的数据记录Managed Object Model是描述应用程序的数据模型，这个模型包含实体（Entity）、特性（Property）、读取请求（Fetch Request）等。</li>
<li>2.NSManageObjectContext：管理对象上下文，持久性存储模型对象，参与数据对象进行各种操作的全过程，并监测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI。</li>
<li>3.NSPersistentStoreCoordinator:连接数据库的Persistent Store Coordinator相当于数据文件管理器，处理底层的对数据文件的读取和写入，一般我们与这个没有交集。</li>
<li>4.NSManagedObjectModel：被管理的数据模型、数据结构。</li>
<li>5.NSFetchRequest：数据请求；</li>
<li>6.NSEntityDescription：表格实体结构，还需知道.xcdatamodel文件编译后为.momd或者.mom文件。</li>
</ul>
</blockquote>
<p><strong>Core Data的功能</strong></p>
<blockquote>
<ul>
<li>对于KVC和KVO完整且自动化的支持，除了为属性整合KVO和KVC访问方法外，还整合了适当的集合访问方法来处理多值关系；</li>
<li>自动验证属性（property）值；</li>
<li>支持跟踪修改和撤销操作；</li>
<li>关系维护，Core Data管理数据的关系传播，包括维护对象间的一致性；</li>
<li>在内存上和界面上分组、过滤、组织数据；</li>
<li>自动支持对象存储在外部数据仓库的功能；</li>
<li>创建复杂请求：无需动手写SQL语句，在获取请求（fetch request）中关联NSPredicate。NSPreadicate支持基本功能、相关子查询和其他高级的SQL特性。它支持正确的Unicode编码、区域感知查询、排序和正则表达式；</li>
<li>延迟操作：Core Data使用懒加载（lazy loading）方式减少内存负载，还支持部分实体化延迟加载和复制对象的数据共享机制；</li>
<li>合并策略：Core Data内置版本跟踪和乐观锁（optimistic locking）来支持多用户写入冲突的解决，其中，乐观锁就是对数据冲突进行检测，若冲突就返回冲突的信息；</li>
<li>数据迁移：Core Data的Schema Migration工具可以简化应对数据库结构变化的任务，在某些情况允许你执行高效率的数据库原地迁移工作；</li>
<li>可选择针对程序Controller层的集成，来支持UI的显示同步Core Data在IPhone OS之上，提供NSFetchedResultsController对象来做相关工作，在Mac OS X上我们用Cocoa提供的绑定（Binding）机制来完成的。</li>
</ul>
</blockquote>
<h4 id="25-对象可以被copy的条件"><a href="#25-对象可以被copy的条件" class="headerlink" title="25.对象可以被copy的条件"></a>25.对象可以被copy的条件</h4><blockquote>
<ul>
<li>只有实现了NSCopying和NSMutableCopying协议的类的对象才能被拷贝,分为不可变拷贝和可变拷贝,具体区别戳这；</li>
<li>NSCopying协议方法为：</li>
</ul>
</blockquote>
<pre><code>     -(id)copyWithZone:(NSZone *)zone &#123;
     MyObject *copy = [[[self class] allocWithZone: zone] init];
     copy.username = [self.username copyWithZone:zone];
     return copy;
     &#125;
</code></pre>
<h4 id="26-自动释放池工作原理"><a href="#26-自动释放池工作原理" class="headerlink" title="26.自动释放池工作原理"></a>26.自动释放池工作原理</h4><blockquote>
<ul>
<li>自动释放池是NSAutorelease类的一个实例,当向一个对象发送autorelease消息时,该对象会自动入池,待池销毁时,将会向池中所有对象发送一条release消息,释放对象。</li>
<li>[pool release]、 [pool drain]表示的是池本身不会销毁,而是池子中的临时对象都被发送release,从而将对象销毁。</li>
</ul>
</blockquote>
<h4 id="27-在某个方法中-self-name-name，name-name-它-们有区别吗-为什么"><a href="#27-在某个方法中-self-name-name，name-name-它-们有区别吗-为什么" class="headerlink" title="27.在某个方法中 self.name = _name，name = _name 它 们有区别吗,为什么?"></a>27.在某个方法中 self.name = _name，name = _name 它 们有区别吗,为什么?</h4><blockquote>
<ul>
<li>前者是存在内存管理的setter方法赋值,它会对_name对象进行保留或者拷贝操作</li>
<li>后者是普通赋值</li>
<li>一般来说，在对象的方法里成员变量和方法都是可以访问的，我们通常会重写Setter方法来执行某些额外的工作。比如说，外部传一个模型过来，那么我会直接重写Setter方法，当模型传过来时，也就是意味着数据发生了变化，那么视图也需要更新显示，则在赋值新模型的同时也去刷新UI。</li>
</ul>
</blockquote>
<h4 id="28-解释self-super-init-方法"><a href="#28-解释self-super-init-方法" class="headerlink" title="28.解释self = [super init]方法"></a>28.解释self = [super init]方法</h4><blockquote>
<ul>
<li>容错处理,当父类初始化失败,会返回一个nil,表示初始化失败。由于继承的关系,子类是需要拥有父类的实例和行为,因此,我们必须先初始化父类,然后再初始化子类</li>
</ul>
</blockquote>
<h4 id="29-定义属性时-什么时候用-assign、retain、copy以及它们的之间的区别"><a href="#29-定义属性时-什么时候用-assign、retain、copy以及它们的之间的区别" class="headerlink" title="29.定义属性时,什么时候用 assign、retain、copy以及它们的之间的区别"></a>29.定义属性时,什么时候用 assign、retain、copy以及它们的之间的区别</h4><blockquote>
<ul>
<li>assign:普通赋值,一般常用于基本数据类型,常见委托设计模式, 以此来防止循环引用。(我们称之为弱引用).</li>
<li>retain:保留计数,获得到了对象的所有权,引用计数在原有基础上加1.</li>
<li>copy:一般认为,是在内存中重新开辟了一个新的内存空间,用来 存储新的对象,和原来的对象是两个不同的地址,引用计数分别为1。但是当copy对象为不可变对象时,那么copy 的作用相当于retain。因为,这样可以节约内存空间</li>
</ul>
</blockquote>
<h4 id="30-堆和栈的区别"><a href="#30-堆和栈的区别" class="headerlink" title="30.堆和栈的区别"></a>30.堆和栈的区别</h4><blockquote>
<ul>
<li>栈区(stack)由编译器自动分配释放 ,存放方法(函数)的参数值, 局部变量的值等，栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的。</li>
<li>堆区(heap)一般由程序员分配释放, 若程序员不释放,程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活。</li>
<li>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出.</li>
<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li>
<li>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</li>
<li>全局区(静态区)(static),全局变量和静态变量的存储是放在一块 的,初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。</li>
<li>文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</li>
<li>程序代码区—存放函数体的二进制代码</li>
</ul>
</blockquote>
<h4 id="31-怎样使用performSelector传入3个以上参数，其中一个为结构体"><a href="#31-怎样使用performSelector传入3个以上参数，其中一个为结构体" class="headerlink" title="31.怎样使用performSelector传入3个以上参数，其中一个为结构体"></a>31.怎样使用performSelector传入3个以上参数，其中一个为结构体</h4><ul>
<li>因为系统提供的performSelector的API中，并没有提供三个参数。因此，我们只能传数组或者字典，但是数组或者字典只有存入对象类型，而结构体并不是对象类型,我们只能通过对象放入结构作为属性来传过去了.</li>
</ul>
<pre><code> -(id)performSelector:(SEL)aSelector;
 -(id)performSelector:(SEL)aSelector withObject:(id)object;
 -(id)performSelector:(SEL)aSelector withObject:
 (id)object1 withObject:(id)object2;
</code></pre>
<p>具体实现如下：</p>
<pre><code> typedef struct HYBStruct &#123;
 int a;
 int b;
 &#125; *my_struct;
</code></pre>
<hr>
<pre><code> @interface HYBObject : NSObject

 @property (nonatomic, assign) my_struct arg3;

 @property (nonatomic, copy)  NSString *arg1;

 @property (nonatomic, copy) NSString *arg2;

 @end
 @implementation HYBObject

 // 在堆上分配的内存，我们要手动释放掉

 - (void)dealloc &#123;

 free(self.arg3);

 &#125;

 @end
</code></pre>
<hr>
<p><strong>测试：</strong></p>
<pre><code> my__struct str = (my_struct)(malloc(sizeof(my_struct)));

 str-&gt;a = 1;

 str-&gt;b = 2;

 HYBObject *obj = [[HYBObject alloc] init];

 obj.arg1 = @&quot;arg1&quot;;

 obj.arg2 = @&quot;arg2&quot;;

 obj.arg3 = str;

 [self performSelector:@selector(call:) withObject:obj];

 // 在回调时得到正确的数据的

 -(void)call:(HYBObject *)obj &#123;

 NSLog(@&quot;%d %d&quot;, obj.arg3-&gt;a, obj.arg3-&gt;b);

 &#125;
</code></pre>
<h4 id="32-UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？"><a href="#32-UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？" class="headerlink" title="32.UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？"></a>32.UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</h4><blockquote>
<p>这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode</li>
<li>UIInitializationRunLoopMode：run loop启动时，会切换到该mode</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合<br>苹果公开提供的Mode有两个：</li>
</ul>
</blockquote>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）<blockquote>
<ul>
<li>在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="33-对于单元格重用的理解"><a href="#33-对于单元格重用的理解" class="headerlink" title="33.对于单元格重用的理解"></a>33.对于单元格重用的理解</h4><blockquote>
<ul>
<li>当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。</li>
</ul>
</blockquote>
<h4 id="34-解决cell重用的问题"><a href="#34-解决cell重用的问题" class="headerlink" title="34.解决cell重用的问题"></a>34.解决cell重用的问题</h4><blockquote>
<ul>
<li>UITableView通过重用单元格来达到节省内存的目的，通过为每个单元格指定一个重用标示（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的ID，对于简单的表格，一个标示符就够了。</li>
<li>如一个TableView中有10个单元格，但屏幕最多显示4个，实际上iPhone只为其分配4个单元格的内存，没有分配10个，当滚动单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的个数为屏幕最大显示数，当有新的cell进入屏幕时，会随机调用已经滚出屏幕的Cell所占的内存，这就是Cell的重用。</li>
<li>对于多变的自定义Cell，这种重用机制会导致内容出错，为解决这种出错的方法，把原来的</li>
</ul>
</blockquote>
<pre><code> UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString]
</code></pre>
<blockquote>
<p>修改为：</p>
</blockquote>
<pre><code> UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];
</code></pre>
<blockquote>
<p>这样就解决掉cell重用机制导致的问题。</p>
</blockquote>
<h4 id="35-有a、b、c、d-4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？"><a href="#35-有a、b、c、d-4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？" class="headerlink" title="35.有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？"></a>35.有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？</h4><blockquote>
<ul>
<li>对于这四个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</li>
</ul>
</blockquote>
<pre><code> dispatch_queue_t queue = 

 dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

 dispatch_group_t group = dispatch_group_create();

 dispatch_group_async(group, queue, ^&#123; /*任务a / &#125;);

 dispatch_group_async(group, queue, ^&#123; /任务b / &#125;);

 dispatch_group_async(group, queue, ^&#123; /任务c / &#125;);

 dispatch_group_async(group, queue, ^&#123; /任务d */ &#125;);

 dispatch_group_notify(group,dispatch_get_main_queue(), ^&#123;

 // 在a、b、c、d异步执行完成后，会回调这里

 &#125;);
</code></pre>
<blockquote>
<ul>
<li>当然，我们还可以使用非常老套的方法来处理，通过四个变量来标识a、b、c、d四个任务是否完成，然后在runloop中让其等待，当完成时才退出runloop。但是这样做会让后面的代码得不到执行，直到Run loop执行完毕。</li>
<li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。</li>
</ul>
</blockquote>
<h4 id="36-使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码"><a href="#36-使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码" class="headerlink" title="36.使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码"></a>36.使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码</h4><blockquote>
<ul>
<li>代码紧凑，传值、回调都很方便，省去了写代理的很多代码。</li>
<li>NSTimer封装成的block，具体实现</li>
</ul>
<p>实现方法：</p>
</blockquote>
<pre><code> NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0

 repeats:YES

 callback:^() &#123;

 weakSelf.secondsLabel.text = ...

 &#125;

 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre>
<h4 id="37-一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值"><a href="#37-一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值" class="headerlink" title="37.一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值"></a>37.一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值</h4><blockquote>
<p>有2种方法解决：</p>
<ul>
<li>第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可。</li>
<li>第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找。</li>
</ul>
</blockquote>
<h4 id="38-线程与进程的区别和联系"><a href="#38-线程与进程的区别和联系" class="headerlink" title="38.线程与进程的区别和联系?"></a>38.线程与进程的区别和联系?</h4><blockquote>
<ul>
<li>一个程序至少要有进城,一个进程至少要有一个线程.</li>
<li>进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li>
<li>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</li>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li>
<li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
</ul>
</blockquote>
<h4 id="39-多线程编程"><a href="#39-多线程编程" class="headerlink" title="39.多线程编程"></a>39.多线程编程</h4><blockquote>
<ul>
<li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中。线程同步：多个线程同时访问一个数据会出问题，NSlock、线程同步块、@synchronized(self){}。</li>
<li>NSOperationQueue操作队列（不需考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation、BSBlockOperation、自定义Operation。创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到操作队列中时，默认会调用main方法。</li>
<li>GCD（``Grand Central Dispatch`）宏大的中央调度，串行队列、并发队列、主线程队列；</li>
<li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个。</li>
<li>串行和并行：串行是多个任务按一定顺序执行，并行是多个任务同时执行；</li>
<li>代码是在分线程执行，在主线程嘟列中刷新UI。</li>
</ul>
</blockquote>
<p> ** 多线程编程是防止主线程堵塞、增加运行效率的最佳方法。**</p>
<blockquote>
<ul>
<li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法；</li>
<li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个线程管理器内可以并行运行的线程数量等。</li>
<li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。</li>
<li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力。</li>
</ul>
</blockquote>
<h4 id="40-定时器与线程的区别"><a href="#40-定时器与线程的区别" class="headerlink" title="40.定时器与线程的区别;"></a>40.定时器与线程的区别;</h4><blockquote>
<ul>
<li>定时器;可以执行多次，默认在主线程中。</li>
<li>线程：只能执行一次。</li>
</ul>
</blockquote>
<h4 id="41-TCP和UDP的区别于联系"><a href="#41-TCP和UDP的区别于联系" class="headerlink" title="41.TCP和UDP的区别于联系"></a>41.TCP和UDP的区别于联系</h4><blockquote>
<ul>
<li>TCP为传输控制层协议，为面向连接、可靠的、点到点的通信；</li>
<li>UDP为用户数据报协议，非连接的不可靠的点到多点的通信；</li>
<li>TCP侧重可靠传输，UDP侧重快速传输。</li>
</ul>
</blockquote>
<h4 id="42-TCP连接的三次握手"><a href="#42-TCP连接的三次握手" class="headerlink" title="42.TCP连接的三次握手"></a>42.TCP连接的三次握手</h4><blockquote>
<ul>
<li>第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态。</li>
</ul>
</blockquote>
<h4 id="43-Scoket连接和HTTP连接的区别："><a href="#43-Scoket连接和HTTP连接的区别：" class="headerlink" title="43.Scoket连接和HTTP连接的区别："></a>43.Scoket连接和HTTP连接的区别：</h4><blockquote>
<ul>
<li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</li>
<li>HTTP连接：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLSession。</li>
<li>Socket连接：长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小）。</li>
</ul>
</blockquote>
<h4 id="44-HTTP协议的特点，关于HTTP请求GET和POST的区别"><a href="#44-HTTP协议的特点，关于HTTP请求GET和POST的区别" class="headerlink" title="44.HTTP协议的特点，关于HTTP请求GET和POST的区别"></a>44.HTTP协议的特点，关于HTTP请求GET和POST的区别</h4><p> <strong>GET和POST的区别：</strong></p>
<blockquote>
<ul>
<li>HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。</li>
<li>HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>
<li>HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。</li>
<li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。 </li>
</ul>
<blockquote>
<p>   GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头<requestline>中。<br>   以？分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母或数字，原样发送，<br>   如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。</p>
</blockquote>
<ul>
<li>POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体<request-body>中.</li>
<li>GET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>传输数据的大小：</strong></p>
<ul>
<li>GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。</li>
<li>安全性：</li>
</ul>
<p><strong>POST的安全性要比GET的安全性高；</strong></p>
<ul>
<li>通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。</li>
<li>HTTPS：安全超文本传输协议（Secure Hypertext Transfer Protocol），它是一个安全通信通道，基于HTTP开发，用于客户计算机和服务器之间交换信息，使用安全套结字层（SSI）进行信息交换，即HTTP的安全版。</li>
</ul>
</blockquote>
<h4 id="45-ASIHttpRequest、AFNetWorking之间的区别"><a href="#45-ASIHttpRequest、AFNetWorking之间的区别" class="headerlink" title="45.ASIHttpRequest、AFNetWorking之间的区别"></a>45.ASIHttpRequest、AFNetWorking之间的区别</h4><blockquote>
<ul>
<li>ASIHttpRequest功能强大，主要是在MRC下实现的，是对系统CFNetwork API进行了封装，支持HTTP协议的CFHTTP，配置比较复杂，并且ASIHttpRequest框架默认不会帮你监听网络改变，如果需要让ASIHttpRequest帮你监听网络状态改变，并且手动开始这个功能。</li>
<li>AFNetWorking构建于NSURLConnection、NSOperation以及其他熟悉的Foundation技术之上。拥有良好的架构，丰富的API及模块构建方式，使用起来非常轻松。它基于NSOperation封装的，AFURLConnectionOperation子类。</li>
<li>ASIHttpRequest是直接操作对象ASIHttpRequest是一个实现了NSCoding协议的NSOperation子类；AFNetWorking直接操作对象的AFHttpClient，是一个实现NSCoding和NSCopying协议的NSObject子类。</li>
<li>同步请求：ASIHttpRequest直接通过调用一个startSynchronous方法；AFNetWorking默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:paraments:success:failures方法，对于AFHttpRequestOperation进行同步处理。</li>
<li>性能对比：AFNetworking请求优于ASIHttpRequest；</li>
</ul>
</blockquote>
<h4 id="46-XML数据解析方式各有什么不同，JSON解析有哪些框架？"><a href="#46-XML数据解析方式各有什么不同，JSON解析有哪些框架？" class="headerlink" title="46.XML数据解析方式各有什么不同，JSON解析有哪些框架？"></a>46.XML数据解析方式各有什么不同，JSON解析有哪些框架？</h4><blockquote>
<ul>
<li>XML数据解析的两种解析方式：DOM解析和SAX解析；</li>
<li>DOM解析必须完成DOM树的构造，在处理规模较大的XML文档时就很耗内存，占用资源较多，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值，通常情况下，可以借助XPath查询XML节点；</li>
<li>SAX与DOM不同，它是事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或者一条指令时，程序就产生一个事件进行相应的处理，一边读取XML文档一边处理，不必等整个文档加载完才采取措施，当在读取解析过程中遇到需要处理的对象，会发出通知进行处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</li>
<li>-JSON解析：性能比较好的主要是第三方的JSONKIT和iOS自带的JSON解析类，其中自带的JSON解析性能最高，但只能用于iOS5之后。</li>
</ul>
</blockquote>
<h4 id="47-如何进行真机调试-现在不用开发者账号也可以真机调试"><a href="#47-如何进行真机调试-现在不用开发者账号也可以真机调试" class="headerlink" title="47.如何进行真机调试(现在不用开发者账号也可以真机调试)"></a>47.如何进行真机调试(现在不用开发者账号也可以真机调试)</h4><blockquote>
<ul>
<li>1.首先需要用钥匙串创建一个钥匙（key）；</li>
<li>2.将钥匙串上传到官网，获取iOS Development证书；</li>
<li>3.创建App ID即我们应用程序中的Boundle ID；</li>
<li>4.添加Device ID即UDID；</li>
<li>5.通过勾选前面所创建的证书：App ID、Device ID；</li>
<li>6.生成mobileprovision文件；</li>
<li>7.先决条件：申请开发者账号 99美刀</li>
</ul>
</blockquote>
<h4 id="48-APP发布的上架流程"><a href="#48-APP发布的上架流程" class="headerlink" title="48.APP发布的上架流程"></a>48.APP发布的上架流程</h4><blockquote>
<ul>
<li>1.登录应用发布网站添加应用信息；</li>
<li>2.下载安装发布证书；</li>
<li>3.选择发布证书，使用Archive编译发布包，用Xcode将代码（发布包）上传到服务器；</li>
<li>4.等待审核通过;</li>
<li>5.生成IPA：菜单栏-&gt;Product-&gt;Archive.</li>
</ul>
</blockquote>
<h4 id="49-SVN的使用"><a href="#49-SVN的使用" class="headerlink" title="49.SVN的使用"></a>49.SVN的使用</h4><blockquote>
<ul>
<li>SVN=版本控制+备份服务器，可以把SVN当成备份服务器，并且可以帮助你记住每次上服务器的档案内容，并自动赋予每次变更的版本；</li>
<li>SVN的版本控制：所有上传版本都会帮您记录下来，也有版本分支及合并等功能。SVN可以让不同的开发者存取同样的档案，并且利用SVN Server作为档案同步的机制，即您有档案更新时，无需将档案寄送给您的开发成员。SVN的存放档案方式是采用差异备份的方式，即会备份到不同的地方，节省硬盘空间，也可以对非文字文件进行差异备份。</li>
<li>SVN的重要性：备份工作档案的重要性、版本控管的重要性、伙伴间的数据同步的重要性、备份不同版本是很耗费硬盘空间的；</li>
<li>防止冲突：</li>
<li>1.防止代码冲突：不要多人同时修改同一文件，例如：A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改；</li>
<li>2.服务器上的项目文件Xcodeproj，仅让一个人管理提交，其他人只更新，防止文件发生冲突。</li>
</ul>
</blockquote>
<h4 id="50-如何进行网络消息推送"><a href="#50-如何进行网络消息推送" class="headerlink" title="50.如何进行网络消息推送"></a>50.如何进行网络消息推送</h4><blockquote>
<ul>
<li>一种是Apple自己提供的通知服务（APNS服务器）、一种是用第三方推送机制。</li>
<li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器(APNS)请求deviceToken，并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用。</li>
<li>推送信息内容，总容量不超过256个字节；</li>
<li>iOS SDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示。</li>
<li>优点：不论应用是否开启，都会发送到手机端；</li>
<li>缺点：消息推送机制是苹果服务端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；</li>
<li>第三方推送机制，普遍使用Socket机制来实现，几乎可以达到即时的发送到目标用户手机端，适用于即时通讯类应用。</li>
<li>优点：实时的，取决于心跳包的节奏；</li>
<li>缺点：iOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用。</li>
</ul>
</blockquote>
<h4 id="51-网络七层协议"><a href="#51-网络七层协议" class="headerlink" title="51.网络七层协议"></a>51.网络七层协议</h4><blockquote>
<ul>
<li><strong>应用层：</strong></li>
</ul>
<p>1.用户接口、应用程序；<br>2.Application典型设备：网关；<br>3.典型协议、标准和应用：TELNET、FTP、HTTP</p>
<ul>
<li><strong>表示层：</strong></li>
</ul>
<p>1.数据表示、压缩和加密presentation<br>2.典型设备：网关<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG<br>4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。</p>
<ul>
<li><strong>会话层：</strong></li>
</ul>
<p>1.会话的建立和结束；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</p>
<ul>
<li><strong>传输层：</strong></li>
</ul>
<p>1.主要功能：端到端控制Transport；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：TCP、UDP、SPX</p>
<ul>
<li><strong>网络层：</strong></li>
</ul>
<p>1.主要功能：路由、寻址Network；<br>2.典型设备：路由器；<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；</p>
<ul>
<li><strong>数据链路层：</strong></li>
</ul>
<p>1.主要功能：保证无差错的疏忽链路的data link；<br>2.典型设备：交换机、网桥、网卡；<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</p>
<ul>
<li><strong>物理层：</strong></li>
</ul>
<p>1.主要功能：传输比特流Physical；<br>2.典型设备：集线器、中继器<br>3.典型协议、标准和应用：V.35、EIA/TIA-232.</p>
</blockquote>
<h4 id="52-对NSUserDefaults的理解"><a href="#52-对NSUserDefaults的理解" class="headerlink" title="52.对NSUserDefaults的理解"></a>52.对NSUserDefaults的理解</h4><blockquote>
<ul>
<li>NSUserDefaults：系统提供的一种存储数据的方式，主要用于保存少量的数据，默认存储到library下的Preferences文件夹。</li>
</ul>
</blockquote>
<h4 id="53-SDWebImage原理"><a href="#53-SDWebImage原理" class="headerlink" title="53.SDWebImage原理"></a>53.SDWebImage原理</h4><blockquote>
<p>调用类别的方法：</p>
</blockquote>
<blockquote>
<ul>
<li>从内存中（字典）找图片（当这个图片在本次程序加载过），找到直接使用；</li>
<li>从沙盒中找，找到直接使用，缓存到内存。</li>
<li>从网络上获取，使用，缓存到内存，缓存到沙盒。</li>
</ul>
</blockquote>
<h4 id="54-OC中是否有二维数组，如何实现二维数组"><a href="#54-OC中是否有二维数组，如何实现二维数组" class="headerlink" title="54.OC中是否有二维数组，如何实现二维数组"></a>54.OC中是否有二维数组，如何实现二维数组</h4><blockquote>
<ul>
<li>OC中没有二维数组，可通过嵌套数组实现二维数组。</li>
</ul>
</blockquote>
<h4 id="55-LayoutSubViews在什么时候被调用？"><a href="#55-LayoutSubViews在什么时候被调用？" class="headerlink" title="55.LayoutSubViews在什么时候被调用？"></a>55.LayoutSubViews在什么时候被调用？</h4><blockquote>
<ul>
<li>当View本身的frame改变时，会调用这个方法。</li>
</ul>
</blockquote>
<h4 id="56-深拷贝和浅拷贝"><a href="#56-深拷贝和浅拷贝" class="headerlink" title="56.深拷贝和浅拷贝"></a>56.深拷贝和浅拷贝</h4><blockquote>
<ul>
<li>如果对象有个指针型成员变量指向内存中的某个资源，那么如何复制这个对象呢？你会只是复制指针的值传给副本的新对象吗？指针只是存储内存中资源地址的占位符。在复制操作中，如果只是将指针复制给新对象，那么底层的资源实际上仍然由两个实例在共享。</li>
</ul>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E6%B5%85%E6%8B%B7%E8%B4%9D.png"></p>
<blockquote>
<ul>
<li>浅复制：两个实例的指针仍指向内存中的同一资源，只复制指针值而不是实际资源；</li>
<li>深复制：不仅复制指针值，还复制指向指针所指向的资源。如下图：</li>
</ul>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E6%B5%85%E6%8B%B7%E8%B4%9D.png"></p>
<h4 id="57-对沙盒的理解"><a href="#57-对沙盒的理解" class="headerlink" title="57.对沙盒的理解"></a>57.对沙盒的理解</h4><blockquote>
<ul>
<li>每个iOS应用都被限制在“沙盒”中，沙盒相当于一个加了仅主人可见权限的文件夹，即使在应用程序安装过程中，系统为每个单独的应用程序生成它的主目录和一些关键的子目录。苹果对沙盒有几条限制:</li>
</ul>
<ol>
<li>应用程序在自己的沙盒中运作，但是不能访问任何其他应用程序的沙盒；</li>
<li>应用之间不能共享数据，沙盒里的文件不能被复制到其他<br>应用程序的文件夹中，也不能把其他应用文件夹复制到沙盒中；</li>
<li>苹果禁止任何读写沙盒以外的文件，禁止应用程序将内容写到沙盒以外的文件夹中；</li>
<li>沙盒目录里有三个文件夹：<br>Documents——存储应用程序的数据文件，存储用户数据或其他定期备份的信息；<br>Library下有两个文件夹：Caches存储应用程序再次启动所需的信息，Preferences包含应用程序的偏好设置文件，不可在这更改偏好设置；<br>temp存放临时文件即应用程序再次启动不需要的文件。</li>
</ol>
<ul>
<li>获取沙盒根目录的方法，有几种方法：用NSHomeDirectory获取。</li>
<li>获取Document路径：    NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES).</li>
</ul>
</blockquote>
<h4 id="58-对瀑布流的理解"><a href="#58-对瀑布流的理解" class="headerlink" title="58.对瀑布流的理解"></a>58.对瀑布流的理解</h4><blockquote>
<ul>
<li>首先图片的宽度都是一样的，1.将图片等比例压缩，让图片不变形；2.计算图片最低应该摆放的位置，哪一列低就放在哪；3.进行最优排列，在ScrollView的基础上添加两个tableView，然后将之前所计算的scrollView的高度通过tableView展示出来。</li>
<li>如何使用两个TableView产生联动：将两个tableView的滚动事件禁止掉，最外层scrollView滚动时将两个TableView跟着滚动，并且更改contentOffset，这样产生效果滚动的两个tableView。</li>
</ul>
</blockquote>
<h4 id="59-ViewController-的-loadView-、viewDidLoad-、viewDidUnload-分别是在什么时候调用的？"><a href="#59-ViewController-的-loadView-、viewDidLoad-、viewDidUnload-分别是在什么时候调用的？" class="headerlink" title="59.ViewController 的 loadView,、viewDidLoad,、viewDidUnload 分别是在什么时候调用的？"></a>59.ViewController 的 loadView,、viewDidLoad,、viewDidUnload 分别是在什么时候调用的？</h4><blockquote>
<ul>
<li>viewDidLoad在view从nib文件初始化时调用，loadView在controller的view为nil时调用。</li>
<li>此方法在编程实现view时调用,view控制器默认会注册memory warning notification,当view controller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release,如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。</li>
</ul>
</blockquote>
<h4 id="60-关键字volatile有什么含意-并给出三个不同的例子："><a href="#60-关键字volatile有什么含意-并给出三个不同的例子：" class="headerlink" title="60.关键字volatile有什么含意?并给出三个不同的例子："></a>60.关键字volatile有什么含意?并给出三个不同的例子：</h4><blockquote>
<ul>
<li>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</li>
</ul>
</blockquote>
<blockquote>
<p>• 并行设备的硬件寄存器（如：状态寄存器）；</p>
<p>•一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)；</p>
<p>• 多线程应用中被几个任务共享的变量。</p>
</blockquote>
<h4 id="61-synthesize、-dynamic的理解"><a href="#61-synthesize、-dynamic的理解" class="headerlink" title="61.@synthesize、@dynamic的理解"></a>61.@synthesize、@dynamic的理解</h4><blockquote>
<ul>
<li>@synthesize是系统自动生成getter和setter属性声明;@synthesize的意思是，除非开发人员已经做了，否则由编译器生成相应的代码，以满足属性声明；</li>
<li>@dynamic是开发者自已提供相应的属性声明,@dynamic意思是由开发人员提供相应的代码：对于只读属性需要提供setter，对于读写属性需要提供 setter 和getter。查阅了一些资料确定@dynamic的意思是告诉编译器,属性的获取与赋值方法由用户自己实现, 不自动生成。</li>
</ul>
</blockquote>
<h4 id="62-frame和bounds有什么不同？"><a href="#62-frame和bounds有什么不同？" class="headerlink" title="62.frame和bounds有什么不同？"></a>62.frame和bounds有什么不同？</h4><blockquote>
<ul>
<li>frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）</li>
<li>bounds指的是：该view在本身坐标系统中的位置和大小。（参照点是本身坐标系统）</li>
</ul>
</blockquote>
<h4 id="63-view的touch事件有哪些？"><a href="#63-view的touch事件有哪些？" class="headerlink" title="63.view的touch事件有哪些？"></a>63.view的touch事件有哪些？</h4><blockquote>
<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; 
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;
</code></pre>
</blockquote>
<h4 id="64-自定义实现UITabbarController的原理"><a href="#64-自定义实现UITabbarController的原理" class="headerlink" title="64.自定义实现UITabbarController的原理"></a>64.自定义实现UITabbarController的原理</h4><blockquote>
<ul>
<li>运用字典，点击五个按钮的一个可以从字典里选择一个控制器对象，将其View显示到主控制器视图上。</li>
</ul>
</blockquote>
<h4 id="65-iOS中的响应者链的工作原理"><a href="#65-iOS中的响应者链的工作原理" class="headerlink" title="65.iOS中的响应者链的工作原理"></a>65.iOS中的响应者链的工作原理</h4><blockquote>
<ul>
<li>每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。</li>
<li>当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。</li>
<li>如需了解更多细节，请读<a target="_blank" rel="noopener" href="https://www.tuicool.com/articles/6VFn2q">这篇文章</a></li>
</ul>
</blockquote>
<h4 id="66-View和View之间传值方式"><a href="#66-View和View之间传值方式" class="headerlink" title="66.View和View之间传值方式"></a>66.View和View之间传值方式</h4><blockquote>
<ul>
<li>对象的property属性传值；</li>
<li>方法参数传值；</li>
<li>NSUserDefault传值；</li>
<li>block块传值。</li>
</ul>
</blockquote>
<h4 id="67-property属性的修饰符的作用"><a href="#67-property属性的修饰符的作用" class="headerlink" title="67.property属性的修饰符的作用"></a>67.property属性的修饰符的作用</h4><blockquote>
<ul>
<li>getter=getName、setter=setName：设置setter与getter的方法名；</li>
<li>readwrite、readonly：设置可供访问级别；</li>
<li>assign：方法直接赋值，不进行任何retain操作，为了解决原类型与环循引用问题；</li>
<li>retain：其setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序；</li>
<li>copy：其setter方法进行copy操作，与retain处理流程一样，先对旧值release，再copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。</li>
<li>nonatomic：非原子性访问，不加同步， 多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。</li>
</ul>
</blockquote>
<h4 id="68-对于Run-Loop的理解"><a href="#68-对于Run-Loop的理解" class="headerlink" title="68.对于Run Loop的理解"></a>68.对于Run Loop的理解</h4><blockquote>
<ul>
<li>RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</li>
<li>每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；</li>
<li>在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；</li>
<li>NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；</li>
<li>实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。</li>
</ul>
</blockquote>
<h4 id="69-SQLite中常用的SQL语句"><a href="#69-SQLite中常用的SQL语句" class="headerlink" title="69.SQLite中常用的SQL语句"></a>69.SQLite中常用的SQL语句</h4><blockquote>
<ul>
<li>创建表:creat table 表名 (字段名 字段数据类型 是否为主键, 字段名 字段数据类型, 字段名 字段数据类型…)；</li>
<li>增: insert into 表名 (字段1, 字段2…) values (值1, 值2…)；</li>
<li>删: delete from 表名 where 字段 = 值；</li>
<li>查：select * from 表名 where 字段=值；</li>
<li>改：update 表名 set 字段=值 where 字段=值；</li>
</ul>
</blockquote>
<h4 id="70-XIB与Storyboards的优缺点"><a href="#70-XIB与Storyboards的优缺点" class="headerlink" title="70.XIB与Storyboards的优缺点"></a>70.XIB与Storyboards的优缺点</h4><blockquote>
<p><strong>优点：</strong></p>
</blockquote>
<blockquote>
<ul>
<li>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。</li>
<li>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构。</li>
</ul>
<p><strong>缺点：</strong></p>
</blockquote>
<blockquote>
<ul>
<li>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</li>
<li>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</li>
</ul>
</blockquote>
<h4 id="71-将字符串“2015-04-10”格式化日期转为NSDate类型"><a href="#71-将字符串“2015-04-10”格式化日期转为NSDate类型" class="headerlink" title="71.将字符串“2015-04-10”格式化日期转为NSDate类型"></a>71.将字符串“2015-04-10”格式化日期转为NSDate类型</h4><pre><code> NSString *timeStr = @&quot;2015-04-10&quot;;

 NSDateFormatter *formatter = [[NSDateFormatter alloc] init];

 formatter.dateFormat = @&quot;yyyy-MM-dd&quot;;

 formatter.timeZone = [NSTimeZone defaultTimeZone];

 NSDate *date = [formatter dateFromString:timeStr];

 // 2015-04-09 16:00:00 +0000

 NSLog(@&quot;%@&quot;, date);
</code></pre>
<h4 id="72-队列和多线程的使用原理"><a href="#72-队列和多线程的使用原理" class="headerlink" title="72.队列和多线程的使用原理"></a>72.队列和多线程的使用原理</h4><p><strong>在iOS中队列分为以下几种：</strong></p>
<blockquote>
<ul>
<li>串行队列：队列中的任务只会顺序执行；</li>
<li>dispatch_queue_t q = dispatch_queue_create(“…”, DISPATCH_QUEUE_SERIAL);</li>
<li>并行队列： 队列中的任务通常会并发执行；</li>
<li>dispatch_queue_t q = dispatch_queue_create(“……”,DISPATCH_QUEUE_CONCURRENT);</li>
<li>全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似；</li>
<li>dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</li>
<li>主队列：每一个应用程序对应唯一主队列，直接GET即可；在多线程开发中，使用主队列更新UI；</li>
<li>dispatch_queue_t q = dispatch_get_main_queue();</li>
<li>更多细节见下图：</li>
</ul>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E9%98%9F%E5%88%97%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B1%87%E6%80%BB.png"></p>
<h4 id="73-内存的使用和优化的注意事项"><a href="#73-内存的使用和优化的注意事项" class="headerlink" title="73.内存的使用和优化的注意事项"></a>73.内存的使用和优化的注意事项</h4><blockquote>
<ul>
<li>重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；</li>
<li>尽量把views设置为不透明：当opque为YES的时候，默认是YES的，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能；</li>
<li>不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多；</li>
<li>选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。</li>
<li>gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</li>
<li>延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</li>
<li>数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</li>
<li>处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</li>
<li>重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</li>
<li>避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要;</li>
<li>使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存;</li>
<li>正确选择图片加载方式。</li>
</ul>
</blockquote>
<h4 id="74-UIViewController的完整生命周期"><a href="#74-UIViewController的完整生命周期" class="headerlink" title="74.UIViewController的完整生命周期"></a>74.UIViewController的完整生命周期</h4><blockquote>
<ul>
<li>-[ViewController initWithNibName:bundle:]；</li>
<li>-[ViewController init]；</li>
<li>-[ViewController loadView]；</li>
<li>-[ViewController viewDidLoad]；</li>
<li>-[ViewController viewWillAppear:]；</li>
<li>-[ViewController viewWillLayoutSubviews:]；</li>
<li>-[ViewController viewDidLayoutSubviews:]；</li>
<li>-[ViewController viewDidAppear:]；</li>
<li>-[ViewController viewWillDisappear:]；</li>
<li>-[ViewController viewDidDisappear:]；</li>
<li>-[ViewController viewWillUnload:]；</li>
<li>-[ViewController viewDidUnload:]；</li>
</ul>
</blockquote>
<h4 id="75-UIImageView添加圆角"><a href="#75-UIImageView添加圆角" class="headerlink" title="75.UIImageView添加圆角"></a>75.UIImageView添加圆角</h4><blockquote>
<ul>
<li>最直接的方法就是使用如下属性设置：</li>
</ul>
</blockquote>
<pre><code>  imgView.layer.cornerRadius = 10;

    // 这一行代码是很消耗性能的

  imgView.clipsToBounds = YES;
</code></pre>
<blockquote>
<p><em>这是离屏渲染（off-screen-rendering），消耗性能的</em></p>
<ul>
<li>给UIImage添加生成圆角图片的扩展API：这是on-screen-rendering</li>
</ul>
</blockquote>
<pre><code>   -(UIImage *)imageWithCornerRadius:(CGFloat)radius &#123;
   CGRect rect = (CGRect)&#123;0.f, 0.f, self.size&#125;;

   UIGraphicsBeginImageContextWithOptions(self.size,NO,UIScreen.mainScreen.scale);
   CGContextAddPath(UIGraphicsGetCurrentContext(),

   [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);
   CGContextClip(UIGraphicsGetCurrentContext());

   [self drawInRect:rect];

   UIImage *image = UIGraphicsGetImageFromCurrentImageContext();

   UIGraphicsEndImageContext();

   return image;

   &#125;
</code></pre>
<h4 id="76-了解iOS开发者账号类型"><a href="#76-了解iOS开发者账号类型" class="headerlink" title="76.了解iOS开发者账号类型"></a>76.了解iOS开发者账号类型</h4><p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/iOS%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B.png"></p>
<blockquote>
<ul>
<li>“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。</li>
<li>公司账号允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请公司账号需要填写公司的邓白氏编码（DUNS Number）。</li>
<li>需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。</li>
</ul>
</blockquote>
<h4 id="77-Property属性"><a href="#77-Property属性" class="headerlink" title="77.Property属性"></a>77.Property属性</h4><blockquote>
<p>1.原子性：nonatomic 、atomic</p>
<p>2.读写： readwrite 、readonly</p>
<p>3.方法名：getter=<name>、setter=<name></p>
<p>4.内存：strong、retain、copy、weak、assign 、unsafe_unretained</p>
<p><strong>原子性和读写特性：</strong></p>
<ul>
<li>atomic：原子性，只有一个线程可以同时访问实例。atomic 是线程安全的，至少在当前的读取器是安全的。虽然它是一个默认属性，但是由于其使用同步锁开销较大，会损耗性能。</li>
<li>nonatomic：非原子性的，可以被多个线程访问。效率要比atomic 高，但是不能保证其在多线程状态下的安全性，在单线程和明确只有一个线程访问的情况下被广泛使用。</li>
<li>readwrite（默认值）：表示其同时拥有getter 和 setter 方法；</li>
<li>readonly：只读操作，其只有getter 方法，没有setter法</li>
<li>注：如果某个实例只允许被外部读取，而不能写入操作，同时在类实现文件当中可以写入的话，可以在头文件中声明属性为只读的，在实现文件中设置其为可读写的属性，写法如下：</li>
</ul>
</blockquote>
<pre><code>     //头文件中声明为：

     @property(nonatomic,readonly,copy) NSString *stringA;

     //实现文件中声明为:

     @property(nonatomic,readwrite,copy) NSString *stringA;
</code></pre>
<p> <strong>getter=<name>的样式：</strong></p>
<pre><code>     @property (nonatomic, getter=isOn) BOOL on;
</code></pre>
<p> <strong>弱引用</strong></p>
<blockquote>
<ul>
<li>assign：用于值类型(如int，float等)</li>
<li>weak： 用于修饰引用类型</li>
<li>unsafe_unretained：只修饰引用类型</li>
</ul>
</blockquote>
<blockquote>
<p><strong>区别</strong>：</p>
</blockquote>
<blockquote>
<ul>
<li>三者修饰效果相同，即都不会更改所赋新值的引用计数，也不改变旧值的引用计数</li>
<li>assign一般只修饰值类型，虽然也可以修饰引用类型，但是修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。</li>
<li>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。</li>
<li>unsafe_unretained与assign的区别在于，其只修饰引用类型。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>强引用</strong></p>
<ul>
<li>strong：用于引用类型，强引用。</li>
<li>retain ：用于引用类型，强引用。</li>
<li>copy：修饰属性会在内存里拷贝对象。</li>
</ul>
<p><strong>区别：</strong></p>
</blockquote>
<blockquote>
<ul>
<li>三者都用于修饰引用类型。</li>
<li>strong用于ARC，retain用于MRC。</li>
<li>copy分为浅层复制和深复制两种，NSString、NSArray、NSDictionary等不可变类型都为浅层复制，即其引用计数会+1，而不会创建新的内存</li>
</ul>
</blockquote>
<h4 id="78-了解沙盒的目录结构"><a href="#78-了解沙盒的目录结构" class="headerlink" title="78.了解沙盒的目录结构"></a>78.了解沙盒的目录结构</h4><blockquote>
<p>iOS应用沙盒即文件系统目录，与其他应用的文件系统隔离</p>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E4%BA%86%E8%A7%A3%E6%B2%99%E7%9B%92%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"></p>
<blockquote>
<ul>
<li>Documents：保存应用运行时生成的需要持久化的数据，如游戏进度、涂鸦软件的绘图等信息， 该目录会被iTunes同步备份。</li>
<li>Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据，如缓存图片或者离线数据(地图等)。 </li>
<li>Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录。</li>
<li>tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。重启手机、系统磁盘不足时都会被清理</li>
</ul>
</blockquote>
<h4 id="79-理解内存中的区域划分"><a href="#79-理解内存中的区域划分" class="headerlink" title="79.理解内存中的区域划分"></a>79.理解内存中的区域划分</h4><blockquote>
<ul>
<li>栈区(stack):由系统自动分配和释放，存放局部变量的值，容量小速度快，有序</li>
<li>堆：一般由程序员分配和释放，如果不释放，则出现内存泄露。程序会回收您的内存，特点：容量大，速度慢，无序</li>
<li>静态存储区：全局变量（外部变量）和静态变量都存放在静态区域。当程序结束使，系统回收</li>
<li>常量区：存放常量的内存区域，程序结束时，系统回收</li>
<li>代码区：存放二进制代码的区域</li>
</ul>
</blockquote>
<h4 id="80-理解iOS的远程推送"><a href="#80-理解iOS的远程推送" class="headerlink" title="80.理解iOS的远程推送"></a>80.理解iOS的远程推送</h4><blockquote>
<p><strong>简易推送流程：</strong></p>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/iOS%E6%8E%A8%E9%80%81%E5%8E%9F%E7%90%86.png"></p>
<blockquote>
<ul>
<li>(1) 应用程序安装后提示用户是否需要接收推送，用户确认后注册消息推送。</li>
<li>(2)App接收到从APNS Server获取的令牌信息;</li>
<li>(3)APP将令牌信息发送到自己的服务器端;</li>
<li>(4)当需要向用户推送消息时，自己的服务器将向苹果的推送通知服务器(Apple Push Notification Service,以下简称 APNS)发送通知；</li>
<li>(5)APNS 会向装有此APP的iPhone设备发送消息</li>
</ul>
</blockquote>
<blockquote>
<p><strong>第三方推送的原理(以个推为例)：</strong></p>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E4%B8%89%E6%96%B9%E6%8E%A8%E9%80%81%E5%8E%9F%E7%90%86.png"></p>
<h4 id="81-理解Block的使用"><a href="#81-理解Block的使用" class="headerlink" title="81.理解Block的使用"></a>81.理解Block的使用</h4><p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/Block%E7%9A%84%E5%A3%B0%E6%98%8E.png"></p>
<blockquote>
<p>——–Block为什么要用copy？——–</p>
<p>a、block在创建的时候默认分配的内存是在栈上，而不是在堆上。这样的话其本身的作用域是属于创建时候<br>的作用域，一旦在创建的作用域之外调用就会导致程序的崩溃。所以使用了copy将其拷贝到堆内存上。<br>b、block创建在栈上，而block的代码中可能会用到本地的一些变量，只有将其拷贝到堆上，才能用这些变量</p>
<p>——–Block为什么不用retain？——–</p>
<p>retain这是增加了一次计数，block的内存还是在栈上，并没有存在堆上，存在栈上的block可能随时被系统回收。</p>
<p>——–为什么进入block中的对象引用计数需要自动加1？——–</p>
<p>Block执行的是回调，因此block并不知道其中的对象obj创建后会在什么时候被释放，为了不在block使用obj之前，对象已经被释放，block就retain了obj一次</p>
<p>——–block和函数的关系？——–</p>
<p>Block的使用很像函数指针，不过与函数最大的不同是Block可以访问函数以外、词法作用域以内的外部变量的值。<br>换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。</p>
<p>——–对于block的理解？——–</p>
<p>block实际上是: 指向结构体的指针<br>编译器会将block的内部代码生成对应的函数</p>
<p>——–对于基本数据类型，进入到block中会被当做常量处理？——–</p>
</blockquote>
<pre><code>    //如果需要在block中对num进行修改，需要加上关键字__block

    //(我们也可以用static关键字进行修饰)

    int  num1 = 10;

    void(^block1)() = ^&#123;

     NSLog(@&quot;num1 is %d&quot;,num1);
     
    &#125;;

    num1 = 20;

    block1(); //输出10
     
    //改进:使用block,使进入到block块中的变量不被当做常量来使用

    __blockint  num2 = 10;

    void(^block2)() = ^&#123;

   NSLog(@&quot;num2 is %d&quot;,num2);
   
    &#125;;

    num2 = 20;

    block2(); //输出20
</code></pre>
<blockquote>
<p>——–Block中self的循环引用？——–</p>
<p>block默认创建在栈上，所以对要对其进行执行copy操作，将其拷贝到堆区，便于更好的操作对象。但是执行了copy操作之后，block中使用self，此对象会被retain一次（注意：block在堆区上时才会起到retain作用），会造成循环引用。<br>解决方法：<br>在MRC下，使用__block修饰<br>在ARC下，使用__unsafe_unretained\weak修饰</p>
</blockquote>
<h4 id="82-理解循环引用出现的三种情况："><a href="#82-理解循环引用出现的三种情况：" class="headerlink" title="82.理解循环引用出现的三种情况："></a>82.理解循环引用出现的三种情况：</h4><blockquote>
<ul>
<li>NSTimer<br>NSTimer对象timer作为一个对象A的属性，本意在A的dealloc中释放timer,但是timer没有停止就不会触发dealloc，然后就互相等待，造成循环引用。解决方法是显式的调用timer的关闭方法[timer invaluate],再释放A对象</li>
<li>Block<br>block代码块没有配合weak使用</li>
<li>Delegate<br>声明delegate时请用assign(MRC)或者weak(ARC)。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>循环引用举例：</strong></p>
</blockquote>
<blockquote>
<pre><code>NSMutableArray *firstArray = [NSMutableArray array]; 

NSMutableArray *secondArray = [NSMutableArray array];

[firstArray addObject:secondArray]; 

[secondArray addObject:firstArray];
</code></pre>
</blockquote>
<blockquote>
<p><strong>检测循环引用</strong></p>
</blockquote>
<blockquote>
<ul>
<li>Xcode -&gt; Product -&gt; Pofile -&gt; Leaks</li>
</ul>
</blockquote>
<h4 id="83-理解指针的使用"><a href="#83-理解指针的使用" class="headerlink" title="83.理解指针的使用"></a>83.理解指针的使用</h4><blockquote>
<p><strong>用变量a给出下面的定义<a target="_blank" rel="noopener" href="https://blog.csdn.net/ropenyuan/article/details/6678080">原文链接</a></strong></p>
<p>a) 一个整型数</p>
<p>b) 一个指向整型数的指针</p>
<p>c) 一个指向指针的的指针，它指向的指针是指向一个整型数</p>
<p>d) 一个有10个整型数的数组</p>
<p>e) 一个有10个指针的数组，该指针是指向一个整型数的</p>
<p>f) 一个指向有10个整型数数组的指针</p>
<p>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数</p>
<p>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</p>
</blockquote>
<h4 id="84-理解iOS中的多线程"><a href="#84-理解iOS中的多线程" class="headerlink" title="84.理解iOS中的多线程"></a>84.理解iOS中的多线程</h4><p><strong>1.概念理解:</strong></p>
<blockquote>
<p>多线程是针对于单核的CPU来设计的，目的是为了让CPU快速在多个线程之间进行调度。</p>
<ul>
<li>多线程的优缺点<br>优点：提高程序的执行效率<br>缺点：开启线程需要一定的内存空间</li>
<li>同步和异步：决定了可不可以开启新的线程<br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力</li>
<li>并行与串行：决定了任务的执行方式<br>并行：多个任务并发（同时）执行。类型迅雷，多个任务同时开启下载<br>串行：一个任务执行完毕后，再执行下一个任务。类似浏览器的一个接一个下载</li>
</ul>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E4%B8%B2%E8%A1%8C%E5%B9%B6%E8%A1%8C.png"></p>
<blockquote>
<p><em>iOS应用程序中都是一个主线程，也称为UI线程<br>那么主线程的作用就是用来更新UI，显示或者刷新界面<br>注意：不能将耗时的任务放在主线程上，否则会出现卡顿的现象。</em></p>
</blockquote>
<blockquote>
<p><strong>2.iOS的三种多线程编程技术</strong></p>
<ul>
<li>NSThread<br>直接操作线程对象，但需要手动管理生命周期，而且经常使用这种方式来查看当前线程</li>
<li>GCD（Grand Central Dispatch）<br>底层使用的是C语言，灵活方便，可以根据系统负荷来增减线程，性能效率更好</li>
<li>Cocoa NSOperation<br>NSOperation对GCD的封装，使用起来更好理解，将任务封装为NSOpertaion,添加到NSOPerationQueue对象中<br>子类化NSOpertaion的设计，更具有面向对象（封装，复用）的特性。更加适合在复杂项目中使用</li>
</ul>
<p><strong>3.进程与线程</strong></p>
<p>Progress和Thread,进程和线程是操作系统里的基本概念</p>
<ul>
<li>线程与进程的区别:<br>线程是资源分配的最小单位，也是处理器调度的基本单位，但是进程不是<br>进程是资源拥有的单位，同一个进程内的线程共享进程里的资源</li>
<li>多进程，允许多个任务同时运行</li>
<li>多线程，允许单个任务分为不同的部分运行</li>
</ul>
</blockquote>
<h4 id="85-了解音频播放相关知识"><a href="#85-了解音频播放相关知识" class="headerlink" title="85.了解音频播放相关知识"></a>85.了解音频播放相关知识</h4><blockquote>
<p><em>音频的播放从形式上分为音频播放和音乐播放。<br>音频播放：通常时间较短，不需要进度控制，和循环控制。使用AudioToolbox.framework。<br>音乐播放：通常时间较长，需要进行精准控制。使用AVFoundation.framework。</em></p>
<p><strong>音频播放</strong><br>AudioToolbox.framework是基于C语言的框架。</p>
<ul>
<li>原理：将短音频注册的到系统声音服务(System Sound Service)中。System Sound Service是一种简单、底层的声音播放服务。</li>
<li>1.音频播放时间不能超过30秒。</li>
<li>2.数据必须是PCM或者IMA4格式。</li>
<li>3.音频格式必须打包成.caf、.aif、wav中的一种。（这是官方说法，实际发现一些.mp3也可以)。</li>
</ul>
<p><strong>音乐播放</strong></p>
<ul>
<li><p>1.适合播放较大的音频。</p>
</li>
<li><p>2.可以对音频进行精准的播放控制</p>
</li>
<li><p>3.使用AVFoundataion.framework中的AVAudioPlayer来实现。</p>
</li>
<li><p><em>使用：</em>*</p>
</li>
<li><p>1.初始化AVAudioPlayer对象，通常是指定本地文件路径</p>
</li>
<li><p>2.设置播放器属性，例如重复次数，音量大小等。</p>
</li>
<li><p>3.调用play方法播放。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>AVAudioPlayer一次只能播放一个音频文件，所有的上一曲和下一曲都是通过创建多个AVAudioPlayer来实现的。</li>
</ul>
</blockquote>
<h4 id="86-理解NSOperationQueue"><a href="#86-理解NSOperationQueue" class="headerlink" title="86.理解NSOperationQueue"></a>86.理解NSOperationQueue</h4><blockquote>
<ul>
<li>NSOperationQueue是存放NSOPeration的集合类，可以参考JAVA中的线程和线程池的概念。</li>
<li>虽说是queue，但并不是队列的意思，并不遵守先进先出。</li>
<li>所以我们可以理解为Pool ，即线程池。</li>
</ul>
</blockquote>
<h4 id="87-理解OC是动态运行时语言"><a href="#87-理解OC是动态运行时语言" class="headerlink" title="87.理解OC是动态运行时语言"></a>87.理解OC是动态运行时语言</h4><blockquote>
<ul>
<li>OC将数据、对象类型的确定从编译阶段推迟到了运行时。实现这一操作的基础是面向对象语言的多态特性。</li>
<li>这里面有有两个关键字：运行时和多态</li>
<li>运行时：运行时机制使我们知道运行的时候才确定一个对象的类型、以及调用该类别对象指定的方法。</li>
<li>多态：不同的对象以自己的方式来响应相同的消息。子类的指针可以赋值给父类。</li>
</ul>
</blockquote>
<h4 id="88-GCD的queue、main-queue中执行的代码一定是在main-thread么？"><a href="#88-GCD的queue、main-queue中执行的代码一定是在main-thread么？" class="headerlink" title="88.GCD的queue、main queue中执行的代码一定是在main thread么？"></a>88.GCD的queue、main queue中执行的代码一定是在main thread么？</h4><blockquote>
<p><em>“queue中所执行的代码不一定在main thread中。如果queue是在主线程中创建的，那么所执行的代码就是在主线程中执行。如果是在子线程中创建的，那么就不会在main thread中执行。“</em></p>
<p>上述说法并不完全正确，queue中所执行的代码不一定在主线程是对的，但是队列Queue中执行的任务是在否在主线程与创建队列所在的线程并无关系。</p>
<h5 id="对于这个问题，首先总结几个知识点："><a href="#对于这个问题，首先总结几个知识点：" class="headerlink" title="对于这个问题，首先总结几个知识点："></a><strong>对于这个问题，首先总结几个知识点：</strong></h5><p><strong>1.iOS中获取队列的三种方式：</strong></p>
<ul>
<li><p>主线程队列：<br>主线程队列为串行队列，和主线程绑定。同普通串行队列一样，队列中任务一次只能执行一个，但是队列中所有任务都在主线程中执行(经过测试，即使是异步添加的任务，也没有创建新的线程)。</p>
</li>
<li><p>全局队列：<br>系统全局队列为并发队列，根据不同的优先级(HIGH、DEFAULT、LOW、BACKGROUND)有四个。</p>
</li>
<li><p>自定义队列：<br>系统提供方法，可以自定义创建串行和并行队列。</p>
</li>
</ul>
<p><strong>2.同步与异步，串行与并行</strong></p>
<p><em>同步与异步：决定可不可以开启新的线程</em></p>
<ul>
<li>同步：在当前线程立即执行添加的任务，不具备开启新线程的能力。</li>
<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>
</ul>
<p><em>并行与串行：决定了任务的执行方式</em></p>
<ul>
<li>并行：可以多个任务并发（同时）执行。类似迅雷，多个任务同时开启下载</li>
<li>串行：一个任务执行完毕后，再执行下一个任务。类似浏览器的一个接一个下载</li>
</ul>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E4%B8%B2%E8%A1%8C%E5%B9%B6%E8%A1%8C.png"></p>
<blockquote>
<p>对于这个问题，我使用代码测试了使用的情况如下：</p>
</blockquote>
<p><img src="/uploads/images/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E6%89%80%E7%94%A8%E5%9B%BE%E7%89%87/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E4%B8%B2%E8%A1%8C%E5%B9%B6%E8%A1%8C%E7%BB%84%E5%90%88%E6%83%85%E5%86%B5.png"></p>
<blockquote>
<p><em>总结：队列Queue中执行的任务是在否在主线程与创建队列所在的线程无关。</em></p>
</blockquote>
<blockquote>
<ul>
<li>判断一个任务是不是在主线程，我们可以首先判断同步还是异步，因为异步才具有开启新线程的能力。然而我们还需要注意两点：</li>
<li>1.主线程所在队列为串行队列，添加同步会导致死锁。</li>
<li>2.并非所有的异步任务都不在主线程中，主线程队列中添加异步任务，并不开启新的线程。</li>
</ul>
</blockquote>
<h4 id="89-常见的Http状态码有哪些？"><a href="#89-常见的Http状态码有哪些？" class="headerlink" title="89.常见的Http状态码有哪些？"></a>89.常见的Http状态码有哪些？</h4><blockquote>
<ul>
<li>302是请求重定向。</li>
<li>500及以上是服务器错误，如503表示服务器找不到、3840表示服务器返回无效JSON。</li>
<li>400及以上是请求链接错误或者找不到服务器，如常见的404。</li>
<li>200及以上是正确，如常见的是200表示请求正常。</li>
</ul>
</blockquote>
<blockquote>
<p>更多参考： <a target="_blank" rel="noopener" href="http://tool.oschina.net/commons?type=5">Http状态码详细说明</a></p>
</blockquote>
<h4 id="90-区分UDID与UUID"><a href="#90-区分UDID与UUID" class="headerlink" title="90.区分UDID与UUID"></a>90.区分UDID与UUID</h4><blockquote>
<ul>
<li><strong>UDID</strong>（Unique Device Identifier）：用户设备唯一编码</li>
</ul>
<p>UDID是一串由40位16进制数组成的字符串，用以标识唯一的设备。苹果从iOS5开始就移除了通过代码访问UDID的权限，所以我们无法从代码中获取用户设备的UDID。如果我们想查看自己设备的UDID，可以通过iTunes来查看。通常我们在增加Provisioning Profile文件时会用到。</p>
<ul>
<li><strong>UUID</strong>（Universally Unique IDentifier）：通用唯一识别符</li>
</ul>
<p>UUID是一个32位的十六进制序列，使用小横线来连接：8-4-4-4-12 。它是一种应用加设备绑定产生的标识符，可以通过代码获得。当在设备上安装来自同一个供应商的不同App时，此值保持不变。如果你删除了来自某个供应商的所有app，再重新安装时，此值会改变。</p>
<p><strong>获取UUID的方法：</strong><br>NSString *uuidString = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</p>
</blockquote>
<h4 id="91-区分nil-、Nil、NULL、NSNUll"><a href="#91-区分nil-、Nil、NULL、NSNUll" class="headerlink" title="91.区分nil 、Nil、NULL、NSNUll"></a>91.区分nil 、Nil、NULL、NSNUll</h4><blockquote>
<ul>
<li>nil</li>
</ul>
<p>nil一般是指把一个对象置空，既完全是一个空对象，完全从内存中释放。</p>
<ul>
<li>Nil</li>
</ul>
<p>Nil和nil基本没有任何区别，也可以说只要是可以使用nil的地方都可以使用Nil，反之亦然。但是作为程序猿，我们应该更加严谨一些。nil和Nil的区别在于，nil表示置空一个对象，而Nil表示置空一个类。</p>
<ul>
<li>NULL</li>
</ul>
<p>大家都知道oc 是基于c的，并且oc是完全兼容c的，NULL源于c，表示一个空指针.<br>即：int *p = NULL</p>
<ul>
<li>NSNull</li>
</ul>
<p>NSNull很有意思，大家一般都会觉得，NSNull也是空，但是看着这货又是“NS”开头的很像一个对象，实质上NSNull的确是一个对象，它继承于NSObject。那它和nil的区别在哪里呢？nil是把一对象完全释放，就是完全从内存中释放。但是当我想把一个对象置空但是又想要一个容器的时候，我们就可以使用NSNull。比如一瓶矿泉水，我们不想要里面的水，但是我们想保留瓶子一样。</p>
</blockquote>
<h4 id="92-区分MRC和ARC内存管理"><a href="#92-区分MRC和ARC内存管理" class="headerlink" title="92.区分MRC和ARC内存管理"></a>92.区分MRC和ARC内存管理</h4><blockquote>
<ul>
<li><p>iOS5.0以后出现的ARC，即自动引用计数(Automatic Refrence Counting)，减少了代码，省去了对象释放的麻烦。</p>
</li>
<li><p>ARC项目：加入MRC：</p>
</li>
</ul>
<p> target -&gt;build phrases -&gt;compbile sources ，点击mrc的文件将其设置为 -fno-objc-arc</p>
<ul>
<li>MRC项目：加入ARC：</li>
</ul>
<p> target -&gt;build phrases -&gt;compbile sources ，点击arc的文件将其设置为 -fobjc-arc</p>
<ul>
<li>iOS通过引用计数来记录对象的引用，每次runloop完成一次循环的时候，都会检查对象的retainCount，如果说对象的retainCount为0，说明该对象没有地方需要引用了，就可以释放掉了。</li>
</ul>
</blockquote>
<h4 id="93-区分黑盒测试与白盒测试"><a href="#93-区分黑盒测试与白盒测试" class="headerlink" title="93. 区分黑盒测试与白盒测试"></a>93. 区分黑盒测试与白盒测试</h4><blockquote>
<ul>
<li>黑盒：已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用， “黑盒”法着眼于程序外部结构、不考虑内部逻辑结构、针对软件界面和软件功能进行测试。“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。</li>
<li>白盒：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。“白盒”法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据</li>
</ul>
</blockquote>
<h4 id="94-区分深拷贝与浅拷贝"><a href="#94-区分深拷贝与浅拷贝" class="headerlink" title="94.区分深拷贝与浅拷贝"></a>94.区分深拷贝与浅拷贝</h4><blockquote>
<ul>
<li>浅拷贝：指针拷贝，不增加新的内存。只是新增加一个指针指向原来的内存区域。</li>
<li>深拷贝：内容拷贝，同时拷贝指针和指针指向的内存。新增指针指向新增的内存。</li>
<li>拷贝条件：<br>iOS中并非所有的对象都支持copy和mutableCopy，只有遵循了NSCopy协议或者NSMutableCoy协议的类才行。如果遵循着两个协议就必须分别实现copyWithZone和mutableCopyZone方法</li>
<li>拷贝原则：</li>
</ul>
<p> 1.非容器类：像NSString、NSNumber这样的不能包含其他对象的系统类<br> 不可变对象调用copy是浅拷贝；而调用muablecopy是深拷贝并得到可变对象<br> 可变对象调用copy和mutablecopy都是深拷贝， 区别在于copy返回不可变对象，mutablecopy返回可变对象</p>
<p> 2.容器类：像NSArray、NSMutableArray等系统类<br> 不可变对象调用copy是浅拷贝，而调用muablecopy是深拷贝并得到可变对象。<br> 可变对象调用copy和mutablecopy都是深拷贝，区别在于copy返回不可变对象，mutablecopy返回可变对象</p>
<p> 容器类与非容器类的拷贝原则相似，但需要注意的是：所有的容器类的拷贝，拷贝后新容器里的元素始终是浅拷贝，其指针都指向原来对象。</p>
<p> 3.自定义类：比如我们自定义一个Student类(实现拷贝协议)<br> 拷贝协议的具体实现不同，拷贝效果也就不同。在实现的拷贝协议方法中直接返回对象的self就相当于浅拷贝了，但是是如果返回新创建对象就是深拷贝了。</p>
</blockquote>
<p>关于拷贝的可参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenyufeng1991/article/details/51771728#">参考链接1</a> 、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f01d490401f9https://www.jianshu.com/p/f01d490401f9">参考链接2</a></p>
<h4 id="95-区别Strong和weak"><a href="#95-区别Strong和weak" class="headerlink" title="95.区别Strong和weak"></a>95.区别Strong和weak</h4><blockquote>
<ul>
<li>在网上找个比较形象的列子来方便理解：</li>
</ul>
<p> 想象我们研究的对象是一条狗，狗想要跑掉（被释放）。</p>
<ul>
<li>1.Strong<br>strong型指针就像是栓住的狗。只要你用牵绳挂住狗，狗就不会跑掉。如果有5个人牵着一条狗（5个strong型指针指向1个象），除非5个牵绳都脱落 ，否着狗是不会跑掉的。</li>
<li>2.Weak<br>weak型指针就像是一个小孩指着狗喊到：“看！一只狗在那” 只要狗一直被栓着，小孩就能看到狗，（weak指针）会一直指向它。只要狗的牵绳脱落，狗就会跑掉，不管有多少小孩在看着它。
　　</li>
<li>总结：只要最后一个strong型指针不再指向对象，那么对象就会被释放，即使还有weak型指针指向它。一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。</li>
</ul>
</blockquote>
<h4 id="96-区分MVC与MVVM"><a href="#96-区分MVC与MVVM" class="headerlink" title="96.区分MVC与MVVM"></a>96.区分MVC与MVVM</h4><blockquote>
<ul>
<li>MVC弊端：Controller通常负责Model和View关联，造成View和Model的耦合度高，而且Controller变得庞大复杂。</li>
<li>MVVM优点：</li>
</ul>
<p> 1.低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p> 2.可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。</p>
<p> 3.独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。</p>
<p> 4.可测试性。可以针对ViewModel来对界面(View)进行测试</p>
</blockquote>
<h4 id="97-区分类目与扩展"><a href="#97-区分类目与扩展" class="headerlink" title="97.区分类目与扩展"></a>97.区分类目与扩展</h4><blockquote>
<ul>
<li>类目:category 为已知的类增加新的方法</li>
</ul>
<p>1.类目中扩展的方法会被子类继承</p>
<p>2.增加原有类的方法，而且是可以增加多个类目将大的功能划分为小功能。</p>
<p>3.类目中的方法会比原有类中的方法具有更高优先级。所以不能和原有类方法重名否则覆盖。</p>
<p>4.类目只能添加方法，不能添加变量</p>
<ul>
<li>扩展：即延展，一般是在一个类的实现文件中。给当前类添加私有变量和私有方法。添加的方法是必须实现的</li>
</ul>
</blockquote>
<h4 id="98-区分-include、-import和-class"><a href="#98-区分-include、-import和-class" class="headerlink" title="98.区分#include、#import和@class"></a>98.区分#include、#import和@class</h4><blockquote>
<ul>
<li>“#include”</li>
</ul>
<p>一般来说，导入objective-C的头文件时用#import，导入c/c++头文件用#include。include相当于拷贝文件中的声明内容，多次使用就会报重复定义的错误。如： class A，class B都引用了class C，而class D中又同时引用class A与class B，就会报重复引用的错误。</p>
<ul>
<li>“#import”</li>
</ul>
<p>不会产生重复定义的错误，因为它会做一次判断，如果已经导入就不再导入了</p>
<ul>
<li>@class</li>
</ul>
<p>@class仅仅是类的声明，告诉编译器有这么个类，具体这个类怎么定义一无所知。<br>@class在编译的时候，速度更快，解决引用循环依赖死锁的问题(类的扩展，代理设计模式）<br>@class还可以解决循环依赖的问题，例如A.h导入了B.h，而B.h导入了A.h，每一个头文件的编译都要让对象先编译成功才行。这样的话，在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。</p>
<ul>
<li>注：＃import&lt;&gt; 跟 #import””区别：＃import&lt;&gt; 包含iOS框架类库里的类，#import””包含项目里自定义的类。</li>
</ul>
</blockquote>
<h4 id="99-区分TCP和UDP"><a href="#99-区分TCP和UDP" class="headerlink" title="99.区分TCP和UDP"></a>99.区分TCP和UDP</h4><blockquote>
<ul>
<li>TCP：面向连接、传输可靠（保证数据正确性，保证数据顺序传输）、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</li>
<li>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快，传输的是报文。</li>
</ul>
</blockquote>
<h4 id="100-区分HTTP与Socket"><a href="#100-区分HTTP与Socket" class="headerlink" title="100.区分HTTP与Socket"></a>100.区分HTTP与Socket</h4><blockquote>
<ul>
<li>HTTP请求：客户端主动发起请求，服务器才能给予响应，一次请求完毕后则断开连接，节省资源。</li>
<li>Socket：客户端与服务器端直接使用socket套接字连接，双方保持连接通道，都可以主动发送数据，适合游戏或股票等这种即时性很强的要求。主要使用的类是CFSockdetRef。</li>
</ul>
</blockquote>
<h4 id="101-区分KVC和KVO"><a href="#101-区分KVC和KVO" class="headerlink" title="101.区分KVC和KVO"></a>101.区分KVC和KVO</h4><blockquote>
<ul>
<li>KVC:值编码，一种使用字符串标识属性，间接访问对象属性的方法。而不是调用存取方法。</li>
<li>KVO:观察者模式。通过监听对象的属性来更新UI或者状态</li>
</ul>
</blockquote>
<h4 id="102-区分MD5和Base64两种加密"><a href="#102-区分MD5和Base64两种加密" class="headerlink" title="102.区分MD5和Base64两种加密"></a>102.区分MD5和Base64两种加密</h4><blockquote>
<ul>
<li><p>“数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，使其只能在输入相应的密钥之后才能显示出本来内容，通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。 该过程的逆过程为解密，即将该编码**信息转化为其原来数据的过程。”</p>
</li>
<li><p>“加密技术通常分为两大类：“对称式”和“非对称式”。”</p>
</li>
<li><p>——–以上内容摘自百度——–*</p>
</li>
<li><p>MD5：严格来说不算加密算法，只能说是摘要算法，而且是一种不可逆的摘要算法。MD5用于生成摘要，并且无法逆破解得到原文。我们常用它验证数据的有效性，比如，在网络请求接口中，通过将所有的参数生成摘要，客户端和服务端采用同样的规则生成摘要，验证数据的有效性。</p>
</li>
<li><p>Base64：一种用64个字符来表示任意二进制数据的编码方式，严格来说也不算是一种加密。Base64的操作是可逆的，经过encode加密，可以decode得到原文。Base64常用来解决网络请求中特殊编码问题和轻量型的加密(转化为非明文)。</p>
</li>
<li><p>关于这两种技术是否为加密算法的讨论有很多，我是这样理解的：<br>严格意义上来说，这两种技术都不能算是真正的加密算法。但是把明文转化为不可读的密文，这本就算是一种加密。在日常的开发工作中，我们经常用这两种方式将一些数据转为不可读密文，因此称它们叫做加密算法也不为过。至于是否为加密算法只是一种说法而已，只要理解了其基本原理与用法即可。又或许我们把它们叫作为一种加密方式会好些。</p>
</li>
</ul>
</blockquote>
<h4 id="103-区分define定义的宏和const定义的常量"><a href="#103-区分define定义的宏和const定义的常量" class="headerlink" title="103.区分define定义的宏和const定义的常量"></a>103.区分define定义的宏和const定义的常量</h4><blockquote>
<ul>
<li>define定义宏的指令，程序在预处理阶段将用#define所定义的内容只是进行了替换。因此程序运行时，常量表中并没有用#define所定义的宏，系统并不为它分配内存，而且在编译时不会检查数据类型，出错的概率要大一些。</li>
<li>const定义的常量，在程序运行时是存放在常量表中，系统会为它分配内存，而且在编译时会进行类型检查。</li>
</ul>
</blockquote>
<h4 id="104-区分id与instancetype"><a href="#104-区分id与instancetype" class="headerlink" title="104.区分id与instancetype"></a>104.区分id与instancetype</h4><blockquote>
<ul>
<li>id:万能指针，指向任意类型</li>
<li>instancetype：只能作为方法的范围类型，并且返回的类型是当前定义类的类型。</li>
</ul>
</blockquote>
<h4 id="105-区分通知和代理"><a href="#105-区分通知和代理" class="headerlink" title="105.区分通知和代理"></a>105.区分通知和代理</h4><blockquote>
<ul>
<li>同：都用于对象之间的通信</li>
<li>异：代理是一对一通信。通知可以一对一，也可以一对多</li>
</ul>
</blockquote>
<h4 id="106-区分methord和selector"><a href="#106-区分methord和selector" class="headerlink" title="106.区分methord和selector"></a>106.区分methord和selector</h4><blockquote>
<ul>
<li>selector只是一个方法名，而method包含了方法名和方法实现。</li>
</ul>
</blockquote>
<h4 id="107-区分isKindOfClass-与isMemberOfClass"><a href="#107-区分isKindOfClass-与isMemberOfClass" class="headerlink" title="107.区分isKindOfClass 与isMemberOfClass"></a>107.区分isKindOfClass 与isMemberOfClass</h4><blockquote>
<ul>
<li>isKindOfClass:确定一个对象是否是一个类的成员,或者是派生自该类的成员.</li>
<li>isMemberOfClass:确定一个对象是否是当前类的成员.</li>
<li>注:isMemberOfClass不能检测任何的类都是基于NSObject类这一事实，而isKindOfClass可以。</li>
</ul>
</blockquote>
<h4 id="108-区别面向过程和面向对象"><a href="#108-区别面向过程和面向对象" class="headerlink" title="108.区别面向过程和面向对象"></a>108.区别面向过程和面向对象</h4><blockquote>
<ul>
<li>面向过程：以事件为编程中心，各功能的实现是按照事件的先后顺序或者因果关系来展开的编程的一种思想</li>
<li>面向对象：以对象为编程的中心，以事件为驱动，各功能是模块化的，彼此之间独立互不影响的一种编程思想。</li>
</ul>
</blockquote>
<h4 id="109-单例的两种写法"><a href="#109-单例的两种写法" class="headerlink" title="109.单例的两种写法"></a>109.单例的两种写法</h4><blockquote>
<ul>
<li><p>单例的目的：通过特殊的构造在不同的地方可以得到同一个对象</p>
</li>
<li><p>方法一：类方法加锁（使用synchronized关键字）</p>
</li>
</ul>
</blockquote>
<pre><code>     static Person *ps;

     +(Person *)sharePerson&#123;

     if (ps == nil) &#123;

         @synchronized(self)&#123;

             //加上锁

              ps = [[Person alloc] init];

         &#125;

     &#125;

     return  ps;

     &#125;
</code></pre>
<blockquote>
<ul>
<li>方法二：通过GCD方法创建</li>
</ul>
</blockquote>
<pre><code>     //dispatch_once只执行一次，确保dispatch_once中的代码块在应用程序里面只执行一次，无论是不是多线程。

     + (Person *)sharePerson&#123;
      
     static dispatch_once_t onceToken;
  
     dispatch_once(&amp;onceToken, ^&#123;
  
         ps = [[Person alloc] init];
      
     &#125;);
  
     return  ps;
  
     &#125;
</code></pre>
<h4 id="110-多任务合并的网络请求处理"><a href="#110-多任务合并的网络请求处理" class="headerlink" title="110.多任务合并的网络请求处理"></a>110.多任务合并的网络请求处理</h4><blockquote>
<ul>
<li>题目分析：10个请求要全部完成后，才执行某一功能。比如，下载10图片后合成一张大图，就需要异步全部下载完成后，才能合并成大图。</li>
<li>实现思路：通过dispatch_group_t来实现，将每个请求放入到Group中，将合并成大图的操作放在dispatch_group_notify中实现。</li>
</ul>
</blockquote>
<blockquote>
<pre><code>    dispatch_queue_tqueue = 

    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    dispatch_group_tgroup = dispatch_group_create();

    dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);

    dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);

    dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); 


    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;

       // 合并图片

    &#125;);
</code></pre>
</blockquote>
<h4 id="111-使用NSLog输出一个浮点类型，保留一位小数"><a href="#111-使用NSLog输出一个浮点类型，保留一位小数" class="headerlink" title="111.使用NSLog输出一个浮点类型，保留一位小数"></a>111.使用NSLog输出一个浮点类型，保留一位小数</h4><blockquote>
<p>//结果四舍五入，保留一个小数</p>
<pre><code>float money = 1.011；

NSlog(@“%.1f”，money);
</code></pre>
</blockquote>
<h4 id="112-内存优化的方案"><a href="#112-内存优化的方案" class="headerlink" title="112.内存优化的方案"></a>112.内存优化的方案</h4><blockquote>
<ul>
<li>1.首选使用ARC环境开发，但是也要注意防止循环引用的产生，避免内存泄漏</li>
<li>2.懒加载，延迟创建对象，需要的时候才创建节省内存消耗</li>
<li>3.复用，单元格的服用，避免过多的创建对象</li>
<li>4.选择正确的是数据结构，不必要的时候不使用可变容器</li>
<li>5.单例模式</li>
<li>6.及时删除缓存信息</li>
</ul>
</blockquote>
<h4 id="113-Xcode工具的使用"><a href="#113-Xcode工具的使用" class="headerlink" title="113.Xcode工具的使用"></a>113.Xcode工具的使用</h4><blockquote>
<ul>
<li>在开发过程中遇到类似内存泄漏的问题，我们可以通过Xcode中的Instruments来分析解决问题：</li>
</ul>
<p> 【Xcode】 &gt; 【Open Developer Too】&gt;【 Instruments】</p>
<p> 1.Leaks：检测内存泄漏</p>
<p> 2.zombies ：僵尸对象，指的是对应的内存已经被释放并且不再会使用到，但是你的程序却在某处依然有指向它的引用</p>
</blockquote>
<h4 id="114-iOS中的回调机制"><a href="#114-iOS中的回调机制" class="headerlink" title="114.iOS中的回调机制"></a>114.iOS中的回调机制</h4><blockquote>
<ul>
<li>1.代理：也叫委托，当某个对象收到多个事件，并要求同一个对象来处理所有事件时。委托机制依赖于某个协议定义的方法来发送消息。</li>
<li>2.通知：当需要多个对象或两个无关对象处理同一个事件时使用。</li>
<li>3.Block：适用于回调只发生一次的简单任务。</li>
</ul>
</blockquote>
<h4 id="115-BAD-ACCESS的错误原因"><a href="#115-BAD-ACCESS的错误原因" class="headerlink" title="115.BAD_ACCESS的错误原因"></a>115.BAD_ACCESS的错误原因</h4><blockquote>
<ul>
<li>原因:访问了野指针，比如已经释放的对象的成员变量或者发送消息。</li>
<li>调试：Enaable zombie objects 、设置全局断点</li>
</ul>
</blockquote>
<h4 id="116-解决报错libc-abi-dylib-handler-threw-exception"><a href="#116-解决报错libc-abi-dylib-handler-threw-exception" class="headerlink" title="116.解决报错libc++abi.dylib handler threw exception"></a>116.解决报错libc++abi.dylib handler threw exception</h4><blockquote>
<ul>
<li>遇到这种错误，即使用了All Exceptions，也断点到相应的代码了，但是没打印对应的日志。此时我们可以添加如下的代码来打印异常log:</li>
</ul>
</blockquote>
<pre><code>     @try&#123;  
       //可能出现错误的代码片段
     &#125;  @catch(NSException *exception) &#123;  
          NSLog(@&quot;exception:%@&quot;, exception);  
     &#125;  @finally &#123;     
 
       &#125;
</code></pre>
<h4 id="117-堆和栈的区别"><a href="#117-堆和栈的区别" class="headerlink" title="117.堆和栈的区别"></a>117.堆和栈的区别</h4><blockquote>
<ul>
<li><strong>1.内存管理范围</strong></li>
</ul>
<p> 只有oc对象需要进行内存管理</p>
<p> 非oc对象类型比如基本数据类型不需要进行内存管理</p>
<ul>
<li><strong>2.内存管理本质</strong></li>
</ul>
<p> 因为：Objective-C的对象在内存中是以堆的方式分配空间的,并且堆内存是由你释放的，就是release</p>
<p> OC对象存放于堆里面(堆内存要程序员手动回收)</p>
<p> 非OC对象一般放在栈里面(栈内存会被系统自动回收)</p>
<p> 堆里面的内存是动态分配的，所以也就需要程序员手动的去添加内存、回收内存</p>
<ul>
<li><strong>3.内存分配以及管理方式</strong></li>
</ul>
</blockquote>
<p>  <strong>按分配方式分:</strong></p>
<blockquote>
<p> 堆是动态分配和回收内存的，没有静态分配的堆</p>
<p> 栈有两种分配方式：静态分配和动态分配</p>
<p> 静态分配是系统编译器完成的，比如局部变量的分配</p>
<p> 动态分配是有alloc函数进行分配的，但是栈的动态分配和堆是不同的，它的动态分配也由系统编译器进行释放，不需要程序员手动管理</p>
<p> <strong>按管理方式分:</strong></p>
<p> 对于栈来讲，是由系统编译器自动管理，不需要程序员手动管理</p>
<p> 对于堆来讲，释放工作由程序员手动管理，不及时回收容易产生内存泄露</p>
<p> <strong>堆：</strong>是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。堆里面一般 放的是静态数据，比如static的数据和字符串常量等，资源加载后一般也放在堆里面。一个进程的所有线程共有这些堆 ，所以对堆的操作要考虑同步和互斥的问题。程序里面编译后的数据段都是堆的一部分。</p>
<p> <strong>栈：</strong>是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此 ，栈是　thread safe的。每个c++对象的数据成员也存在在栈中，每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换ss/esp寄存器。栈空间不需要在高级语言里面显式的分配 和释放。</p>
<p> <strong>一句话总结:</strong>  就是 堆：由程序员分配和释放,如果不释放可能会引起内存泄漏 栈：由编译器自动分配和释放，一般存放参数值，局部变量</p>
</blockquote>
<h4 id="118-KVO和KVC"><a href="#118-KVO和KVC" class="headerlink" title="118.KVO和KVC"></a>118.KVO和KVC</h4><blockquote>
<ul>
<li>KVC，即是指 NSKeyValueCoding(键值编码),提供一种机制来间接访问对象的属性。KVC 就是基于KVO技术来实现的。</li>
<li>KVO，提供了一种观察者的机制，通过对某个对象的某个属性添加观察者，当该属性改变，就会调用”observeValueForKeyPath:”方法。</li>
</ul>
</blockquote>
<h4 id="119-OC中创建线程的方法是什么-如果在主线程中执行代码，-方法是什么-如果想延时执行代码、方法是什么"><a href="#119-OC中创建线程的方法是什么-如果在主线程中执行代码，-方法是什么-如果想延时执行代码、方法是什么" class="headerlink" title="119.OC中创建线程的方法是什么?如果在主线程中执行代码， 方法是什么?如果想延时执行代码、方法是什么?"></a>119.OC中创建线程的方法是什么?如果在主线程中执行代码， 方法是什么?如果想延时执行代码、方法是什么?</h4><blockquote>
<ul>
<li>1、线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;</li>
<li>2、在主线程执行代码，方法是performSelectorOnMainThread:withObject:waitUntilDone:;</li>
<li>3、如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:；</li>
</ul>
</blockquote>
<h4 id="120-指针与数组名的关系"><a href="#120-指针与数组名的关系" class="headerlink" title="120.指针与数组名的关系?"></a>120.指针与数组名的关系?</h4><blockquote>
<pre><code> int arrayName[4] = &#123;10, 20, 30, 40&#125;;

 int *p = (int *)(&amp;arrayName + 1);

 NSLog(@&quot;%d&quot;, (&amp;arrayName - 1));
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>1.(&amp;arrayName + 1)：&amp;arrayName是数组的地址（等价于指向arrayName数组的指针）</li>
<li>2.增加 1 会往后移动16个字节，开始是4个字节的位置，移动后就是16个字节后面的位置（也就是目前位置是20个字节）</li>
<li>3.最后又赋值给，int类型的指针p（int类型占4个字节）</li>
<li>4.所以(p - 1)就是减去4个字节，变成为16个字节的位置，输出的(p - 1)值为40</li>
<li>int *p = (int *)(&amp;arrayName + 1);</li>
<li>NSLog(@”%d”, *(p - 1));//输出结果为 40</li>
</ul>
</blockquote>
<h4 id="121-属性readwrite-readonly-assign-retain-copy-nonatomic-什么作用-在哪种情况下"><a href="#121-属性readwrite-readonly-assign-retain-copy-nonatomic-什么作用-在哪种情况下" class="headerlink" title="121.属性readwrite.readonly,assign,retain,copy,nonatomic 什么作用 ? 在哪种情况下 ?"></a>121.属性readwrite.readonly,assign,retain,copy,nonatomic 什么作用 ? 在哪种情况下 ?</h4><blockquote>
<ul>
<li>readwrite 是可读可写特性；需要生成getter方法和setter方法时（补充：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数））</li>
<li>readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变</li>
<li>assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时；</li>
<li>retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;</li>
<li>copy 表示拷贝特性，setter方法将传入对象复制一份；需要完全一份新的变量时。</li>
<li>nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic</li>
</ul>
</blockquote>
<h4 id="122-IBOutlet-连出来的视图属性为什么可以被设置成weak"><a href="#122-IBOutlet-连出来的视图属性为什么可以被设置成weak" class="headerlink" title="122. IBOutlet 连出来的视图属性为什么可以被设置成weak?"></a>122. IBOutlet 连出来的视图属性为什么可以被设置成weak?</h4><blockquote>
<ul>
<li>在 storyboard 中添加一个控件引用关系是这样的(以 UIbutton 为例): UIviewController -&gt; UIview -&gt; UIbutton</li>
<li>此时 UIviewController 强引用着 UIview , UIview 强引用着 UIbutton , IBoutlet 连线到控制器的. m 或者. h 中作为视图的属性时用 weak 修饰就可以了, (觉得用 strong 修饰也可以但是没有必要)</li>
<li>添加到子控件也是强引用: UIbutton 就是添加到了 UIviewController 的 view 上</li>
</ul>
</blockquote>
<h4 id="123-预处指令-define声明一个常数，-以表明一年中有多少秒-忽闰问题-。"><a href="#123-预处指令-define声明一个常数，-以表明一年中有多少秒-忽闰问题-。" class="headerlink" title="123.预处指令#define声明一个常数， 以表明一年中有多少秒(忽闰问题)。"></a>123.预处指令#define声明一个常数， 以表明一年中有多少秒(忽闰问题)。</h4><blockquote>
<ul>
<li>代码如下：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</li>
</ul>
</blockquote>
<h4 id="124-重写-个NSString类型的，retain-式声明name属性的-setter和getter-法-MRC"><a href="#124-重写-个NSString类型的，retain-式声明name属性的-setter和getter-法-MRC" class="headerlink" title="124.重写-个NSString类型的，retain 式声明name属性的 setter和getter 法(MRC)"></a>124.重写-个NSString类型的，retain 式声明name属性的 setter和getter 法(MRC)</h4><blockquote>
<ul>
<li>属性的三大特性:语义特性,原子特性,读写特性.</li>
<li>同时重写setter和getter方法,@synchronized name = _name,关联属性和实例变量</li>
</ul>
</blockquote>
<p> 如： </p>
<pre><code> -(void)setName:(NSString *)name&#123;

 if(_name != name)&#123;

 [_name retain];

 [_name release];

 _name = name;

 &#125;

 &#125;

 -(NSString *)name&#123;

 return [[_name retain]autorelease]

 &#125;
</code></pre>
<h4 id="125-分析json、xml-的区别-json、xml-解析-式的底层是如何让处理的"><a href="#125-分析json、xml-的区别-json、xml-解析-式的底层是如何让处理的" class="headerlink" title="125.分析json、xml 的区别? json、xml 解析 式的底层是如何让处理的"></a>125.分析json、xml 的区别? json、xml 解析 式的底层是如何让处理的</h4><blockquote>
<ul>
<li>(一)JSON与XML的区别：</li>
</ul>
<p>（1）可读性方面：基本相同，XML的可读性比较好；</p>
<p>（2）可扩展性方面：都具有良好的扩展性；</p>
<p>（3）编码难度方面：相对而言，JSON的编码比较容易；</p>
<p>（4）解码难度：JSON的解码难度基本为零，XML需要考虑子节点和父节点；</p>
<p>（5）数据体积方面：JSON相对于XML来讲，数据体积小，传递的速度比较快；</p>
<p>（6）数据交互方面：JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互；</p>
<p>（7）数据描述方面：XML对数据描述性比较好</p>
<p>（8）传输速度方面：JSON的速度远远快于XML。</p>
<ul>
<li>（二）JSON与XML底层实现原理：　（1）JSON底层原理：遍历字符串中的字符，最终根据格式规定的特殊字符，比如{}、[]、：等进行区分，{}号表示字典，[]号表示数组，：号是字典的键和值的分水岭，最终仍是将JSON转化为字典，只不过字典中的值可能是“字典、数组或者字符串而已”。</li>
</ul>
<p>（2）XML底层原理：XML解析常用的解析方法有两种：DOM解析和SAX解析；DOM采用的是树形结构的方式访问XML文档，而SAX采用的是事件模型；DOM解析把XML文档转化为一个包含其内容的树，并可以对树进行遍历，使用DOM解析器的时候需要处理整个XML文档，所以对内存和性能的要求比较高；SAX在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，他可以激活一个回调方法，告诉该方法指定的标签已经找到，SAX对内存的要求通常会比较低，因为他让开发人员自己来决定所要处理的tag，特别是当开发人员只需要处理文档中所包含部分数据时，SAX这种扩展能力得到了更好的体现。</p>
</blockquote>
<h4 id="126-对程序性能的优化你有什么建议"><a href="#126-对程序性能的优化你有什么建议" class="headerlink" title="126.对程序性能的优化你有什么建议?"></a>126.对程序性能的优化你有什么建议?</h4><blockquote>
<ul>
<li>1.使用复用机制</li>
<li>2.尽可能设置 View 为不透明</li>
<li>3.避免臃肿的 XIB 文件</li>
<li>4.不要阻塞主线程</li>
<li>5.图片尺寸匹配 UIImageView</li>
<li>6.选择合适的容器</li>
<li>7.启用 GZIP 数据压缩</li>
<li>8.View 的复用和懒加载机制</li>
<li>9、缓存：</li>
</ul>
<p>服务器的响应信息（response）。</p>
<p>图片。</p>
<p>计算值。比如：UITableView 的 row heights。</p>
<ul>
<li>10.关于图形绘制</li>
<li>11.处理 Memory Warnings</li>
</ul>
<p>在 AppDelegate 中实现-[AppDelegate applicationDidReceiveMemoryWarning:] 代理方法。</p>
<p>在 UIViewController 中重载 didReceiveMemoryWarning 方法。</p>
<p>监听 UIApplicationDidReceiveMemoryWarningNotification 通知。</p>
<ul>
<li>12.复用高开销的对象</li>
<li>13.减少离屏渲染(设置圆角和阴影的时候可以选用绘制的方法)</li>
<li>14.优化 UITableView</li>
</ul>
<p> 通过正确的设置 reuseIdentifier 来重用 Cell。</p>
<p>尽量减少不必要的透明 View。</p>
<p>尽量避免渐变效果、图片拉伸和离屏渲染。</p>
<p>当不同的行的高度不一样时，尽量缓存它们的高度值。</p>
<p>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。</p>
<p>使用 shadowPath 来设置阴影效果。</p>
<p>尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。</p>
<p>尽量优化 - [UITableView tableView:cellForRowAtIndexPath:] 方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。</p>
<p>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。</p>
<p>对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。</p>
<ul>
<li>15.选择合适的数据存储方式</li>
</ul>
<p>在 iOS 中可以用来进行数据持有化的方案包括：</p>
<p>NSUserDefaults。只适合用来存小数据。</p>
<p>XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。</p>
<p>使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。</p>
<p>使用 SQLite 数据库。可以配合 FMDB 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。</p>
<p>使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。</p>
<ul>
<li>16.减少应用启动时间</li>
</ul>
<p>快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。</p>
<p>——保证应用快速启动的指导原则——：</p>
<p>尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。</p>
<p>避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。</p>
<p>注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。</p>
<ul>
<li>17.使用 Autorelease Pool （内存释放池）</li>
<li>18.imageNamed 和 imageWithContentsOfFile</li>
</ul>
</blockquote>
<h4 id="127-runloop-和线程有什么关系"><a href="#127-runloop-和线程有什么关系" class="headerlink" title="127.runloop 和线程有什么关系?"></a>127.runloop 和线程有什么关系?</h4><blockquote>
<ul>
<li>runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。</li>
<li>runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。</li>
<li>runloop在第一次获取时被创建，在线程结束时被销毁。</li>
<li>对于主线程来说，runloop在程序一启动就默认创建好了。</li>
<li>对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调。</li>
</ul>
</blockquote>
<h4 id="128-介绍下layoutSubview和drawRect"><a href="#128-介绍下layoutSubview和drawRect" class="headerlink" title="128.介绍下layoutSubview和drawRect"></a>128.介绍下layoutSubview和drawRect</h4><blockquote>
<p><strong>layoutSubviews调用情况：</strong></p>
</blockquote>
<blockquote>
<ul>
<li><p>init初始化UIView不会触发调用</p>
</li>
<li><p>addSubview会触发调用</p>
</li>
<li><p>改变view的width和height的时候会触发调用</p>
</li>
<li><p>一个UIScrollView滚动会触发调用</p>
</li>
<li><p>旋转screen会触发调用</p>
</li>
<li><p>改变一个UIView大小的时候会触发superView的layoutSubviews事件</p>
</li>
<li><p>直接调用setLayoutSubviews会触发调用</p>
</li>
<li><p>-(void)viewWillAppear:(BOOL)animated会触发一次调用</p>
</li>
<li><p>-(void)viewDidAppear:(BOOL)animated 看情况，可能有调用</p>
</li>
<li><p><em>drawRect调用情况：</em>*</p>
</li>
<li><p>如果UIView没有设置frame大小，直接导致drawRect不能被自动调用。</p>
</li>
<li><p>drawRect在loadView和viewDidLoad这两个方法之后调用</p>
</li>
<li><p>调用sizeToFit后自动调用drawRect</p>
</li>
<li><p>通过设置contentMode值为UIViewContentModeRedraw。那么每次设置或者更改frame自动调用drawRect。</p>
</li>
<li><p>直接调用setNeedsDisplay或者setNeedsDisplayInRect会触发调用</p>
</li>
</ul>
</blockquote>
<h4 id="129-写个“标准“宏MIN，这个宏输两个参数并返回较小的那个"><a href="#129-写个“标准“宏MIN，这个宏输两个参数并返回较小的那个" class="headerlink" title="129.写个“标准“宏MIN，这个宏输两个参数并返回较小的那个"></a>129.写个“标准“宏MIN，这个宏输两个参数并返回较小的那个</h4><blockquote>
<ul>
<li>MIN(A,B) ((A) &lt;= (B) ? (A) : (B))</li>
</ul>
</blockquote>
<h4 id="130-类别有什么作用"><a href="#130-类别有什么作用" class="headerlink" title="130.类别有什么作用"></a>130.类别有什么作用</h4><blockquote>
<ul>
<li>1.扩展已有的类（添加方法）</li>
<li>2.可以通过runtime添加属性</li>
</ul>
</blockquote>
<h4 id="131-什么是method-swizzing-讲-讲你的使-场景以及使-时的注意事项"><a href="#131-什么是method-swizzing-讲-讲你的使-场景以及使-时的注意事项" class="headerlink" title="131.什么是method swizzing?讲 讲你的使 场景以及使 时的注意事项"></a>131.什么是method swizzing?讲 讲你的使 场景以及使 时的注意事项</h4><blockquote>
<ul>
<li>1.给扩展添加属性</li>
<li>2.替换系统方法的的实现</li>
</ul>
</blockquote>
<h4 id="132-讲讲iOS事件响应链的原理"><a href="#132-讲讲iOS事件响应链的原理" class="headerlink" title="132.讲讲iOS事件响应链的原理"></a>132.讲讲iOS事件响应链的原理</h4><blockquote>
<ul>
<li>1、响应者链通常是由视图（UIView）构成的；</li>
<li>2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</li>
<li>3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</li>
<li>4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者</li>
<li>需要指出的是，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点；</li>
<li>5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</li>
</ul>
</blockquote>
<h4 id="133-你在什么场景下会选择使-Category"><a href="#133-你在什么场景下会选择使-Category" class="headerlink" title="133.你在什么场景下会选择使 Category"></a>133.你在什么场景下会选择使 Category</h4><blockquote>
<ul>
<li>1.扩展已有的类（添加方法）</li>
</ul>
</blockquote>
<h4 id="134-UIview-和CAlayer-是什么关系-你使用-CLayer做过什么"><a href="#134-UIview-和CAlayer-是什么关系-你使用-CLayer做过什么" class="headerlink" title="134.UIview 和CAlayer 是什么关系? 你使用 CLayer做过什么?"></a>134.UIview 和CAlayer 是什么关系? 你使用 CLayer做过什么?</h4><blockquote>
<ul>
<li>首先UIView可以响应事件，Layer不可以.</li>
<li>UIView是CALayer的delegate </li>
<li>UIView主要处理事件，CALayer负责绘制就更好 </li>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</li>
<li>用CAlayer： 创建隐式动画 绘制边框圆角</li>
</ul>
</blockquote>
<h4 id="135-如何处理UITableVier-中Cell-动态计算高度的问题，都有哪些方案"><a href="#135-如何处理UITableVier-中Cell-动态计算高度的问题，都有哪些方案" class="headerlink" title="135.如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案?"></a>135.如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案?</h4><blockquote>
<ul>
<li>—–第一种方案：——</li>
<li>1、你的Cell要使用AutoLayout来布局约束这是必须的；</li>
<li>2、设置tableview的estimatedRowHeight为一个非零值，这个属性是设置一个预估的高度值，不用太精确。</li>
<li>3、设置tableview的rowHeight属性为UITableViewAutomaticDimension</li>
<li>—–第二种方案：—–</li>
<li>1、第三方 UITableView+FDTemplateLayoutCell</li>
</ul>
</blockquote>
<h4 id="136-AutoLayout-中的优先级是什么-UIScrollView-中使用Autolayout-会出现什么问题"><a href="#136-AutoLayout-中的优先级是什么-UIScrollView-中使用Autolayout-会出现什么问题" class="headerlink" title="136.AutoLayout 中的优先级是什么? UIScrollView 中使用Autolayout 会出现什么问题?"></a>136.AutoLayout 中的优先级是什么? UIScrollView 中使用Autolayout 会出现什么问题?</h4><blockquote>
<ul>
<li>代码计算frame -&gt; autoreszing(父控件和子控件的关系) -&gt; autolayout(任何控件都可以产生关系) -&gt; sizeclass</li>
<li>可以设置两个看似有冲突的约束，但设置不同的优先级之后就不会有冲突了，当其中一个约束失效之后，另一个优先级比较低的约束就会起作用</li>
</ul>
</blockquote>
<h4 id="137-NSIRLConnection-和NSLRLSession-的区别是-么-NSURLProtocol是做什么的"><a href="#137-NSIRLConnection-和NSLRLSession-的区别是-么-NSURLProtocol是做什么的" class="headerlink" title="137.NSIRLConnection 和NSLRLSession 的区别是 么? NSURLProtocol是做什么的?"></a>137.NSIRLConnection 和NSLRLSession 的区别是 么? NSURLProtocol是做什么的?</h4><p><strong>1.下载</strong></p>
<ul>
<li>NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。</li>
<li>而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码</li>
</ul>
<p><strong>2.请求方法的控制</strong></p>
<ul>
<li>NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</li>
<li>NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。</li>
<li>使用NSURLSession进行断点下载更加便捷.</li>
<li>NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进</li>
</ul>
<h4 id="138-怎么高效的实现控件的圆角效果"><a href="#138-怎么高效的实现控件的圆角效果" class="headerlink" title="138.怎么高效的实现控件的圆角效果"></a>138.怎么高效的实现控件的圆角效果</h4><blockquote>
<ul>
<li>绘制圆角</li>
</ul>
</blockquote>
<pre><code>     -(UIImageView *)roundedRectImageViewWithCornerRadius:(CGFloat)cornerRadius &#123;

     UIBezierPath *bezierPath = [UIBezierPath 

     bezierPathWithRoundedRect:self.bounds cornerRadius:cornerRadius];

    CAShapeLayer *layer = [CAShapeLayer layer];

     layer.path = bezierPath.CGPath;

     self.layer.mask = layer;

     return self;

     &#125;
</code></pre>
<h4 id="139-说说你了解weak属性"><a href="#139-说说你了解weak属性" class="headerlink" title="139.说说你了解weak属性?"></a>139.说说你了解weak属性?</h4><blockquote>
<ul>
<li>weak关键字在OC中属于比较基础的知识此特性表明该属性定义了一种关系“非拥有关系”（nonowning relationship）。为这种属性设置新值得时，设置方法既不保留新值，也不释放旧值。此特性同assign类似，然后在属性所指的对象遭到摧毁时，属性值也会清空（nil out）。</li>
<li>弱引用，不决定对象的存亡。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。</li>
</ul>
</blockquote>
<h4 id="140-假如Controller太臃肿，如何优化"><a href="#140-假如Controller太臃肿，如何优化" class="headerlink" title="140.假如Controller太臃肿，如何优化?"></a>140.假如Controller太臃肿，如何优化?</h4><p>  <strong>1.将网络请求抽象到单独的类中</strong></p>
<blockquote>
<ul>
<li>方便在基类中处理公共逻辑；</li>
<li>方便在基类中处理缓存逻辑，以及其它一些公共逻辑；</li>
<li>方便做对象的持久化。<strong>2.将界面的封装抽象到专门的类中</strong></li>
<li>构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。<strong>3.构造 ViewModel</strong></li>
<li>借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。</li>
</ul>
</blockquote>
<p>  <strong>4.专门构造存储类</strong></p>
<blockquote>
<ul>
<li><p>专门来处理本地数据的存取。</p>
</li>
<li><p><em>5.整合常量</em>*</p>
</li>
</ul>
</blockquote>
<h4 id="141-项目中网络层如何做安全处理"><a href="#141-项目中网络层如何做安全处理" class="headerlink" title="141.项目中网络层如何做安全处理?"></a>141.项目中网络层如何做安全处理?</h4><blockquote>
<ul>
<li>1.判断API的调用请求是否来自于经过授权的APP。如若不是则拒绝请求访问</li>
<li>2.在数据请求的过程中进行URL加密处理：防止反编译，接口信息被静态分析。</li>
<li>3.数据传输加密：对客户端传输数据提供有效的加密方案，以防止网络接口的拦截。</li>
<li>如果可以尽量使用HTTPS，可以有效的避免接口数据在传输中被攻击。</li>
</ul>
</blockquote>
<h4 id="142-main-之前的过程有哪些"><a href="#142-main-之前的过程有哪些" class="headerlink" title="142.main()之前的过程有哪些?"></a>142.main()之前的过程有哪些?</h4><blockquote>
<ul>
<li>在iOS中 main.m 是我们所熟悉的程序入口。但是在在此之前其实程序以及做了很多事了。如系统会获取dyld的路径，并加载。加载程序中的依赖库。调用所有的+ load方法，并返回main函数地址。</li>
</ul>
</blockquote>
<h4 id="143-设计模式是什么？-你知道哪些设计模式，并简要叙述？"><a href="#143-设计模式是什么？-你知道哪些设计模式，并简要叙述？" class="headerlink" title="143.设计模式是什么？ 你知道哪些设计模式，并简要叙述？"></a>143.设计模式是什么？ 你知道哪些设计模式，并简要叙述？</h4><blockquote>
<p> 设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。</p>
<ul>
<li> MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。</li>
<li> MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。</li>
<li> 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</li>
<li> 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。</li>
<li> 委托模式：代理+协议的组合。实现1对1的反向传值操作。</li>
<li> 工厂模式：通过一个类方法，批量的根据已有模板生产对象。</li>
</ul>
</blockquote>
<h4 id="144-MVC-和-MVVM-的区别"><a href="#144-MVC-和-MVVM-的区别" class="headerlink" title="144.MVC 和 MVVM 的区别"></a>144.MVC 和 MVVM 的区别</h4><blockquote>
<ul>
<li> MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</li>
<li> MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</li>
</ul>
</blockquote>
<h4 id="145-Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"><a href="#145-Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？" class="headerlink" title="145.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"></a>145.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</h4><blockquote>
<ul>
<li>Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</li>
</ul>
</blockquote>
<h4 id="146。-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#146。-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="146。@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>146。@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h4><blockquote>
<ul>
<li>@property 的本质是什么？</li>
<li>@property = ivar + getter + setter;</li>
<li>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</li>
<li>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</li>
</ul>
</blockquote>
<h4 id="147-property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#147-property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="147.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？"></a>147.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h4><blockquote>
<p>属性可以拥有的特质分为四类:</p>
<ul>
<li>1.原子性：nonatomic、atomic特质</li>
<li>2.读/写权限：readwrite(读写)、readonly (只读)</li>
<li>3.内存管理语义：assign、strong、 weak、unsafe_unretained、copy</li>
<li>4.方法名：getter=<name> 、setter=<name></li>
<li>5.不常用的：nonnull,null_resettable,nullable</li>
</ul>
</blockquote>
<h4 id="148-什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#148-什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="148.什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>148.什么情况使用 weak 关键字，相比 assign 有什么不同？</h4><blockquote>
<ul>
<li>1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</li>
<li>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</li>
<li>3.IBOutlet连出来的视图属性为什么可以被设置成weak?</li>
</ul>
<p> 因为父控件的subViews数组已经对它有一个强引用。</p>
<ul>
<li>4.不同点：</li>
</ul>
<p> assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。</p>
<p> weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。</p>
</blockquote>
<h4 id="149-怎么用-copy-关键字？"><a href="#149-怎么用-copy-关键字？" class="headerlink" title="149.怎么用 copy 关键字？"></a>149.怎么用 copy 关键字？</h4><blockquote>
<ul>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</li>
<li>block 也经常使用 copy 关键字。</li>
<li>说明：<br>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</li>
</ul>
</blockquote>
<h4 id="150-用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#150-用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="150.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>150.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4><blockquote>
<ul>
<li>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</li>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</li>
<li>总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</li>
</ul>
</blockquote>
<h4 id="151-系统对象的-copy-与-mutableCopy-方法"><a href="#151-系统对象的-copy-与-mutableCopy-方法" class="headerlink" title="151.系统对象的 copy 与 mutableCopy 方法"></a>151.系统对象的 copy 与 mutableCopy 方法</h4><p><em>不管是集合类对象（NSArray、NSDictionary、NSSet … 之类的对象），还是非集合类对象（NSString, NSNumber … 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：</em></p>
<blockquote>
<ul>
<li>copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。</li>
<li>mutableCopy 返回的是可变对象（mutableObject）。</li>
</ul>
</blockquote>
<p>  <strong>一、非集合类对象的copy与mutableCopy</strong></p>
<blockquote>
<ul>
<li>在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</li>
<li>对可变对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</li>
</ul>
</blockquote>
<pre><code>      NSString *str = @&quot;hello word!&quot;;

      NSString *strCopy = [str copy] // 指针复制，strCopy与str的地址一样

      NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy与str的地址不一样
</code></pre>
<p>–</p>
<pre><code>     NSMutableString *mutableStr = [NSMutableString stringWithString: @&quot;hello word!&quot;];

     NSString *strCopy = [mutableStr copy] // 内容复制

     NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制
</code></pre>
<blockquote>
</blockquote>
<p> <strong>二、集合类对象的copy与mutableCopy (同上)</strong></p>
<blockquote>
<ul>
<li>在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</li>
<li>对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)</li>
</ul>
</blockquote>
<blockquote>
<pre><code>    NSArray *arr = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];

    NSArray *copyArr = [arr copy]; // 指针复制

    NSMutableArray *mCopyArr = [arr mutableCopy]; //单层内容复制

    NSMutableArray *array = [NSMutableArray arrayWithObjects:

    [NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];

    NSArray *copyArr = [mutableArr copy]; // 单层内容复制
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>【总结一句话】：</li>
<li>只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！</li>
</ul>
</blockquote>
<h4 id="152-这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-arr"><a href="#152-这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-arr" class="headerlink" title="152.这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;"></a>152.这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;</h4><blockquote>
<ul>
<li>问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。</li>
</ul>
</blockquote>
<pre><code>     //如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460

     // cop    y后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）
</code></pre>
<blockquote>
<ul>
<li>原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。</li>
</ul>
</blockquote>
<h4 id="153-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#153-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="153.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>153.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h4><blockquote>
<ul>
<li>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</li>
<li>具体步骤：</li>
</ul>
</blockquote>
<blockquote>
<p>需声明该类遵从 NSCopying 协议</p>
<p>实现 NSCopying 协议的方法。</p>
<pre><code>// 该协议只有一个方法: - (id)copyWithZone:(NSZone *)zone;

// 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。
</code></pre>
</blockquote>
<h4 id="154-写一个-setter-方法用于完成-property-nonatomic-retain-NSString-name，写一个-setter-方法用于完成-property-nonatomic-copy-NSString-name"><a href="#154-写一个-setter-方法用于完成-property-nonatomic-retain-NSString-name，写一个-setter-方法用于完成-property-nonatomic-copy-NSString-name" class="headerlink" title="154.写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name"></a>154.写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name</h4><pre><code>  // retain
 
 -(void)setName:(NSArray *)name
 
 &#123;
 
     if (_name !=name) &#123;
         [_name release];
         _name =[name retain];
         
     &#125;
     
 &#125;

 // copy
 
 -(void)setName:(NSString *)name
 
 &#123;
 
     if (_name !=name) &#123;
        [_name release];
         _name = [name copy];
     &#125;
     
 &#125;
</code></pre>
<h4 id="155-synthesize-和-dynamic-分别有什么作用？"><a href="#155-synthesize-和-dynamic-分别有什么作用？" class="headerlink" title="155.@synthesize 和 @dynamic 分别有什么作用？"></a>155.@synthesize 和 @dynamic 分别有什么作用？</h4><blockquote>
<ul>
<li>@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。</li>
<li>如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;</li>
<li>// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</li>
<li>@synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。</li>
</ul>
</blockquote>
<h4 id="156-常见的-Objective-C-的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int"><a href="#156-常见的-Objective-C-的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int" class="headerlink" title="156.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int"></a>156.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</h4><blockquote>
<ul>
<li>Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象；</li>
<li>而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;</li>
<li>NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。</li>
</ul>
</blockquote>
<h4 id="157-id-声明的对象有什么特性？"><a href="#157-id-声明的对象有什么特性？" class="headerlink" title="157.id 声明的对象有什么特性？"></a>157.id 声明的对象有什么特性？</h4><blockquote>
<ul>
<li>id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。</li>
</ul>
</blockquote>
<h4 id="158-Objective-C-如何对内存管理的，说说你的看法和解决方法？"><a href="#158-Objective-C-如何对内存管理的，说说你的看法和解决方法？" class="headerlink" title="158.Objective-C 如何对内存管理的，说说你的看法和解决方法？"></a>158.Objective-C 如何对内存管理的，说说你的看法和解决方法？</h4><blockquote>
<p><em>Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</em></p>
<ul>
<li>(Garbage Collection)自动内存计数：这种方式和java类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以iPhone不支持这个功能。所以“Garbage Collection”不是本入门指南的范围，对“Garbage Collection”内部机制感兴趣的同学可以参考一些其他的资料，不过说老实话“Garbage Collection”不大适合适初学者研究。</li>
</ul>
<p>解决: 通过alloc – initial方式创建的, 创建后引用计数+1, 此后每retain一次引用计数+1, 那么在程序中做相应次数的release就好了.</p>
<ul>
<li> (Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为0的时候，那么就是释放这段内存的时候。比如说，当在程序A里面一段内存被成功申请完成之后，那么这个计数器就从0变成1(我们把这个过程叫做alloc)，然后程序B也需要使用这个内存，那么计数器就从1变成了2(我们把这个过程叫做retain)。紧接着程序A不再需要这段内存了，那么程序A就把这个计数器减1(我们把这个过程叫做release);程序B也不再需要这段内存的时候，那么也把计数器减1(这个过程还是release)。当系统(也就是Foundation)发现这个计数器变 成员了0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做dealloc)。顺便提一句，如果没有Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。</li>
</ul>
<p>解决:一般是由类的静态方法创建的, 函数名中不会出现alloc或init字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的局部变量. 当然也可以通过retain延长对象的生存期.</p>
<ul>
<li> (NSAutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.</li>
</ul>
<p>解决:是由autorelease加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像main函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</p>
</blockquote>
<h4 id="159-Category（类别）、-Extension（扩展）和继承的区别"><a href="#159-Category（类别）、-Extension（扩展）和继承的区别" class="headerlink" title="159.Category（类别）、 Extension（扩展）和继承的区别"></a>159.Category（类别）、 Extension（扩展）和继承的区别</h4><blockquote>
<ul>
<li>分类有名字，类扩展没有分类名字，是一种特殊的分类。</li>
<li>分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</li>
<li>继承可以增加，修改或者删除方法，并且可以增加属性。</li>
</ul>
</blockquote>
<h4 id="160-我们说的OC是动态运行时语言是什么意思？"><a href="#160-我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="160.我们说的OC是动态运行时语言是什么意思？"></a>160.我们说的OC是动态运行时语言是什么意思？</h4><blockquote>
<ul>
<li>主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</li>
</ul>
</blockquote>
<h4 id="161-为什么我们常见的delegate属性都用是weak而不是retain-strong？"><a href="#161-为什么我们常见的delegate属性都用是weak而不是retain-strong？" class="headerlink" title="161.为什么我们常见的delegate属性都用是weak而不是retain/strong？"></a>161.为什么我们常见的delegate属性都用是weak而不是retain/strong？</h4><blockquote>
<ul>
<li>是为了防止delegate两端产生不必要的循环引用。</li>
<li>@property (nonatomic, weak) id<UITableViewDelegate> delegate;</li>
</ul>
</blockquote>
<h4 id="162-什么时候用delete，什么时候用Notification？"><a href="#162-什么时候用delete，什么时候用Notification？" class="headerlink" title="162.什么时候用delete，什么时候用Notification？"></a>162.什么时候用delete，什么时候用Notification？</h4><blockquote>
<ul>
<li>Delegate(委托模式)：1对1的反向消息通知功能。</li>
<li>Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</li>
</ul>
</blockquote>
<h4 id="163-什么是-KVO-和-KVC？"><a href="#163-什么是-KVO-和-KVC？" class="headerlink" title="163.什么是 KVO 和 KVC？"></a>163.什么是 KVO 和 KVC？</h4><blockquote>
<ul>
<li> KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）</li>
</ul>
<p>举例说明：</p>
<pre><code>stu.name = @&quot;张三&quot; // 点语法给属性赋值

[stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;]; // 通过字符串使用KVC方式给属性赋值

stu1.nameLabel.text = @&quot;张三&quot;;

[stu1 setValue:@&quot;张三&quot; forKey:@&quot;nameLabel.text&quot;]; // 跨层赋值
</code></pre>
<ul>
<li> KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。</li>
</ul>
<p>KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</p>
<pre><code> // 通过下方方法为属性添加KVO观察

 -(void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 

 options:(NSKeyValueObservingOptions)options context:(nullable void 

 *)context;

 // 当被观察的属性发送变化时，会自动触发下方方法

 -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object

  change:(NSDictionary *)change context:(void *)context&#123;&#125;

  // KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。
</code></pre>
</blockquote>
<h4 id="164-KVC的底层实现？"><a href="#164-KVC的底层实现？" class="headerlink" title="164.KVC的底层实现？"></a>164.KVC的底层实现？</h4><blockquote>
<p><em>当一个对象调用setValue方法时，方法内部会做以下操作：</em></p>
<ul>
<li> 检查是否存在相应的key的set方法，如果存在，就调用set方法。</li>
<li> 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。</li>
<li> 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</li>
<li> 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</li>
</ul>
</blockquote>
<h4 id="165-KVO的底层实现？"><a href="#165-KVO的底层实现？" class="headerlink" title="165.KVO的底层实现？"></a>165.KVO的底层实现？</h4><blockquote>
<ul>
<li>KVO基于runtime机制实现。</li>
</ul>
</blockquote>
<h4 id="166-ViewController生命周期"><a href="#166-ViewController生命周期" class="headerlink" title="166. ViewController生命周期"></a>166. ViewController生命周期</h4><blockquote>
<p><em>按照执行顺序排列：</em></p>
<ul>
<li>1.initWithCoder：通过nib文件初始化时触发。</li>
<li>2.awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。</li>
<li>3.loadView：开始加载视图控制器自带的view。</li>
<li>4.viewDidLoad：视图控制器的view被加载完成。</li>
<li>5.viewWillAppear：视图控制器的view将要显示在window上。</li>
<li>6.updateViewConstraints：视图控制器的view开始更新AutoLayout约束。</li>
<li>7.viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。</li>
<li>8.viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。</li>
<li>9.viewDidAppear：视图控制器的view已经展示到window上。</li>
<li>10.viewWillDisappear：视图控制器的view将要从window上消失。</li>
<li>11.viewDidDisappear：视图控制器的view已经从window上消失。</li>
</ul>
</blockquote>
<h4 id="167-你是否接触过OC中的反射机制？简单聊一下概念和使用"><a href="#167-你是否接触过OC中的反射机制？简单聊一下概念和使用" class="headerlink" title="167.你是否接触过OC中的反射机制？简单聊一下概念和使用"></a>167.你是否接触过OC中的反射机制？简单聊一下概念和使用</h4><blockquote>
<ul>
<li> class反射</li>
</ul>
<p>通过类名的字符串形式实例化对象。</p>
<pre><code>Class class = NSClassFromString(@&quot;student&quot;);

Student *stu = [[class alloc] init];
</code></pre>
<p>将类名变为字符串。</p>
<pre><code>Class class =[Student class];

NSString className = NSStringFromClass(class);
</code></pre>
<ul>
<li> SEL的反射</li>
</ul>
<p>通过方法的字符串形式实例化方法。</p>
<pre><code>SEL selector = NSSelectorFromString(@&quot;setName&quot;);

[stu performSelector:selector withObject:@&quot;Mike&quot;];
</code></pre>
<p>将方法变成字符串。</p>
<pre><code>NSStringFromSelector(@selector(setName:));
</code></pre>
</blockquote>
<h4 id="168-调用方法有两种方式："><a href="#168-调用方法有两种方式：" class="headerlink" title="168.调用方法有两种方式："></a>168.调用方法有两种方式：</h4><blockquote>
<ul>
<li> 直接通过方法名来调用。[person show];</li>
<li> 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];</li>
</ul>
</blockquote>
<h4 id="169-如何对iOS设备进行性能测试？"><a href="#169-如何对iOS设备进行性能测试？" class="headerlink" title="169.如何对iOS设备进行性能测试？"></a>169.如何对iOS设备进行性能测试？</h4><blockquote>
<ul>
<li>Profile-&gt; Instruments -&gt;Time Profiler</li>
</ul>
</blockquote>
<h4 id="170-开发项目时你是怎么检查内存泄露？"><a href="#170-开发项目时你是怎么检查内存泄露？" class="headerlink" title="170.开发项目时你是怎么检查内存泄露？"></a>170.开发项目时你是怎么检查内存泄露？</h4><blockquote>
<ul>
<li> 静态分析 analyze。</li>
<li> instruments工具里面有个leak可以动态分析。</li>
</ul>
</blockquote>
<h4 id="171-什么是懒加载？"><a href="#171-什么是懒加载？" class="headerlink" title="171.什么是懒加载？"></a>171.什么是懒加载？</h4><blockquote>
<ul>
<li>懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</li>
<li>我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。</li>
</ul>
</blockquote>
<h4 id="172-类变量的-public，-protected，-private，-package-声明各有什么含义？"><a href="#172-类变量的-public，-protected，-private，-package-声明各有什么含义？" class="headerlink" title="172.类变量的 @public，@protected，@private，@package 声明各有什么含义？"></a>172.类变量的 @public，@protected，@private，@package 声明各有什么含义？</h4><blockquote>
<ul>
<li>@public 任何地方都能访问;</li>
<li>@protected 该类和子类中访问,是默认的;</li>
<li>@private 只能在本类中访问;</li>
<li>@package 本包内使用,跨包不可以。</li>
</ul>
</blockquote>
<h4 id="173-什么是谓词？"><a href="#173-什么是谓词？" class="headerlink" title="173.什么是谓词？"></a>173.什么是谓词？</h4><blockquote>
<ul>
<li>谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。</li>
</ul>
<p> //定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)</p>
<pre><code> NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&lt;%d&quot;,30];
</code></pre>
<p> //使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</p>
<pre><code> NSArray *array = [persons filteredArrayUsingPredicate:predicate];
</code></pre>
</blockquote>
<h4 id="174-isa指针问题"><a href="#174-isa指针问题" class="headerlink" title="174.isa指针问题"></a>174.isa指针问题</h4><blockquote>
<ul>
<li>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。</li>
</ul>
</blockquote>
<h4 id="175-如何访问并修改一个类的私有属性？"><a href="#175-如何访问并修改一个类的私有属性？" class="headerlink" title="175.如何访问并修改一个类的私有属性？"></a>175.如何访问并修改一个类的私有属性？</h4><blockquote>
<ul>
<li> 一种是通过KVC获取。</li>
<li> 通过runtime访问并修改私有属性。</li>
</ul>
</blockquote>
<h4 id="176-一个objc对象的isa的指针指向什么？有什么作用？"><a href="#176-一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="176.一个objc对象的isa的指针指向什么？有什么作用？"></a>176.一个objc对象的isa的指针指向什么？有什么作用？</h4><blockquote>
<ul>
<li>指向他的类对象,从而可以找到对象上的方法。</li>
</ul>
</blockquote>
<h4 id="177-下面的代码输出什么？"><a href="#177-下面的代码输出什么？" class="headerlink" title="177.下面的代码输出什么？"></a>177.下面的代码输出什么？</h4><pre><code> @implementation Son : Father

 - (id)init &#123;
    if (self = [super init]) &#123;
        NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son
        NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son
    &#125;
    return self;
 &#125;
 @end
 
</code></pre>
<blockquote>
<pre><code>// 解析：

self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。
</code></pre>
</blockquote>
<h4 id="178-写一个完整的代理，包括声明、实现"><a href="#178-写一个完整的代理，包括声明、实现" class="headerlink" title="178.写一个完整的代理，包括声明、实现"></a>178.写一个完整的代理，包括声明、实现</h4><pre><code>  // 创建

 @protocol MyDelagate
 
 @required
 
 -(void)eat:(NSString *)foodName; 
 
 @optional
 
 -(void)run;
 
 @end

 //  声明 .h
 
 @interface person: NSObject&lt;MyDelagate&gt;

 @end

  //  实现 .m
 
     @implementation person
 
     -(void)eat:(NSString *)foodName &#123; 
   
     NSLog(@&quot;吃:%@!&quot;, foodName);
    
     &#125; 
 
      -(void)run &#123;
 
      NSLog(@&quot;run!&quot;);
    
     &#125;

 @end
</code></pre>
<h4 id="179-isKindOfClass、isMemberOfClass、selector作用分别是什么"><a href="#179-isKindOfClass、isMemberOfClass、selector作用分别是什么" class="headerlink" title="179.isKindOfClass、isMemberOfClass、selector作用分别是什么"></a>179.isKindOfClass、isMemberOfClass、selector作用分别是什么</h4><blockquote>
<ul>
<li>isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。</li>
<li>isMemberOfClass：某个对象确切属于某个类型。</li>
<li>selector：通过方法名，获取在内存中的函数的入口地址。</li>
</ul>
</blockquote>
<h4 id="180-delegate-和-notification-的区别"><a href="#180-delegate-和-notification-的区别" class="headerlink" title="180.delegate 和 notification 的区别"></a>180.delegate 和 notification 的区别</h4><blockquote>
<ul>
<li> 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。</li>
<li> notification通过维护一个array，实现一对多消息的转发。</li>
<li> delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</li>
</ul>
</blockquote>
<h4 id="181-什么是block？"><a href="#181-什么是block？" class="headerlink" title="181.什么是block？"></a>181.什么是block？</h4><blockquote>
<ul>
<li> 闭包（block）：闭包就是获取其它函数局部变量的匿名函数。</li>
</ul>
</blockquote>
<h4 id="182-block反向传值"><a href="#182-block反向传值" class="headerlink" title="182.block反向传值"></a>182.block反向传值</h4><p>在控制器间传值可以使用代理或者block，使用block相对来说简洁。</p>
<pre><code>在前一个控制器的touchesBegan:方法内实现如下代码。

  // OneViewController.m
  TwoViewController *twoVC = [[TwoViewController alloc] init];
  twoVC.valueBlcok = ^(NSString *str) &#123;
    NSLog(@&quot;OneViewController拿到值：%@&quot;, str); 
  &#125;;
  [self presentViewController:twoVC animated:YES completion:nil];

  // TwoViewController.h   （在.h文件中声明一个block属性）
  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);

  // TwoViewController.m   （在.m文件中实现方法）
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event          &#123;
    // 传值:调用block
    if (_valueBlcok) &#123;
        _valueBlcok(@&quot;123456&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="183-block的注意点"><a href="#183-block的注意点" class="headerlink" title="183.block的注意点"></a>183.block的注意点</h4><p>在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：</p>
<pre><code>    __weak typeof(self) weakSelf = self; 
    
</code></pre>
<p>在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在<br>block内部再将弱指针重新强引用一下。</p>
<pre><code>    __strong typeof(self) strongSelf = weakSelf;
</code></pre>
<p> 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。</p>
<h4 id="184-lldb（gdb）常用的控制台调试命令？"><a href="#184-lldb（gdb）常用的控制台调试命令？" class="headerlink" title="184.lldb（gdb）常用的控制台调试命令？"></a>184.lldb（gdb）常用的控制台调试命令？</h4><blockquote>
<ul>
<li>p 输出基本类型。是打印命令，需要指定类型。是print的简写<br> p (int)[[[self view] subviews] count]</li>
<li>po 打印对象，会调用对象description方法。是print-object的简写<br>po [self view]</li>
<li> expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。</li>
<li> bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈</li>
<li> br l：是breakpoint list的简写</li>
</ul>
</blockquote>
<h4 id="185-你一般是怎么用Instruments的？"><a href="#185-你一般是怎么用Instruments的？" class="headerlink" title="185.你一般是怎么用Instruments的？"></a>185.你一般是怎么用Instruments的？</h4><p> <em>Instruments里面工具很多，常用：</em></p>
<blockquote>
<ul>
<li>Time Profiler: 性能分析</li>
<li>Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。</li>
<li>Allocations：用来检查内存，写算法的那批人也用这个来检查。</li>
<li>Leaks：检查内存，看是否有内存泄露。</li>
</ul>
</blockquote>
<h4 id="186-iOS的沙盒目录结构是怎样的？"><a href="#186-iOS的沙盒目录结构是怎样的？" class="headerlink" title="186.iOS的沙盒目录结构是怎样的？"></a>186.iOS的沙盒目录结构是怎样的？</h4><p> <em>沙盒结构：</em></p>
<blockquote>
<ul>
<li>Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</li>
<li>Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）</li>
<li>Library：<pre><code>   Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
   Preference：设置目录，iCloud会备份设置信息。
</code></pre>
</li>
<li>tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</li>
</ul>
</blockquote>
<h4 id="187-iOS多线程技术有哪几种方式？"><a href="#187-iOS多线程技术有哪几种方式？" class="headerlink" title="187.iOS多线程技术有哪几种方式？"></a>187.iOS多线程技术有哪几种方式？</h4><blockquote>
<ul>
<li>pthread、NSThread、GCD、NSOperation</li>
</ul>
</blockquote>
<h4 id="188-GCD-与-NSOperation-的区别："><a href="#188-GCD-与-NSOperation-的区别：" class="headerlink" title="188.GCD 与 NSOperation 的区别："></a>188.GCD 与 NSOperation 的区别：</h4><blockquote>
<ul>
<li>GCD 和 NSOperation 都是用于实现多线程：</li>
<li><pre><code>GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。
</code></pre>
</li>
<li><pre><code>NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。
</code></pre>
</li>
</ul>
</blockquote>
<h4 id="189-写出使用GCD方式从子线程回到主线程的方法代码"><a href="#189-写出使用GCD方式从子线程回到主线程的方法代码" class="headerlink" title="189.写出使用GCD方式从子线程回到主线程的方法代码"></a>189.写出使用GCD方式从子线程回到主线程的方法代码</h4><pre><code>    dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);
</code></pre>
<h4 id="190-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"><a href="#190-如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）" class="headerlink" title="190.如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"></a>190.如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</h4><pre><code>// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。
// 创建队列组
dispatch_group_t group = dispatch_group_create();
// 获取全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);
dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;); 
// 当并发队列组中的任务执行完毕后才会执行这里的代码
dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;
        // 合并图片
&#125;);
</code></pre>
<h4 id="191-dispatch-barrier-async（栅栏函数）的作用是什么？"><a href="#191-dispatch-barrier-async（栅栏函数）的作用是什么？" class="headerlink" title="191.dispatch_barrier_async（栅栏函数）的作用是什么？"></a>191.dispatch_barrier_async（栅栏函数）的作用是什么？</h4><pre><code>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
作用：
    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。
    2.避免数据竞争

 // 1.创建并发队列
 dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
// 2.向队列中添加任务
dispatch_async(queue, ^&#123;  // 1.2是并行的
    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);
&#125;);
dispatch_async(queue, ^&#123;
    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);
&#125;);

 dispatch_barrier_async(queue, ^&#123;
    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);
&#125;);

 dispatch_async(queue, ^&#123;   // 这两个是同时执行的
    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);
&#125;);
 dispatch_async(queue, ^&#123;
    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);
&#125;);

 // 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 
// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。
</code></pre>
<h4 id="192-以下代码运行结果如何？"><a href="#192-以下代码运行结果如何？" class="headerlink" title="192.以下代码运行结果如何？"></a>192.以下代码运行结果如何？</h4><pre><code>- (void)viewDidLoad &#123;
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^&#123;
        NSLog(@&quot;2&quot;);
    &#125;);
    NSLog(@&quot;3&quot;);
 &#125;
// 只输出：1。（主线程死锁）
</code></pre>
<h4 id="193-什么是-RunLoop"><a href="#193-什么是-RunLoop" class="headerlink" title="193.什么是 RunLoop"></a>193.什么是 RunLoop</h4><blockquote>
<ul>
<li>从字面上讲就是运行循环，它内部就是do-while循环，在这  个循环内部不断地处理各种任务。</li>
<li>一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</li>
<li>  主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</li>
</ul>
</blockquote>
<pre><code>  int main(int argc, char * argv[]) &#123;
     @autoreleasepool &#123;
         return UIApplicationMain(argc, argv, nil,   NSStringFromClass([AppDelegate class]));
     &#125;
 &#125;
</code></pre>
<h4 id="194-什么是-Runtime"><a href="#194-什么是-Runtime" class="headerlink" title="194.什么是 Runtime"></a>194.什么是 Runtime</h4><blockquote>
<ul>
<li>Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</li>
</ul>
</blockquote>
<h4 id="195-Runtime实现的机制是什么，怎么用，一般用于干嘛？"><a href="#195-Runtime实现的机制是什么，怎么用，一般用于干嘛？" class="headerlink" title="195.Runtime实现的机制是什么，怎么用，一般用于干嘛？"></a>195.Runtime实现的机制是什么，怎么用，一般用于干嘛？</h4><blockquote>
<ul>
<li><p>使用时需要导入的头文件 &lt;objc/message.h&gt; &lt;objc/runtime.h&gt;</p>
</li>
<li><p>Runtime 运行时机制，它是一套C语言库。</p>
</li>
<li><p>实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</p>
<p>比如：</p>
<p>类转成了 Runtime 库里面的结构体等数据类型，</p>
<p>方法转成了 Runtime 库里面的C语言函数，</p>
<p>平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）</p>
</li>
</ul>
</blockquote>
<pre><code> // OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
 // [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));   
  
</code></pre>
<blockquote>
<ul>
<li>因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。</li>
</ul>
</blockquote>
<h4 id="196-有了Runtime库，能做什么事情呢？"><a href="#196-有了Runtime库，能做什么事情呢？" class="headerlink" title="196.有了Runtime库，能做什么事情呢？"></a>196.有了Runtime库，能做什么事情呢？</h4><blockquote>
<ul>
<li><p> Runtime库里面包含了跟类、成员变量、方法相关的API。</p>
</li>
<li><p>比如：</p>
<p>   （1）获取类里面的所有成员变量。</p>
<p>   （2）为类动态添加成员变量。</p>
<p>   （3）动态改变类的方法实现。</p>
<p>   （4）为类动态添加新的方法等。</p>
</li>
<li><p> 因此，有了Runtime，想怎么改就怎么改。</p>
</li>
</ul>
</blockquote>
<h4 id="197-什么是-Method-Swizzle（黑魔法），什么情况下会使用？"><a href="#197-什么是-Method-Swizzle（黑魔法），什么情况下会使用？" class="headerlink" title="197.什么是 Method Swizzle（黑魔法），什么情况下会使用？"></a>197.什么是 Method Swizzle（黑魔法），什么情况下会使用？</h4><blockquote>
<ul>
<li>在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。</li>
<li>Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。</li>
<li>在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</li>
<li>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</li>
<li>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。</li>
<li>我们可以利用 class_replaceMethod 来修改类。</li>
<li>我们可以利用 method_setImplementation 来直接设置某个方法的IMP。</li>
<li>归根结底，都是偷换了selector的IMP。</li>
</ul>
</blockquote>
<h4 id="198-objc-msgForward-函数是做什么的，直接调用它将会发生什么？"><a href="#198-objc-msgForward-函数是做什么的，直接调用它将会发生什么？" class="headerlink" title="198._objc_msgForward 函数是做什么的，直接调用它将会发生什么？"></a>198._objc_msgForward 函数是做什么的，直接调用它将会发生什么？</h4><blockquote>
<ul>
<li>_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</li>
</ul>
</blockquote>
<h4 id="199-什么是-TCP-UDP"><a href="#199-什么是-TCP-UDP" class="headerlink" title="199.什么是 TCP / UDP ?"></a>199.什么是 TCP / UDP ?</h4><blockquote>
<ul>
<li>TCP：传输控制协议。</li>
<li>UDP：用户数据协议。</li>
<li>TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</li>
<li>UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</li>
<li>简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</li>
<li> 通信底层原理（OSI七层模型）</li>
</ul>
<p> OSI采用了分层的结构化技术，共分七层：</p>
<p>  物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
</blockquote>
<h4 id="200-介绍一下XMPP？"><a href="#200-介绍一下XMPP？" class="headerlink" title="200.介绍一下XMPP？"></a>200.介绍一下XMPP？</h4><blockquote>
<ul>
<li>XMPP是一种以XML为基础的开放式实时通信协议。</li>
<li>简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。</li>
</ul>
</blockquote>
<h4 id="201-OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？"><a href="#201-OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？" class="headerlink" title="201.OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？"></a>201.OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？</h4><pre><code>// 创建线程的方法
 - [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]
 - [self performSelectorInBackground:nil withObject:nil];
 - [[NSThread alloc] initWithTarget:nil selector:nil object:nil];
 - dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;&#125;);
 - [[NSOperationQueue new] addOperation:nil];

  // 主线程中执行代码的方法
 - [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];
 - dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);
 - [[NSOperationQueue mainQueue] addOperation:nil];
</code></pre>
<h4 id="202-tableView的重用机制？"><a href="#202-tableView的重用机制？" class="headerlink" title="202.tableView的重用机制？"></a>202.tableView的重用机制？</h4><blockquote>
<ul>
<li>UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</li>
</ul>
</blockquote>
<h4 id="203-用伪代码写一个线程安全的单例模式"><a href="#203-用伪代码写一个线程安全的单例模式" class="headerlink" title="203.用伪代码写一个线程安全的单例模式"></a>203.用伪代码写一个线程安全的单例模式</h4><pre><code>static id _instance;
 + (id)allocWithZone:(struct _NSZone *)zone &#123;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^&#123;
        _instance = [super allocWithZone:zone];
    &#125;);
    return _instance;
 &#125;

 + (instancetype)sharedData &#123;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^&#123;
        _instance = [[self alloc] init];
    &#125;);
    return _instance;
 &#125;

 - (id)copyWithZone:(NSZone *)zone &#123;
    return _instance;
 &#125;
</code></pre>
<h4 id="204-如何实现视图的变形"><a href="#204-如何实现视图的变形" class="headerlink" title="204.如何实现视图的变形?"></a>204.如何实现视图的变形?</h4><blockquote>
<ul>
<li>通过修改view的 transform 属性即可。</li>
</ul>
</blockquote>
<h4 id="205-字符串常用方法："><a href="#205-字符串常用方法：" class="headerlink" title="205.字符串常用方法："></a>205.字符串常用方法：</h4><pre><code> NSString *str = @&quot;abc*123&quot;;
 NSArray *arr = [str componentsSeparatedByString:@&quot;*&quot;]; //以目标字符串把原 字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;];
</code></pre>
<h4 id="206-如何高性能的给-UIImageView-加个圆角"><a href="#206-如何高性能的给-UIImageView-加个圆角" class="headerlink" title="206.如何高性能的给 UIImageView 加个圆角?"></a>206.如何高性能的给 UIImageView 加个圆角?</h4><blockquote>
<ul>
<li>不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。</li>
</ul>
</blockquote>
<pre><code>self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;
</code></pre>
<blockquote>
<p> <strong>正确的解决方案：使用绘图技术</strong></p>
</blockquote>
<pre><code> - (UIImage *)circleImage &#123;
    // NO代表透明
     UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
     // 获得上下文
     CGContextRef ctx = UIGraphicsGetCurrentContext();
     // 添加一个圆
     CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
     CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
     // 将图片画上去
     [self drawInRect:rect];
     UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
     // 关闭上下文
     UIGraphicsEndImageContext();
     return image;
 &#125;
</code></pre>
<blockquote>
<p>还有一种方案：使用了贝塞尔曲线”切割”个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。</p>
</blockquote>
<pre><code> UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
 imageView.center = CGPointMake(200, 300);
 UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];
 UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
 [[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
 [anotherImage drawInRect:imageView.bounds];
 imageView.image = UIGraphicsGetImageFromCurrentImageContext();
 UIGraphicsEndImageContext();
 [self.view addSubview:imageView];
</code></pre>
<h4 id="207-你是怎么封装一个view的"><a href="#207-你是怎么封装一个view的" class="headerlink" title="207.你是怎么封装一个view的"></a>207.你是怎么封装一个view的</h4><blockquote>
<ul>
<li>可以通过纯代码或者xib的方式来封装子控件</li>
<li>建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值</li>
</ul>
</blockquote>
<pre><code> /**
  *  纯代码初始化控件时一定会走这个方法
  */
 - (instancetype)initWithFrame:(CGRect)frame &#123;
    if(self = [super initWithFrame:frame]) &#123;
         [self setupUI];
     &#125;
     return self;
 &#125;

 /**
  *  通过xib初始化控件时一定会走这个方法
  */
 - (id)initWithCoder:(NSCoder *)aDecoder &#123;
    if(self = [super initWithCoder:aDecoder]) &#123;
         [self setupUI];
     &#125;
     return self;
 &#125;

 - (void)setupUI &#123;
     // 初始化代码
 &#125;
</code></pre>
<h4 id="208-HTTP协议中-POST-方法和-GET-方法有那些区别"><a href="#208-HTTP协议中-POST-方法和-GET-方法有那些区别" class="headerlink" title="208.HTTP协议中 POST 方法和 GET 方法有那些区别?"></a>208.HTTP协议中 POST 方法和 GET 方法有那些区别?</h4><blockquote>
<ul>
<li> GET用于向服务器请求数据，POST用于提交数据</li>
<li>GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作</li>
<li>GET请求的URL有长度限制，POST请求不会有长度限制</li>
</ul>
</blockquote>
<h4 id="209-请简单的介绍下APNS发送系统消息的机制"><a href="#209-请简单的介绍下APNS发送系统消息的机制" class="headerlink" title="209.请简单的介绍下APNS发送系统消息的机制"></a>209.请简单的介绍下APNS发送系统消息的机制</h4><blockquote>
<ul>
<li><p>APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</p>
</li>
<li><p>APNS的原理：</p>
<p>应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)</p>
<p>应用程序接收到设备令牌并发送给自己的后台服务器</p>
<p>服务器把要推送的内容和设备发送给APNS</p>
<p>APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示</p>
</li>
</ul>
</blockquote>
<h4 id="210-对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象"><a href="#210-对于语句NSString-obj-NSData-alloc-init-obj在编译时和运行时分别时什么类型的对象" class="headerlink" title="210.对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?"></a>210.对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?</h4><blockquote>
<ul>
<li>编译时是NSString的类型;运行时是NSData类型的对象</li>
</ul>
</blockquote>
<h4 id="211-原子-atomic-跟非原子-non-atomic-属性有什么区别"><a href="#211-原子-atomic-跟非原子-non-atomic-属性有什么区别" class="headerlink" title="211.原子(atomic)跟非原子(non-atomic)属性有什么区别?"></a>211.原子(atomic)跟非原子(non-atomic)属性有什么区别?</h4><blockquote>
<ul>
<li>atomic提供多线程安全。是防止在写未完成的时候被另外一个线程读取，造成数据错误</li>
<li> non-atomic:在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。</li>
</ul>
</blockquote>
<h4 id="212-看下面的程序-第一个NSLog会输出什么-这时str的retainCount是多少-第二个和第三个呢-为什么"><a href="#212-看下面的程序-第一个NSLog会输出什么-这时str的retainCount是多少-第二个和第三个呢-为什么" class="headerlink" title="212.看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?"></a>212.看下面的程序,第一个NSLog会输出什么?这时str的retainCount是多少?第二个和第三个呢? 为什么?</h4><pre><code>NSMutableArray* ary = [[NSMutableArray array] retain];
NSString *str = [NSString stringWithFormat:@&quot;test&quot;];
[str retain];
[aryaddObject:str];
NSLog(@”%@%d”,str,[str retainCount]);
[str retain];
[str release];
[str release];
NSLog(@”%@%d”,str,[str retainCount]);
[aryremoveAllObjects];
NSLog(@”%@%d”,str,[str retainCount]);
</code></pre>
<blockquote>
<ul>
<li><p>str的retainCount：创建+1，retain+1，加入数组自动+1 3</p>
</li>
<li><p>retain+1，release-1，release-1 2</p>
</li>
<li><p>数组删除所有对象，所有数组内的对象自动-1 1</p>
</li>
</ul>
</blockquote>
<h4 id="213-内存管理的几条原则时什么-按照默认法则-那些关键字生成的对象需要手动释放-在和property结合的时候怎样有效的避免内存泄露"><a href="#213-内存管理的几条原则时什么-按照默认法则-那些关键字生成的对象需要手动释放-在和property结合的时候怎样有效的避免内存泄露" class="headerlink" title="213.内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?"></a>213.内存管理的几条原则时什么?按照默认法则.那些关键字生成的对象需要手动释放?在和property结合的时候怎样有效的避免内存泄露?</h4><blockquote>
<ul>
<li>谁申请，谁释放</li>
<li>遵循Cocoa Touch的使用原则;</li>
<li>内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。</li>
<li>关键字alloc 或new 生成的对象需要手动释放;</li>
<li>设置正确的property属性，对于retain需要在合适的地方释放，</li>
</ul>
</blockquote>
<h4 id="214-MVC设计模式是什么？-你还熟悉什么设计模式？"><a href="#214-MVC设计模式是什么？-你还熟悉什么设计模式？" class="headerlink" title="214.MVC设计模式是什么？ 你还熟悉什么设计模式？"></a>214.MVC设计模式是什么？ 你还熟悉什么设计模式？</h4><blockquote>
<ul>
<li>设计模式：并不是一种新技术，而是一种编码经验，使用比如java中的接口，iphone中的协议，继承关系等基本手段，用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，java已经归纳了23种设计模式。</li>
<li>mvc设计模式 ：模型，视图，控制器，可以将整个应用程序在思想上分成三大块，对应是的数据的存储或处理，前台的显示，业务逻辑的控制。 Iphone本身的设计思想就是遵循mvc设计模式。其不属于23种设计模式范畴。</li>
<li>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.</li>
<li>单例模式：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。</li>
<li>观察者模式： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>工厂模式：</li>
</ul>
</blockquote>
<pre><code>public class Factory&#123;
public static Sample creator(int which)&#123;
if (which==1)
return new SampleA();
else if (which==2)
return new SampleB();
&#125;
&#125;
</code></pre>
<h4 id="215-浅复制和深复制的区别"><a href="#215-浅复制和深复制的区别" class="headerlink" title="215.浅复制和深复制的区别?"></a>215.浅复制和深复制的区别?</h4><blockquote>
<ul>
<li>浅层复制：只复制指向对象的指针，而不复制引用对象本身。</li>
<li>深层复制：复制引用对象本身。</li>
<li>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源</li>
<li>还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。</li>
<li>用网上一哥们通俗的话将就是：</li>
</ul>
<p> 浅复制好比你和你的影子，你完蛋，你的影子也完蛋</p>
<p> 深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>
</blockquote>
<h4 id="225-类别的作用-继承和类别在实现中有何区别"><a href="#225-类别的作用-继承和类别在实现中有何区别" class="headerlink" title="225.类别的作用?继承和类别在实现中有何区别?"></a>225.类别的作用?继承和类别在实现中有何区别?</h4><blockquote>
<ul>
<li>category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</li>
<li>类别主要有3个作用：</li>
</ul>
<p>1).将类的实现分散到多个不同文件或多个不同框架中。</p>
<p>2).创建对私有方法的前向引用。</p>
<p>3).向对象添加非正式协议。</p>
<ul>
<li>继承可以增加，修改或者删除方法，并且可以增加属性。</li>
</ul>
</blockquote>
<h4 id="226-类别和类扩展的区别。"><a href="#226-类别和类扩展的区别。" class="headerlink" title="226.类别和类扩展的区别。"></a>226.类别和类扩展的区别。</h4><blockquote>
<ul>
<li>category和extensions的不同在于 后者可以添加属性，前者可以用关联对象添加属性。另外后者添加的方法是必须要实现的。 </li>
<li>extensions可以认为是一个私有的Category。</li>
</ul>
</blockquote>
<h4 id="227-oc中的协议和java中的接口概念有何不同"><a href="#227-oc中的协议和java中的接口概念有何不同" class="headerlink" title="227.oc中的协议和java中的接口概念有何不同?"></a>227.oc中的协议和java中的接口概念有何不同?</h4><blockquote>
<ul>
<li><p>OC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。</p>
</li>
<li><p>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。</p>
</li>
<li><p>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里</p>
</li>
<li><p>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。</p>
</li>
<li><p>这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。</p>
</li>
<li><p>这么看，总觉得类别这玩意儿有点像协议的可选协议。”</p>
</li>
<li><p>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，</p>
</li>
<li><p>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>
</li>
</ul>
</blockquote>
<ol start="228">
<li>什么是KVO和KVC?</li>
</ol>
<blockquote>
<ul>
<li>KVC:键 – 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。</li>
</ul>
<p> 很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。</p>
<ul>
<li>KVO:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。</li>
<li>具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。</li>
</ul>
</blockquote>
<blockquote>
<p> <strong>比如我自定义的一个button：</strong></p>
</blockquote>
<pre><code>[self addObserver:self forKeyPath:@&quot;highlighted&quot; options:0 context:nil];
#pragma mark KVO
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
&#123;
if ([keyPath isEqualToString:@&quot;highlighted&quot;] ) &#123;
[self setNeedsDisplay];
&#125;
&#125;
</code></pre>
<blockquote>
<p>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。</p>
<ul>
<li>对于kvc机制如何通过key寻找到value：</li>
</ul>
<p>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</p>
<p>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。)</p>
<p>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“</p>
<p>来至cocoa，这个说法应该挺有道理。</p>
<p>因为我们知道butto确实存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，</p>
<p>可以按照kvc查找的逻辑理解，就说的过去了。</p>
</blockquote>
<h4 id="229-代理的作用"><a href="#229-代理的作用" class="headerlink" title="229.代理的作用?"></a>229.代理的作用?</h4><blockquote>
<ul>
<li>代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。</li>
<li>另外一点，代理可以理解为java中的回调监听机制的一种类似。</li>
</ul>
</blockquote>
<h4 id="230-我们说的oc是动态运行时语言是什么意思"><a href="#230-我们说的oc是动态运行时语言是什么意思" class="headerlink" title="230.我们说的oc是动态运行时语言是什么意思?"></a>230.我们说的oc是动态运行时语言是什么意思?</h4><blockquote>
<ul>
<li><p>多态。 主要是将数据类型的确定由编译时，推迟到了运行时。</p>
</li>
<li><p>这个问题其实浅涉及到两个概念，运行时和多态。</p>
</li>
<li><p>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。</p>
</li>
<li><p>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类(life)都用有一个相同的方法-eat;</p>
</li>
<li><p>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。</p>
</li>
<li><p>也就是不同的对象以自己的方式响应了相同的消息(响应了eat这个选择器)。</p>
</li>
<li><p>因此也可以说，运行时机制是多态的基础?~~~</p>
</li>
</ul>
</blockquote>
<h4 id="231-通知和协议的不同之处"><a href="#231-通知和协议的不同之处" class="headerlink" title="231.通知和协议的不同之处?"></a>231.通知和协议的不同之处?</h4><blockquote>
<ul>
<li><p>协议有控制链(has-a)的关系，通知没有。</p>
</li>
<li><p>首先我一开始也不太明白，什么叫控制链(专业术语了~)。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解</p>
</li>
<li><p>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。</p>
</li>
<li><p>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。</p>
</li>
<li><p>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。</p>
</li>
<li><p>因此控制链(has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>
</li>
</ul>
</blockquote>
<h4 id="232-什么是推送消息"><a href="#232-什么是推送消息" class="headerlink" title="232.什么是推送消息?"></a>232.什么是推送消息?</h4><blockquote>
<ul>
<li>推送通知更是一种技术。</li>
<li>简单点就是客户端获取资源的一种手段。</li>
<li>普通情况下，都是客户端主动的pull。</li>
<li>推送则是服务器端主动push。 测试push的实现可以查看该博文。</li>
</ul>
</blockquote>
<h4 id="233-关于多态性"><a href="#233-关于多态性" class="headerlink" title="233.关于多态性"></a>233.关于多态性</h4><blockquote>
<ul>
<li>多态，子类指针可以赋值给父类。</li>
<li>这个题目其实可以出到一切面向对象语言中，</li>
<li>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来</li>
</ul>
</blockquote>
<h4 id="234-对于单例的理解"><a href="#234-对于单例的理解" class="headerlink" title="234. 对于单例的理解"></a>234. 对于单例的理解</h4><blockquote>
<p> <em>在objective-c中要实现一个单例类，至少需要做以下四个步骤：</em></p>
<ul>
<li>1).为单例对象实现一个静态实例，并初始化，然后设置成nil，</li>
<li>2).实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，</li>
<li>3).重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，</li>
<li>4).适当实现allocWitheZone，copyWithZone，release和autorelease。</li>
</ul>
</blockquote>
<h4 id="235-NSOperation-queue"><a href="#235-NSOperation-queue" class="headerlink" title="235.NSOperation queue?"></a>235.NSOperation queue?</h4><blockquote>
<ul>
<li>存放NSOperation的集合类。</li>
<li>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。</li>
<li>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。</li>
<li>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，</li>
<li>但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。</li>
<li>但是转念一想其实可以参考银行的取票和叫号系统。</li>
<li>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。</li>
<li>但是后来看到一票关于这操作队列话题的文章，其中有一句提到</li>
<li>“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”</li>
<li>瞬间觉得这个queue名字有点忽悠人了，还不如pool~</li>
<li>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</li>
</ul>
</blockquote>
<h4 id="236-是否在一个视图控制器中嵌入两个tableview控制器"><a href="#236-是否在一个视图控制器中嵌入两个tableview控制器" class="headerlink" title="236.是否在一个视图控制器中嵌入两个tableview控制器?"></a>236.是否在一个视图控制器中嵌入两个tableview控制器?</h4><blockquote>
<ul>
<li>一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，</li>
<li>只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController那样的感觉。</li>
</ul>
</blockquote>
<h4 id="237-一个tableView是否可以关联两个不同的数据源-你会怎么处理"><a href="#237-一个tableView是否可以关联两个不同的数据源-你会怎么处理" class="headerlink" title="237.一个tableView是否可以关联两个不同的数据源?你会怎么处理?"></a>237.一个tableView是否可以关联两个不同的数据源?你会怎么处理?</h4><blockquote>
<ul>
<li>首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。</li>
<li>因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。</li>
<li>因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢?想让列表如何显示，不同的数据源分区块显示?</li>
</ul>
</blockquote>
<h4 id="238-什么时候使用NSMutableArray，什么时候使用NSArray"><a href="#238-什么时候使用NSMutableArray，什么时候使用NSArray" class="headerlink" title="238.什么时候使用NSMutableArray，什么时候使用NSArray?"></a>238.什么时候使用NSMutableArray，什么时候使用NSArray?</h4><blockquote>
<ul>
<li>当数组在程序运行时，需要不断变化的，使用NSMutableArray，当数组在初始化后，便不再改变的，使用NSArray。需要指出的是，使用NSArray只表明的是该数组在运行时不发生改变，即不能往NSAarry的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。NSArray是线程安全的，NSMutableArray不是线程安全的，多线程使用到NSMutableArray需要注意。</li>
</ul>
</blockquote>
<h4 id="239-给出委托方法的实例，并且说出UITableVIew的Data-Source方法"><a href="#239-给出委托方法的实例，并且说出UITableVIew的Data-Source方法" class="headerlink" title="239.给出委托方法的实例，并且说出UITableVIew的Data Source方法"></a>239.给出委托方法的实例，并且说出UITableVIew的Data Source方法</h4><blockquote>
<ul>
<li>CocoaTouch框架中用到了大量委托，其中UITableViewDelegate就是委托机制的典型应用，是一个典型的使用委托来实现适配器模式，其中UITableViewDelegate协议是目标，tableview是适配器，实现UITableViewDelegate协议，并将自身设置为talbeview的delegate的对象，是被适配器，一般情况下该对象是UITableViewController。</li>
</ul>
</blockquote>
<pre><code>UITableVIew的Data Source方法有- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>
<h4 id="240-在应用中可以创建多少autorelease对象，是否有限制"><a href="#240-在应用中可以创建多少autorelease对象，是否有限制" class="headerlink" title="240.在应用中可以创建多少autorelease对象，是否有限制?"></a>240.在应用中可以创建多少autorelease对象，是否有限制?</h4><blockquote>
<ul>
<li>无</li>
</ul>
</blockquote>
<h4 id="241-如果我们不创建内存池，是否有内存池提供给我们"><a href="#241-如果我们不创建内存池，是否有内存池提供给我们" class="headerlink" title="241.如果我们不创建内存池，是否有内存池提供给我们?"></a>241.如果我们不创建内存池，是否有内存池提供给我们?</h4><blockquote>
<ul>
<li>界面线程维护着自己的内存池，用户自己创建的数据线程，则需要创建该线程的内存池</li>
</ul>
</blockquote>
<h4 id="242-什么时候需要在程序中创建内存池"><a href="#242-什么时候需要在程序中创建内存池" class="headerlink" title="242.什么时候需要在程序中创建内存池?"></a>242.什么时候需要在程序中创建内存池?</h4><blockquote>
<ul>
<li>用户自己创建的数据线程，则需要创建该线程的内存池</li>
</ul>
</blockquote>
<h4 id="243-类NSObject的那些方法经常被使用"><a href="#243-类NSObject的那些方法经常被使用" class="headerlink" title="243.类NSObject的那些方法经常被使用?"></a>243.类NSObject的那些方法经常被使用?</h4><blockquote>
<ul>
<li>NSObject是Objetive-C的基类，其由NSObject类及一系列协议构成。</li>
<li>其中类方法alloc、class、 description 对象方法init、dealloc、– performSelector:withObject:afterDelay:等经常被使用</li>
</ul>
</blockquote>
<h4 id="244-什么是简便构造方法"><a href="#244-什么是简便构造方法" class="headerlink" title="244.什么是简便构造方法?"></a>244.什么是简便构造方法?</h4><blockquote>
<ul>
<li>简便构造方法一般由CocoaTouch框架提供，如NSNumber的 + numberWithBool: + numberWithChar: + numberWithDouble: + numberWithFloat: + numberWithInt:</li>
<li>Foundation下大部分类均有简便构造方法，我们可以通过简便构造方法，获得系统给我们创建好的对象，并且不需要手动释放。</li>
</ul>
</blockquote>
<h4 id="245-如何使用Xcode设计通用应用"><a href="#245-如何使用Xcode设计通用应用" class="headerlink" title="245.如何使用Xcode设计通用应用?"></a>245.如何使用Xcode设计通用应用?</h4><blockquote>
<ul>
<li>使用MVC模式设计应用，其中Model层完成脱离界面，即在Model层，其是可运行在任何设备上，在controller层，根据iPhone与iPad(独有UISplitViewController)的不同特点选择不同的viewController对象。在View层，可根据现实要求，来设计，其中以xib文件设计时，其设置其为universal。</li>
</ul>
</blockquote>
<h4 id="246-UIView的动画效果有那些"><a href="#246-UIView的动画效果有那些" class="headerlink" title="246.UIView的动画效果有那些?"></a>246.UIView的动画效果有那些?</h4><blockquote>
<ul>
<li>有很多，如 UIViewAnimationOptionCurveEaseInOut UIViewAnimationOptionCurveEaseIn UIViewAnimationOptionCurveEaseOut UIViewAnimationOptionTransitionFlipFromLeft UIViewAnimationOptionTransitionFlipFromRight UIViewAnimationOptionTransitionCurlUpUIViewAnimationOptionTransitionCurlDown</li>
</ul>
</blockquote>
<h4 id="247-在iPhone应用中如何保存数据"><a href="#247-在iPhone应用中如何保存数据" class="headerlink" title="247. 在iPhone应用中如何保存数据?"></a>247. 在iPhone应用中如何保存数据?</h4><blockquote>
<ul>
<li><p>有以下几种保存机制：</p>
</li>
<li><p>1).通过web服务，保存在服务器上</p>
</li>
<li><p>2).通过NSCoder固化机制，将对象保存在文件中</p>
</li>
<li><p>3).通过SQlite或CoreData保存在文件数据库中</p>
</li>
</ul>
</blockquote>
<h4 id="248-什么是coredata"><a href="#248-什么是coredata" class="headerlink" title="248. 什么是coredata?"></a>248. 什么是coredata?</h4><blockquote>
<ul>
<li>coredata是苹果提供一套数据保存框架，其基于SQlite</li>
</ul>
</blockquote>
<h4 id="249-什么是NSManagedObject模型"><a href="#249-什么是NSManagedObject模型" class="headerlink" title="249.什么是NSManagedObject模型?"></a>249.什么是NSManagedObject模型?</h4><blockquote>
<ul>
<li>NSManagedObject是NSObject的子类 ，也是coredata的重要组成部分，它是一个通用的类,实现了core data 模型层所需的基本功能，用户可通过子类化NSManagedObject，建立自己的数据模型。</li>
</ul>
</blockquote>
<h4 id="250-什么是NSManagedobjectContext"><a href="#250-什么是NSManagedobjectContext" class="headerlink" title="250.什么是NSManagedobjectContext?"></a>250.什么是NSManagedobjectContext?</h4><blockquote>
<ul>
<li>NSManagedobjectContext对象负责应用和数据库之间的交互。</li>
</ul>
</blockquote>
<h4 id="251-谈谈对Block-的理解-并写出一个使用Block执行UIVew动画"><a href="#251-谈谈对Block-的理解-并写出一个使用Block执行UIVew动画" class="headerlink" title="251. 谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?"></a>251. 谈谈对Block 的理解?并写出一个使用Block执行UIVew动画?</h4><blockquote>
<ul>
<li>Block是可以获取其他函数局部变量的匿名函数，其不但方便开发，并且可以大幅提高应用的执行效率(多核心CPU可直接处理Block指令)</li>
</ul>
</blockquote>
<pre><code>[UIView transitionWithView:self.view
duration:0.2
options:UIViewAnimationOptionTransitionFlipFromLeft
animations:^&#123; [[blueViewController view] removeFromSuperview]; [[self view] insertSubview:yellowViewController.view atIndex:0]; &#125;
completion:NULL];
</code></pre>
<h4 id="252-写出上面代码的Block的定义。"><a href="#252-写出上面代码的Block的定义。" class="headerlink" title="252.写出上面代码的Block的定义。"></a>252.写出上面代码的Block的定义。</h4><pre><code>typedef void(^animations) (void);
typedef void(^completion) (BOOL finished);
</code></pre>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">Job Interview</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">Written examination</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS//" class="article-tag-list-link color4">iOS</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="/categories/iOS/面试、笔试//" class="article-tag-list-link color1">面试、笔试</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2018/08/11/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Will Power" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 itemprop="name">
	
	  <a class="article-title" href="/2018/07/01/Will%20Power/" target="_blank">Will Power</a>
  
    </h1>
  


  
  
<a href="/2018/07/01/Will%20Power/" class="archive-article-date">
        <time datetime="2018-07-01T08:19:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2018-07-01</time>
</a>

  
  
    

  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h1 id="Will-Power（自控力）-version-1-0"><a href="#Will-Power（自控力）-version-1-0" class="headerlink" title="Will Power（自控力）-version 1.0"></a>Will Power（自控力）-version 1.0</h1><p><img src="/uploads/images/414.png"></p>
<p>如果你总拖到最后一分钟才开始工作；总是月光，信用卡透支；想放松一下，却熬夜上网；一直想减肥，总是挫败；那么这个app会帮助你增强自控，培养习惯，达到真正的控制自己。打开苹果商店，搜索“Will Power”下载。</p>

    

    

    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">Will Power</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/应用介绍//" class="article-tag-list-link color5">应用介绍</a>
        		</li>
      		
		</ul>
	</div>


    
    <p class="article-more-link">
      <a class="article-more-a" href="/2018/07/01/Will%20Power/">展开全文 >></a>
    </p>
    

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017-2021 <a href="http://www.jiyoung.cn/" target="_blank">KangLeon</a>
    	</div>
      	<div class="footer-right">
			
			
      		GitHub:<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank">hexo-theme-yilia-plus</a> by Litten
      	</div>
    </div>
  </div>
  
  
	<script src="/lib/busuanzi.pure.js"></script>
	
  
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(r){function e(t){if(i[t])return i[t].exports;var n=i[t]={exports:{},id:t,loaded:!1};return r[t].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var i={};e.m=r,e.c=i,e.p="./",e(0)}([function(t,n,r){r(208),t.exports=r(205)},function(t,n,r){var d=r(3),y=r(46),g=r(26),b=r(27),x=r(47),m="prototype",S=function(t,n,r){var e,i,o,u,c=t&S.F,f=t&S.G,a=t&S.S,s=t&S.P,l=t&S.B,h=f?d:a?d[n]||(d[n]={}):(d[n]||{})[m],v=f?y:y[n]||(y[n]={}),p=v[m]||(v[m]={});for(e in f&&(r=n),r)o=((i=!c&&h&&void 0!==h[e])?h:r)[e],u=l&&i?x(o,d):s&&"function"==typeof o?x(Function.call,o):o,h&&b(h,e,o,t&S.U),v[e]!=o&&g(v,e,u),s&&p[e]!=o&&(p[e]=o)};d.core=y,S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(5);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(118)("wks"),i=r(79),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(49),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(174),o=r(53),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(20)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(24);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(22),i=r(60),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(96),i=r(34);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(40)("wks"),i=r(25),o=r(6).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(51);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(18);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=!0},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(11),i=r(75);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var o=r(3),u=r(26),c=r(30),f=r(79)("src"),e=r(219),i="toString",a=(""+e).split(i);r(46).inspectSource=function(t){return e.call(t)},(t.exports=function(t,n,r,e){var i="function"==typeof r;i&&(c(r,"name")||u(r,"name",n)),t[n]!==r&&(i&&(c(r,f)||u(r,f,t[n]?""+t[n]:a.join(String(n)))),t===o?t[n]=r:e?t[n]?t[n]=r:u(t,n,r):(delete t[n],u(t,n,r)))})(Function.prototype,i,function(){return"function"==typeof this&&this[f]||e.call(this)})},function(t,n,r){var e=r(1),i=r(4),u=r(51),c=/"/g,o=function(t,n,r,e){var i=String(u(t)),o="<"+n;return""!==r&&(o+=" "+r+'="'+String(e).replace(c,"&quot;")+'"'),o+">"+i+"</"+n+">"};t.exports=function(n,t){var r={};r[n]=t(o),e(e.P+e.F*i(function(){var t=""[n]('"');return t!==t.toLowerCase()||3<t.split('"').length}),"String",r)}},function(t,n,r){var e=r(65),i=r(35);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(117),i=r(75),o=r(33),u=r(53),c=r(30),f=r(174),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(30),i=r(17),o=r(154)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(116),i=r(51);t.exports=function(t){return e(i(t))}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(9),o=r(16)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(25);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(19),i=r(6),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(23)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var i=r(18);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(6),i=r(19),o=r(23),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(16)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){var r=t.exports={version:"2.6.9"};"number"==typeof __e&&(__e=r)},function(t,n,r){var o=r(21);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){"use strict";var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(0<t?e:r)(t)}},function(t,n,r){var x=r(47),m=r(116),S=r(17),w=r(8),e=r(138);t.exports=function(l,t){var h=1==l,v=2==l,p=3==l,d=4==l,y=6==l,g=5==l||y,b=t||e;return function(t,n,r){for(var e,i,o=S(t),u=m(o),c=x(n,r,3),f=w(u.length),a=0,s=h?b(t,f):v?b(t,0):void 0;a<f;a++)if((g||a in u)&&(i=c(e=u[a],a,o),l))if(h)s[a]=i;else if(i)switch(l){case 3:return!0;case 5:return e;case 6:return a;case 2:s.push(e)}else if(d)return!1;return y?-1:p||d?d:s}}},function(t,n){t.exports=function(t){if(null==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var i=r(1),o=r(46),u=r(4);t.exports=function(t,n){var r=(o.Object||{})[t]||Object[t],e={};e[t]=n(r),i(i.S+i.F*u(function(){r(1)}),"Object",e)}},function(t,n,r){var i=r(5);t.exports=function(t,n){if(!i(t))return t;var r,e;if(n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;if("function"==typeof(r=t.valueOf)&&!i(e=r.call(t)))return e;if(!n&&"function"==typeof(r=t.toString)&&!i(e=r.call(t)))return e;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var d=r(6),y=r(19),g=r(93),b=r(13),x=r(9),m="prototype",S=function(t,n,r){var e,i,o,u=t&S.F,c=t&S.G,f=t&S.S,a=t&S.P,s=t&S.B,l=t&S.W,h=c?y:y[n]||(y[n]={}),v=h[m],p=c?d:f?d[n]:(d[n]||{})[m];for(e in c&&(r=n),r)(i=!u&&p&&void 0!==p[e])&&x(h,e)||(o=i?p[e]:r[e],h[e]=c&&"function"!=typeof p[e]?r[e]:s&&i?g(o,d):l&&p[e]==o?function(e){var t=function(t,n,r){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(t);case 2:return new e(t,n)}return new e(t,n,r)}return e.apply(this,arguments)};return t[m]=e[m],t}(o):a&&"function"==typeof o?g(Function.call,o):o,a&&((h.virtual||(h.virtual={}))[e]=o,t&S.R&&v&&!v[e]&&b(v,e,o)))};S.F=1,S.G=2,S.S=4,S.P=8,S.B=16,S.W=32,S.U=64,S.R=128,t.exports=S},function(t,n,r){var e=r(34);t.exports=function(t){return Object(e(t))}},function(t,n,r){var o=r(196),e=r(1),i=r(118)("metadata"),u=i.store||(i.store=new(r(200))),c=function(t,n,r){var e=u.get(t);if(!e){if(!r)return;u.set(t,e=new o)}var i=e.get(n);if(!i){if(!r)return;e.set(n,i=new o)}return i};t.exports={store:u,map:c,has:function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},get:function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},set:function(t,n,r,e){c(r,e,!0).set(t,n)},keys:function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},key:function(t){return void 0===t||"symbol"==typeof t?t:String(t)},exp:function(t){e(e.S,"Reflect",t)}}},function(t,n,r){"use strict";if(r(10)){var g=r(68),b=r(3),x=r(4),m=r(1),S=r(132),e=r(159),h=r(47),w=r(70),i=r(75),_=r(26),o=r(76),u=r(49),O=r(8),E=r(194),c=r(78),f=r(53),a=r(30),M=r(81),P=r(5),v=r(17),p=r(145),j=r(72),F=r(32),A=r(73).f,d=r(161),s=r(79),l=r(7),y=r(50),I=r(120),L=r(119),N=r(162),T=r(82),k=r(125),R=r(77),C=r(137),D=r(166),G=r(11),W=r(31),U=G.f,V=W.f,B=b.RangeError,q=b.TypeError,z=b.Uint8Array,K="ArrayBuffer",H="Shared"+K,J="BYTES_PER_ELEMENT",$="prototype",Y=Array[$],X=e.ArrayBuffer,Q=e.DataView,Z=y(0),tt=y(2),nt=y(3),rt=y(4),et=y(5),it=y(6),ot=I(!0),ut=I(!1),ct=N.values,ft=N.keys,at=N.entries,st=Y.lastIndexOf,lt=Y.reduce,ht=Y.reduceRight,vt=Y.join,pt=Y.sort,dt=Y.slice,yt=Y.toString,gt=Y.toLocaleString,bt=l("iterator"),xt=l("toStringTag"),mt=s("typed_constructor"),St=s("def_constructor"),wt=S.CONSTR,_t=S.TYPED,Ot=S.VIEW,Et="Wrong length!",Mt=y(1,function(t,n){return It(L(t,t[St]),n)}),Pt=x(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),jt=!!z&&!!z[$].set&&x(function(){new z(1).set({})}),Ft=function(t,n){var r=u(t);if(r<0||r%n)throw B("Wrong offset!");return r},At=function(t){if(P(t)&&_t in t)return t;throw q(t+" is not a typed array!")},It=function(t,n){if(!(P(t)&&mt in t))throw q("It is not a typed array constructor!");return new t(n)},Lt=function(t,n){return Nt(L(t,t[St]),n)},Nt=function(t,n){for(var r=0,e=n.length,i=It(t,e);r<e;)i[r]=n[r++];return i},Tt=function(t,n,r){U(t,n,{get:function(){return this._d[r]}})},kt=function(t){var n,r,e,i,o,u,c=v(t),f=arguments.length,a=1<f?arguments[1]:void 0,s=void 0!==a,l=d(c);if(null!=l&&!p(l)){for(u=l.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(s&&2<f&&(a=h(a,arguments[2],2)),n=0,r=O(c.length),i=It(this,r);n<r;n++)i[n]=s?a(c[n],n):c[n];return i},Rt=function(){for(var t=0,n=arguments.length,r=It(this,n);t<n;)r[t]=arguments[t++];return r},Ct=!!z&&x(function(){gt.call(new z(1))}),Dt=function(){return gt.apply(Ct?dt.call(At(this)):At(this),arguments)},Gt={copyWithin:function(t,n){return D.call(At(this),t,n,2<arguments.length?arguments[2]:void 0)},every:function(t){return rt(At(this),t,1<arguments.length?arguments[1]:void 0)},fill:function(t){return C.apply(At(this),arguments)},filter:function(t){return Lt(this,tt(At(this),t,1<arguments.length?arguments[1]:void 0))},find:function(t){return et(At(this),t,1<arguments.length?arguments[1]:void 0)},findIndex:function(t){return it(At(this),t,1<arguments.length?arguments[1]:void 0)},forEach:function(t){Z(At(this),t,1<arguments.length?arguments[1]:void 0)},indexOf:function(t){return ut(At(this),t,1<arguments.length?arguments[1]:void 0)},includes:function(t){return ot(At(this),t,1<arguments.length?arguments[1]:void 0)},join:function(t){return vt.apply(At(this),arguments)},lastIndexOf:function(t){return st.apply(At(this),arguments)},map:function(t){return Mt(At(this),t,1<arguments.length?arguments[1]:void 0)},reduce:function(t){return lt.apply(At(this),arguments)},reduceRight:function(t){return ht.apply(At(this),arguments)},reverse:function(){for(var t,n=this,r=At(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(At(this),t,1<arguments.length?arguments[1]:void 0)},sort:function(t){return pt.call(At(this),t)},subarray:function(t,n){var r=At(this),e=r.length,i=c(t,e);return new(L(r,r[St]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,O((void 0===n?e:c(n,e))-i))}},Wt=function(t,n){return Lt(this,dt.call(At(this),t,n))},Ut=function(t){At(this);var n=Ft(arguments[1],1),r=this.length,e=v(t),i=O(e.length),o=0;if(r<i+n)throw B(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(At(this))},keys:function(){return ft.call(At(this))},values:function(){return ct.call(At(this))}},Bt=function(t,n){return P(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return Bt(t,n=f(n,!0))?i(2,t[n]):V(t,n)},zt=function(t,n,r){return!(Bt(t,n=f(n,!0))&&P(r)&&a(r,"value"))||a(r,"get")||a(r,"set")||r.configurable||a(r,"writable")&&!r.writable||a(r,"enumerable")&&!r.enumerable?U(t,n,r):(t[n]=r.value,t)};wt||(W.f=qt,G.f=zt),m(m.S+m.F*!wt,"Object",{getOwnPropertyDescriptor:qt,defineProperty:zt}),x(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Kt=o({},Gt);o(Kt,Vt),_(Kt,bt,Vt.values),o(Kt,{slice:Wt,set:Ut,constructor:function(){},toString:yt,toLocaleString:Dt}),Tt(Kt,"buffer","b"),Tt(Kt,"byteOffset","o"),Tt(Kt,"byteLength","l"),Tt(Kt,"length","e"),U(Kt,xt,{get:function(){return this[_t]}}),t.exports=function(t,l,n,o){var h=t+((o=!!o)?"Clamped":"")+"Array",r="get"+t,u="set"+t,v=b[h],c=v||{},e=v&&F(v),i=!v||!S.ABV,f={},a=v&&v[$],p=function(t,i){U(t,i,{get:function(){return t=i,(n=this._d).v[r](t*l+n.o,Pt);var t,n},set:function(t){return n=i,r=t,e=this._d,o&&(r=(r=Math.round(r))<0?0:255<r?255:255&r),void e.v[u](n*l+e.o,r,Pt);var n,r,e},enumerable:!0})};i?(v=n(function(t,n,r,e){w(t,v,h,"_d");var i,o,u,c,f=0,a=0;if(P(n)){if(!(n instanceof X||(c=M(n))==K||c==H))return _t in n?Nt(v,n):kt.call(v,n);i=n,a=Ft(r,l);var s=n.byteLength;if(void 0===e){if(s%l)throw B(Et);if((o=s-a)<0)throw B(Et)}else if(s<(o=O(e)*l)+a)throw B(Et);u=o/l}else u=E(n),i=new X(o=u*l);for(_(t,"_d",{b:i,o:a,l:o,e:u,v:new Q(i)});f<u;)p(t,f++)}),a=v[$]=j(Kt),_(a,"constructor",v)):x(function(){v(1)})&&x(function(){new v(-1)})&&k(function(t){new v,new v(null),new v(1.5),new v(t)},!0)||(v=n(function(t,n,r,e){var i;return w(t,v,h),P(n)?n instanceof X||(i=M(n))==K||i==H?void 0!==e?new c(n,Ft(r,l),e):void 0!==r?new c(n,Ft(r,l)):new c(n):_t in n?Nt(v,n):kt.call(v,n):new c(E(n))}),Z(e!==Function.prototype?A(c).concat(A(e)):A(c),function(t){t in v||_(v,t,c[t])}),v[$]=a,g||(a.constructor=v));var s=a[bt],d=!!s&&("values"==s.name||null==s.name),y=Vt.values;_(v,mt,!0),_(a,_t,h),_(a,Ot,!0),_(a,St,v),(o?new v(1)[xt]==h:xt in a)||U(a,xt,{get:function(){return h}}),f[h]=v,m(m.G+m.W+m.F*(v!=c),f),m(m.S,h,{BYTES_PER_ELEMENT:l}),m(m.S+m.F*x(function(){c.of.call(v,1)}),h,{from:kt,of:Rt}),J in a||_(a,J,l),m(m.P,h,Gt),R(h),m(m.P+m.F*jt,h,{set:Ut}),m(m.P+m.F*!d,h,Vt),g||a.toString==yt||(a.toString=yt),m(m.P+m.F*x(function(){new v(1).slice()}),h,{slice:Wt}),m(m.P+m.F*(x(function(){return[1,2].toLocaleString()!=new v([1,2]).toLocaleString()})||!x(function(){a.toLocaleString.call([1,2])})),h,{toLocaleString:Dt}),T[h]=d?s:y,g||d||_(a,bt,y)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(18),i=r(6).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(20)(function(){return 7!=Object.defineProperty(r(59)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var x=r(23),m=r(54),S=r(66),w=r(13),_=r(36),O=r(98),E=r(38),M=r(104),P=r(16)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n,e){var i=e(22),o=e(101),u=e(35),c=e(39)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(59)("iframe"),r=u.length;for(n.style.display="none",e(95).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(65),i=r(35).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var u=r(9),c=r(15),f=r(92)(!1),a=r(39)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;null==i[e]&&r(26)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n){t.exports=!1},function(t,n,r){var e=r(79)("meta"),i=r(5),o=r(30),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n,r){var h=r(47),v=r(177),p=r(145),d=r(2),y=r(8),g=r(161),b={},x={};(n=t.exports=function(t,n,r,e,i){var o,u,c,f,a=i?function(){return t}:g(t),s=h(r,e,n?2:1),l=0;if("function"!=typeof a)throw TypeError(t+" is not iterable!");if(p(a)){for(o=y(t.length);l<o;l++)if((f=n?s(d(u=t[l])[0],u[1]):s(t[l]))===b||f===x)return f}else for(c=a.call(t);!(u=c.next()).done;)if((f=v(c,s,u.value,n))===b||f===x)return f}).BREAK=b,n.RETURN=x},function(t,n,e){var i=e(2),o=e(183),u=e(141),c=e(154)("IE_PROTO"),f=function(){},a="prototype",s=function(){var t,n=e(140)("iframe"),r=u.length;for(n.style.display="none",e(143).appendChild(n),n.src="javascript:",(t=n.contentWindow.document).open(),t.write("<script>document.F=Object<\/script>"),t.close(),s=t.F;r--;)delete s[a][u[r]];return s()};t.exports=Object.create||function(t,n){var r;return null!==t?(f[a]=i(t),r=new f,f[a]=null,r[c]=t):r=s(),void 0===n?r:o(r,n)}},function(t,n,r){var e=r(185),i=r(141).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(185),i=r(141);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var i=r(27);t.exports=function(t,n,r){for(var e in n)i(t,e,n[e],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(49),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(5);t.exports=function(t,n){if(!e(t)||t._t!==n)throw TypeError("Incompatible receiver, "+n+" required!");return t}},function(t,n,r){var i=r(45),o=r(7)("toStringTag"),u="Arguments"==i(function(){return arguments}());t.exports=function(t){var n,r,e;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),o))?r:u?i(n):"Object"==(e=i(n))&&"function"==typeof n.callee?"Arguments":e}},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(30),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var u=r(1),e=r(51),c=r(4),f=r(157),i="["+f+"]",o=RegExp("^"+i+i+"*"),a=RegExp(i+i+"*$"),s=function(t,n,r){var e={},i=c(function(){return!!f[t]()||"​"!="​"[t]()}),o=e[t]=i?n(l):f[t];r&&(e[r]=o),u(u.P+u.F*i,"String",e)},l=s.trim=function(t,n){return t=String(e(t)),1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(a,"")),t};t.exports=s},function(t,n,r){t.exports={default:r(88),__esModule:!0}},function(t,n,r){t.exports={default:r(89),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=e(r(86)),o=e(r(85)),u="function"==typeof o.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":typeof t};n.default="function"==typeof o.default&&"symbol"===u(i.default)?function(t){return void 0===t?"undefined":u(t)}:function(t){return t&&"function"==typeof o.default&&t.constructor===o.default&&t!==o.default.prototype?"symbol":void 0===t?"undefined":u(t)}},function(t,n,r){r(111),r(109),r(112),r(113),t.exports=r(19).Symbol},function(t,n,r){r(110),r(114),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var f=r(15),a=r(107),s=r(106);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){var o=r(90);t.exports=function(e,i,t){if(o(e),void 0===i)return e;switch(t){case 1:return function(t){return e.call(i,t)};case 2:return function(t,n){return e.call(i,t,n)};case 3:return function(t,n,r){return e.call(i,t,n,r)}}return function(){return e.apply(i,arguments)}}},function(t,n,r){var c=r(29),f=r(64),a=r(37);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){var e=r(6).document;t.exports=e&&e.documentElement},function(t,n,r){var e=r(58);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(58);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(62),i=r(24),o=r(38),u={};r(13)(u,r(16)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(25)("meta"),i=r(18),o=r(9),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(20)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=t.exports={KEY:e,NEED:!1,fastKey:function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},getWeak:function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},onFreeze:function(t){return a&&l.NEED&&f(t)&&!o(t,e)&&s(t),t}}},function(t,n,r){var u=r(14),c=r(22),f=r(29);t.exports=r(12)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(24),o=r(15),u=r(42),c=r(9),f=r(60),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(15),i=r(63).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var e=r(9),i=r(55),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var f=r(41),a=r(34);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return(t=e(t))<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return 0<t?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(91),i=r(99),o=r(36),u=r(15);t.exports=r(61)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(105)(!0);r(61)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(6),u=r(9),i=r(12),o=r(54),c=r(66),f=r(100).KEY,a=r(20),s=r(40),l=r(38),h=r(25),v=r(16),p=r(44),d=r(43),y=r(94),g=r(97),b=r(22),x=r(18),m=r(55),S=r(15),w=r(42),_=r(24),O=r(62),E=r(103),M=r(102),P=r(64),j=r(14),F=r(29),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(63).f=E.f=tt,r(37).f=Q,P.f=nt,i&&!r(23)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(13)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(108);for(var e=r(6),i=r(13),o=r(36),u=r(16)("toStringTag"),c="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),f=0;f<c.length;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(46),i=r(3),o="__core-js_shared__",u=i[o]||(i[o]={});(t.exports=function(t,n){return u[t]||(u[t]=void 0!==n?n:{})})("versions",[]).push({version:e.version,mode:r(68)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,n,r){var i=r(2),o=r(21),u=r(7)("species");t.exports=function(t,n){var r,e=i(t).constructor;return void 0===e||null==(r=i(e)[u])?n:o(r)}},function(t,n,r){var f=r(33),a=r(8),s=r(78);t.exports=function(c){return function(t,n,r){var e,i=f(t),o=a(i.length),u=s(r,o);if(c&&n!=n){for(;u<o;)if((e=i[u++])!=e)return!0}else for(;u<o;u++)if((c||u in i)&&i[u]===n)return c||u||0;return!c&&-1}}},function(t,n,r){"use strict";var g=r(3),b=r(1),x=r(27),m=r(76),S=r(69),w=r(71),_=r(70),O=r(5),E=r(4),M=r(125),P=r(83),j=r(144);t.exports=function(e,t,n,r,i,o){var u=g[e],c=u,f=i?"set":"add",a=c&&c.prototype,s={},l=function(t){var r=a[t];x(a,t,"delete"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"has"==t?function(t){return!(o&&!O(t))&&r.call(this,0===t?0:t)}:"get"==t?function(t){return o&&!O(t)?void 0:r.call(this,0===t?0:t)}:"add"==t?function(t){return r.call(this,0===t?0:t),this}:function(t,n){return r.call(this,0===t?0:t,n),this})};if("function"==typeof c&&(o||a.forEach&&!E(function(){(new c).entries().next()}))){var h=new c,v=h[f](o?{}:-0,1)!=h,p=E(function(){h.has(1)}),d=M(function(t){new c(t)}),y=!o&&E(function(){for(var t=new c,n=5;n--;)t[f](n,n);return!t.has(-0)});d||(((c=t(function(t,n){_(t,c,e);var r=j(new u,t,c);return null!=n&&w(n,i,r[f],r),r})).prototype=a).constructor=c),(p||y)&&(l("delete"),l("has"),i&&l("get")),(y||v)&&l(f),o&&a.clear&&delete a.clear}else c=r.getConstructor(t,e,i,f),m(c.prototype,n),S.NEED=!0;return P(c,e),s[e]=c,b(b.G+b.W+b.F*(c!=u),s),o||r.setStrong(c,e,i),c}},function(t,n,r){"use strict";r(197);var s=r(27),l=r(26),h=r(4),v=r(51),p=r(7),d=r(152),y=p("species"),g=!h(function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")}),b=function(){var t=/(?:)/,n=t.exec;t.exec=function(){return n.apply(this,arguments)};var r="ab".split(t);return 2===r.length&&"a"===r[0]&&"b"===r[1]}();t.exports=function(r,t,n){var e=p(r),o=!h(function(){var t={};return t[e]=function(){return 7},7!=""[r](t)}),i=o?!h(function(){var t=!1,n=/a/;return n.exec=function(){return t=!0,null},"split"===r&&(n.constructor={},n.constructor[y]=function(){return n}),n[e](""),!t}):void 0;if(!o||!i||"replace"===r&&!g||"split"===r&&!b){var u=/./[e],c=n(v,e,""[r],function(t,n,r,e,i){return n.exec===d?o&&!i?{done:!0,value:u.call(n,r,e)}:{done:!0,value:t.call(r,n,e)}:{done:!1}}),f=c[0],a=c[1];s(String.prototype,r,f),l(RegExp.prototype,e,2==t?function(t,n){return a.call(t,this,n)}:function(t){return a.call(t,this)})}}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){var e=r(5),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var o=r(7)("iterator"),u=!1;try{var e=[7][o]();e.return=function(){u=!0},Array.from(e,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!u)return!1;var r=!1;try{var e=[7],i=e[o]();i.next=function(){return{done:r=!0}},e[o]=function(){return i},t(e)}catch(t){}return r}},function(t,n,r){"use strict";t.exports=r(68)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){"use strict";var i=r(81),o=RegExp.prototype.exec;t.exports=function(t,n){var r=t.exec;if("function"==typeof r){var e=r.call(t,n);if("object"!=typeof e)throw new TypeError("RegExp exec method returned something other than an Object or null");return e}if("RegExp"!==i(t))throw new TypeError("RegExp#exec called on incompatible receiver");return o.call(t,n)}},function(t,n,r){"use strict";var e=r(1),u=r(21),c=r(47),f=r(71);t.exports=function(t){e(e.S,t,{from:function(t){var n,r,e,i,o=arguments[1];return u(this),(n=void 0!==o)&&u(o),null==t?new this:(r=[],n?(e=0,i=c(o,arguments[2],2),f(t,!1,function(t){r.push(i(t,e++))})):f(t,!1,r.push,r),new this(r))}})}},function(t,n,r){"use strict";var e=r(1);t.exports=function(t){e(e.S,t,{of:function(){for(var t=arguments.length,n=new Array(t);t--;)n[t]=arguments[t];return new this(n)}})}},function(t,n,r){var f=r(49),a=r(51);t.exports=function(c){return function(t,n){var r,e,i=String(a(t)),o=f(n),u=i.length;return o<0||u<=o?c?"":void 0:(r=i.charCodeAt(o))<55296||56319<r||o+1===u||(e=i.charCodeAt(o+1))<56320||57343<e?c?i.charAt(o):r:c?i.slice(o,o+2):e-56320+(r-55296<<10)+65536}}},function(t,n,r){for(var e,i=r(3),o=r(26),u=r(79),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n,r){var e=r(3).navigator;t.exports=e&&e.userAgent||""},function(t,n){"use strict";var r,e={versions:(r=window.navigator.userAgent,{trident:-1<r.indexOf("Trident"),presto:-1<r.indexOf("Presto"),webKit:-1<r.indexOf("AppleWebKit"),gecko:-1<r.indexOf("Gecko")&&-1==r.indexOf("KHTML"),mobile:!!r.match(/AppleWebKit.*Mobile.*/),ios:!!r.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:-1<r.indexOf("Android")||-1<r.indexOf("Linux"),iPhone:-1<r.indexOf("iPhone")||-1<r.indexOf("Mac"),iPad:-1<r.indexOf("iPad"),webApp:-1==r.indexOf("Safari"),weixin:-1==r.indexOf("MicroMessenger")})};t.exports=e},function(t,n,r){"use strict";var e,i=r(87),l=(e=i)&&e.__esModule?e:{default:e},h=function(){function n(t,n,r){return n||r?String.fromCharCode(n||r):o[t]||t}function r(t){return s[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,i=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},u=/\u00a0/g,c=/<br\s*\/?>/gi,f=/\r?\n/g,a=/\s/g,s={};for(var t in o)s[o[t]]=t;return o["&apos;"]="'",s["'"]="&#39;",{encode:function(t){return t?(""+t).replace(i,r).replace(f,"<br/>").replace(a,"&nbsp;"):""},decode:function(t){return t?(""+t).replace(c,"\n").replace(e,n).replace(u," "):""},encodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;for(var n=[],r=0,e=(t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")})).length;r<e;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;for(var n=[],r=0,e=(t+="").length;r<e;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;n<r;n++)t[n]=h.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,l.default)(t)))for(var e in t)t[e]=h.encodeObject(t[e]);else if("string"==typeof t)return h.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=h},function(t,n,r){"use strict";var e=r(131)(!0);t.exports=function(t,n,r){return n+(r?e(t,n).length:1)}},function(t,n,r){"use strict";var c=r(17),f=r(78),a=r(8);t.exports=function(t){for(var n=c(this),r=a(n.length),e=arguments.length,i=f(1<e?arguments[1]:void 0,r),o=2<e?arguments[2]:void 0,u=void 0===o?r:f(o,r);i<u;)n[i++]=t;return n}},function(t,n,r){var e=r(215);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(11),i=r(75);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(5),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(n){var r=/./;try{"/./"[n](r)}catch(t){try{return r[e]=!1,!"/./"[n](r)}catch(n){}}return!0}},function(t,n,r){var e=r(3).document;t.exports=e&&e.documentElement},function(t,n,r){var o=r(5),u=r(153).set;t.exports=function(t,n,r){var e,i=n.constructor;return i!==r&&"function"==typeof i&&(e=i.prototype)!==r.prototype&&o(e)&&u&&u(t,e),t}},function(t,n,r){var e=r(82),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){"use strict";var e=r(72),i=r(75),o=r(83),u={};r(26)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var x=r(68),m=r(1),S=r(27),w=r(26),_=r(82),O=r(146),E=r(83),M=r(32),P=r(7)("iterator"),j=!([].keys&&"next"in[].keys()),F="values",A=function(){return this};t.exports=function(t,n,r,e,i,o,u){O(r,n,e);var c,f,a,s=function(t){if(!j&&t in p)return p[t];switch(t){case"keys":case F:return function(){return new r(this,t)}}return function(){return new r(this,t)}},l=n+" Iterator",h=i==F,v=!1,p=t.prototype,d=p[P]||p["@@iterator"]||i&&p[i],y=d||s(i),g=i?h?s("entries"):y:void 0,b="Array"==n&&p.entries||d;if(b&&((a=M(b.call(new t)))!==Object.prototype&&a.next&&(E(a,l,!0),x||"function"==typeof a[P]||w(a,P,A))),h&&d&&d.name!==F&&(v=!0,y=function(){return d.call(this)}),x&&!u||!j&&!v&&p[P]||w(p,P,y),_[n]=y,_[l]=A,i)if(c={values:h?y:s(F),keys:o?y:s("keys"),entries:g},u)for(f in c)f in p||S(p,f,c[f]);else m(m.P+m.F*(j||v),n,c);return c}},function(t,n){var r=Math.expm1;t.exports=!r||22025.465794806718<r(10)||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:-1e-6<t&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var c=r(3),f=r(158).set,a=c.MutationObserver||c.WebKitMutationObserver,s=c.process,l=c.Promise,h="process"==r(45)(s);t.exports=function(){var r,e,i,t=function(){var t,n;for(h&&(t=s.domain)&&t.exit();r;){n=r.fn,r=r.next;try{n()}catch(t){throw r?i():e=void 0,t}}e=void 0,t&&t.enter()};if(h)i=function(){s.nextTick(t)};else if(!a||c.navigator&&c.navigator.standalone)if(l&&l.resolve){var n=l.resolve(void 0);i=function(){n.then(t)}}else i=function(){f.call(c,t)};else{var o=!0,u=document.createTextNode("");new a(t).observe(u,{characterData:!0}),i=function(){u.data=o=!o}}return function(t){var n={fn:t,next:void 0};e&&(e.next=n),r||(r=n,i()),e=n}}},function(t,n,r){"use strict";function e(t){var r,e;this.promise=new t(function(t,n){if(void 0!==r||void 0!==e)throw TypeError("Bad Promise constructor");r=t,e=n}),this.resolve=i(r),this.reject=i(e)}var i=r(21);t.exports.f=function(t){return new e(t)}},function(t,n,r){"use strict";var e,i,u=r(115),c=RegExp.prototype.exec,f=String.prototype.replace,o=c,a="lastIndex",s=(e=/a/,i=/b*/g,c.call(e,"a"),c.call(i,"a"),0!==e[a]||0!==i[a]),l=void 0!==/()??/.exec("")[1];(s||l)&&(o=function(t){var n,r,e,i,o=this;return l&&(r=new RegExp("^"+o.source+"$(?!\\s)",u.call(o))),s&&(n=o[a]),e=c.call(o,t),s&&e&&(o[a]=o.global?e.index+e[0].length:n),l&&e&&1<e.length&&f.call(e[0],r,function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(e[i]=void 0)}),e}),t.exports=o},function(t,n,i){var r=i(5),e=i(2),o=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,r,e){try{(e=i(47)(Function.call,i(31).f(Object.prototype,"__proto__").set,2))(t,[]),r=!(t instanceof Array)}catch(t){r=!0}return function(t,n){return o(t,n),r?t.__proto__=n:e(t,n),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(118)("keys"),i=r(79);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(124),i=r(51);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var i=r(49),o=r(51);t.exports=function(t){var n=String(o(this)),r="",e=i(t);if(e<0||e==1/0)throw RangeError("Count can't be negative");for(;0<e;(e>>>=1)&&(n+=n))1&e&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(47),c=r(175),f=r(143),a=r(140),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=s.Dispatch,y=0,g={},b="onreadystatechange",x=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},m=function(t){x.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return g[++y]=function(){c("function"==typeof t?t:Function(t),n)},e(y),y},v=function(t){delete g[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(x,t,1))}:d&&d.now?e=function(t){d.now(u(x,t,1))}:p?(o=(i=new p).port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=b in a("script")?function(t){f.appendChild(a("script"))[b]=function(){f.removeChild(this),x.call(t)}}:function(t){setTimeout(u(x,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";function e(t,n,r){var e,i,o,u=new Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?W(2,-24)-W(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for((t=G(t))!=t||t===C?(i=t!=t?1:0,e=f):(e=U(V(t)/B),t*(o=W(2,-e))<1&&(e--,o*=2),2<=(t+=1<=e+a?s/o:s*W(2,1-a))*o&&(e++,o/=2),f<=e+a?(i=0,e=f):1<=e+a?(i=(t*o-1)*W(2,n),e+=a):(i=t*W(2,a-1)*W(2,n),e=0));8<=n;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;0<c;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u}function i(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;0<c;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;0<c;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-C:C;e+=W(2,n),s-=u}return(a?-1:1)*e*W(2,s-n)}function o(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]}function u(t){return[255&t]}function c(t){return[255&t,t>>8&255]}function f(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]}function a(t){return e(t,52,8)}function s(t){return e(t,23,4)}function l(t,n,r){M(t[I],n,{get:function(){return this[r]}})}function h(t,n,r,e){var i=O(+r);if(i+n>t[H])throw R(L);var o=t[K]._b,u=i+t[J],c=o.slice(u,u+n);return e?c:c.reverse()}function v(t,n,r,e,i,o){var u=O(+r);if(u+n>t[H])throw R(L);for(var c=t[K]._b,f=u+t[J],a=e(+i),s=0;s<n;s++)c[f+s]=a[o?s:n-s-1]}var p=r(3),d=r(10),y=r(68),g=r(132),b=r(26),x=r(76),m=r(4),S=r(70),w=r(49),_=r(8),O=r(194),E=r(73).f,M=r(11).f,P=r(137),j=r(83),F="ArrayBuffer",A="DataView",I="prototype",L="Wrong index!",N=p[F],T=p[A],k=p.Math,R=p.RangeError,C=p.Infinity,D=N,G=k.abs,W=k.pow,U=k.floor,V=k.log,B=k.LN2,q="byteLength",z="byteOffset",K=d?"_b":"buffer",H=d?"_l":q,J=d?"_o":z;if(g.ABV){if(!m(function(){N(1)})||!m(function(){new N(-1)})||m(function(){return new N,new N(1.5),new N(NaN),N.name!=F})){for(var $,Y=(N=function(t){return S(this,N),new D(O(t))})[I]=D[I],X=E(D),Q=0;X.length>Q;)($=X[Q++])in N||b(N,$,D[$]);y||(Y.constructor=N)}var Z=new T(new N(2)),tt=T[I].setInt8;Z.setInt8(0,2147483648),Z.setInt8(1,2147483649),!Z.getInt8(0)&&Z.getInt8(1)||x(T[I],{setInt8:function(t,n){tt.call(this,t,n<<24>>24)},setUint8:function(t,n){tt.call(this,t,n<<24>>24)}},!0)}else N=function(t){S(this,N,F);var n=O(t);this._b=P.call(new Array(n),0),this[H]=n},T=function(t,n,r){S(this,T,A),S(t,N,A);var e=t[H],i=w(n);if(i<0||e<i)throw R("Wrong offset!");if(e<i+(r=void 0===r?e-i:_(r)))throw R("Wrong length!");this[K]=t,this[J]=i,this[H]=r},d&&(l(N,q,"_l"),l(T,"buffer","_b"),l(T,q,"_l"),l(T,z,"_o")),x(T[I],{getInt8:function(t){return h(this,1,t)[0]<<24>>24},getUint8:function(t){return h(this,1,t)[0]},getInt16:function(t){var n=h(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=h(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return o(h(this,4,t,arguments[1]))},getUint32:function(t){return o(h(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return i(h(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return i(h(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){v(this,1,t,u,n)},setUint8:function(t,n){v(this,1,t,u,n)},setInt16:function(t,n){v(this,2,t,c,n,arguments[2])},setUint16:function(t,n){v(this,2,t,c,n,arguments[2])},setInt32:function(t,n){v(this,4,t,f,n,arguments[2])},setUint32:function(t,n){v(this,4,t,f,n,arguments[2])},setFloat32:function(t,n){v(this,4,t,s,n,arguments[2])},setFloat64:function(t,n){v(this,8,t,a,n,arguments[2])}});j(N,F),j(T,A),b(T[I],g.VIEW,!0),n[F]=N,n[A]=T},function(t,n,r){var e=r(3),i=r(46),o=r(68),u=r(195),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(81),i=r(7)("iterator"),o=r(82);t.exports=r(46).getIteratorMethod=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(67),i=r(178),o=r(82),u=r(33);t.exports=r(147)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):i(0,"keys"==n?r:"values"==n?t[r]:[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){t.exports=function(t,n){t.classList?t.classList.add(n):t.className+=" "+n}},function(t,n){t.exports=function(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var a=r(17),s=r(78),l=r(8);t.exports=[].copyWithin||function(t,n){var r=a(this),e=l(r.length),i=s(t,e),o=s(n,e),u=2<arguments.length?arguments[2]:void 0,c=Math.min((void 0===u?e:s(u,e))-o,e-i),f=1;for(o<i&&i<o+c&&(f=-1,o+=c-1,i+=c-1);0<c--;)o in r?r[i]=r[o]:delete r[i],i+=f,o+=f;return r}},function(t,n,r){var e=r(71);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var s=r(21),l=r(17),h=r(116),v=r(8);t.exports=function(t,n,r,e,i){s(n);var o=l(t),u=h(o),c=v(o.length),f=i?c-1:0,a=i?-1:1;if(r<2)for(;;){if(f in u){e=u[f],f+=a;break}if(f+=a,i?f<0:c<=f)throw TypeError("Reduce of empty array with no initial value")}for(;i?0<=f:f<c;f+=a)f in u&&(e=n(e,u[f],f,o));return e}},function(t,n,r){"use strict";var o=r(21),u=r(5),c=r(175),f=[].slice,a={};t.exports=Function.bind||function(n){var r=o(this),e=f.call(arguments,1),i=function(){var t=e.concat(f.call(arguments));return this instanceof i?function(t,n,r){if(!(n in a)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";a[n]=Function("F,a","return new F("+e.join(",")+")")}return a[n](t,r)}(r,t.length,t):c(r,t,n)};return u(r.prototype)&&(i.prototype=r.prototype),i}},function(t,n,r){"use strict";var u=r(11).f,c=r(72),f=r(76),a=r(47),s=r(70),l=r(71),e=r(147),i=r(178),o=r(77),h=r(10),v=r(69).fastKey,p=r(80),d=h?"_s":"size",y=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,o,r,e){var i=t(function(t,n){s(t,i,o,"_i"),t._t=o,t._i=c(null),t._f=void 0,t._l=void 0,t[d]=0,null!=n&&l(n,r,t[e],t)});return f(i.prototype,{clear:function(){for(var t=p(this,o),n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=p(this,o),r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){p(this,o);for(var n,r=a(t,1<arguments.length?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(p(this,o),t)}}),h&&u(i.prototype,"size",{get:function(){return p(this,o)[d]}}),i},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,r,n){e(t,r,function(t,n){this._t=p(t,r),this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?i(0,"keys"==n?r.k:"values"==n?r.v:[r.k,r.v]):(t._t=void 0,i(1))},n?"entries":"values",!n,!0),o(r)}}},function(t,n,r){var e=r(81),i=r(167);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var u=r(76),c=r(69).getWeak,i=r(2),f=r(5),a=r(70),s=r(71),e=r(50),l=r(30),h=r(80),o=e(5),v=e(6),p=0,d=function(t){return t._l||(t._l=new y)},y=function(){this.a=[]},g=function(t,n){return o(t.a,function(t){return t[0]===n})};y.prototype={get:function(t){var n=g(this,t);if(n)return n[1]},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(n){var t=v(this.a,function(t){return t[0]===n});return~t&&this.a.splice(t,1),!!~t}},t.exports={getConstructor:function(t,r,e,i){var o=t(function(t,n){a(t,o,r,"_i"),t._t=r,t._i=p++,t._l=void 0,null!=n&&s(n,e,t[i],t)});return u(o.prototype,{delete:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).delete(t):n&&l(n,this._i)&&delete n[this._i]},has:function(t){if(!f(t))return!1;var n=c(t);return!0===n?d(h(this,r)).has(t):n&&l(n,this._i)}}),o},def:function(t,n,r){var e=c(i(n),!0);return!0===e?d(t).set(n,r):e[t._i]=r,t},ufstore:d}},function(t,n,r){"use strict";var p=r(123),d=r(5),y=r(8),g=r(47),b=r(7)("isConcatSpreadable");t.exports=function t(n,r,e,i,o,u,c,f){for(var a,s,l=o,h=0,v=!!c&&g(c,f,3);h<i;){if(h in e){if(a=v?v(e[h],h,r):e[h],s=!1,d(a)&&(s=void 0!==(s=a[b])?!!s:p(a)),s&&0<u)l=t(n,r,a,y(a.length),l,u-1)-1;else{if(9007199254740991<=l)throw TypeError();n[l]=a}l++}h++}return l}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(140)("div"),"a",{get:function(){return 7}}).a})},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(5),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var o=r(2);t.exports=function(t,n,r,e){try{return e?n(o(r)[0],r[1]):n(r)}catch(n){var i=t.return;throw void 0!==i&&o(i.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var o=r(149),e=Math.pow,u=e(2,-52),c=e(2,-23),f=e(2,127)*(2-c),a=e(2,-126);t.exports=Math.fround||function(t){var n,r,e=Math.abs(t),i=o(t);return e<a?i*(e/a/c+1/u-1/u)*a*c:f<(r=(n=(1+c/u)*e)-(n-e))||r!=r?i*(1/0):i*r}},function(t,n){t.exports=Math.log1p||function(t){return-1e-8<(t=+t)&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n){t.exports=Math.scale||function(t,n,r,e,i){return 0===arguments.length||t!=t||n!=n||r!=r||e!=e||i!=i?NaN:t===1/0||t===-1/0?t:(t-n)*(i-e)/(r-n)+e}},function(t,n,r){"use strict";var h=r(10),v=r(74),p=r(127),d=r(117),y=r(17),g=r(116),i=Object.assign;t.exports=!i||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=i({},t)[r]||Object.keys(i({},n)).join("")!=e})?function(t,n){for(var r=y(t),e=arguments.length,i=1,o=p.f,u=d.f;i<e;)for(var c,f=g(arguments[i++]),a=o?v(f).concat(o(f)):v(f),s=a.length,l=0;l<s;)c=a[l++],h&&!u.call(f,c)||(r[c]=f[c]);return r}:i},function(t,n,r){var u=r(11),c=r(2),f=r(74);t.exports=r(10)?Object.defineProperties:function(t,n){c(t);for(var r,e=f(n),i=e.length,o=0;o<i;)u.f(t,r=e[o++],n[r]);return t}},function(t,n,r){var e=r(33),i=r(73).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return u.slice()}}(t):i(e(t))}},function(t,n,r){var u=r(30),c=r(33),f=r(120)(!1),a=r(154)("IE_PROTO");t.exports=function(t,n){var r,e=c(t),i=0,o=[];for(r in e)r!=a&&u(e,r)&&o.push(r);for(;n.length>i;)u(e,r=n[i++])&&(~f(o,r)||o.push(r));return o}},function(t,n,r){var f=r(10),a=r(74),s=r(33),l=r(117).f;t.exports=function(c){return function(t){for(var n,r=s(t),e=a(r),i=e.length,o=0,u=[];o<i;)n=e[o++],f&&!l.call(r,n)||u.push(c?[n,r[n]]:r[n]);return u}}},function(t,n,r){var e=r(73),i=r(127),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(84).trim;t.exports=1/e(r(157)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(84).trim,o=r(157),u=/^[-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=function(t){try{return{e:!1,v:t()}}catch(t){return{e:!0,v:t}}}},function(t,n,r){var e=r(2),i=r(5),o=r(151);t.exports=function(t,n){if(e(t),i(n)&&n.constructor===t)return n;var r=o.f(t);return(0,r.resolve)(n),r.promise}},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var s=r(8),l=r(156),h=r(51);t.exports=function(t,n,r,e){var i=String(h(t)),o=i.length,u=void 0===r?" ":String(r),c=s(n);if(c<=o||""==u)return i;var f=c-o,a=l.call(u,Math.ceil(f/u.length));return a.length>f&&(a=a.slice(0,f)),e?a+i:i+a}},function(t,n,r){var e=r(49),i=r(8);t.exports=function(t){if(void 0===t)return 0;var n=e(t),r=i(n);if(n!==r)throw RangeError("Wrong length!");return r}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Map",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(i(this,"Map"),t);return n&&n.v},set:function(t,n){return e.def(i(this,"Map"),0===t?0:t,n)}},e,!0)},function(t,n,r){"use strict";var e=r(152);r(1)({target:"RegExp",proto:!0,forced:e!==/./.exec},{exec:e})},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(115)})},function(t,n,r){"use strict";var e=r(170),i=r(80);t.exports=r(121)("Set",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"Set"),t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var o,e=r(3),i=r(50)(0),u=r(27),c=r(69),f=r(182),a=r(172),s=r(5),l=r(80),h=r(80),v=!e.ActiveXObject&&"ActiveXObject"in e,p="WeakMap",d=c.getWeak,y=Object.isExtensible,g=a.ufstore,b=function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},x={get:function(t){if(s(t)){var n=d(t);return!0===n?g(l(this,p)).get(t):n?n[this._i]:void 0}},set:function(t,n){return a.def(l(this,p),t,n)}},m=t.exports=r(121)(p,b,x,a,!0,!0);h&&v&&(f((o=a.getConstructor(b,p)).prototype,x),c.NEED=!0,i(["delete","has","get","set"],function(e){var t=m.prototype,i=t[e];u(t,e,function(t,n){if(!s(t)||y(t))return i.call(this,t,n);this._f||(this._f=new o);var r=this._f[e](t,n);return"set"==e?this:r})}))},,,,function(t,n){"use strict";t.exports={init:function(){var t=document.querySelector("#page-nav");t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new&&document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")}),yiliaConfig&&yiliaConfig.toc_hide_index&&document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n,r,e,i){var o=function(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}(t),u=function(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}(t)-n;if(u-r<=i){var c=t.$newDom;c||(c=t.cloneNode(!0),(0,a.default)(t,c),(t.$newDom=c).style.position="fixed",c.style.top=(r||u)+"px",c.style.left=o+"px",c.style.zIndex=e||2,c.style.width="100%",c.style.color="#fff"),c.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var f=t.$newDom;f&&(f.style.visibility="hidden")}}function o(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");i(t,document.body.scrollTop,-63,2,0),i(n,document.body.scrollTop,1,3,0)}var f=e(r(163)),a=e((e(r(164)),r(414))),u=e(r(134)),c=e(r(204)),s=r(135);u.default.versions.mobile&&window.screen.width<800&&(function(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var i=t[r];o=n,u=i.getAttribute("href"),c=/\/|index.html/g,o.replace(c,"")===u.replace(c,"")&&(0,f.default)(i,"active")}var o,u,c}(),document.querySelector("#container").addEventListener("scroll",function(t){o()}),window.addEventListener("scroll",function(t){o()}),o()),(0,s.addLoadEvent)(function(){c.default.init()}),t.exports={}},,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object.defineProperty(t,n,{writable:!0,configurable:!0,value:r})}if(r(413),r(209),r(211),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},function(L,t){(function(t){!function(t){"use strict";function o(t,n,r,e){var o,u,c,f,i=n&&n.prototype instanceof h?n:h,a=Object.create(i.prototype),s=new p(e||[]);return a._invoke=(o=t,u=r,c=s,f=_,function(t,n){if(f===E)throw new Error("Generator is already running");if(f===M){if("throw"===t)throw n;return d()}for(c.method=t,c.arg=n;;){var r=c.delegate;if(r){var e=v(r,c);if(e){if(e===P)continue;return e}}if("next"===c.method)c.sent=c._sent=c.arg;else if("throw"===c.method){if(f===_)throw f=M,c.arg;c.dispatchException(c.arg)}else"return"===c.method&&c.abrupt("return",c.arg);f=E;var i=l(o,u,c);if("normal"===i.type){if(f=c.done?M:O,i.arg===P)continue;return{value:i.arg,done:c.done}}"throw"===i.type&&(f=M,c.method="throw",c.arg=i.arg)}}),a}function l(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function h(){}function r(){}function n(){}function e(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function u(c){function f(t,n,r,e){var i=l(c[t],c,n);if("throw"!==i.type){var o=i.arg,u=o.value;return u&&"object"==typeof u&&y.call(u,"__await")?Promise.resolve(u.__await).then(function(t){f("next",t,r,e)},function(t){f("throw",t,r,e)}):Promise.resolve(u).then(function(t){o.value=t,r(o)},e)}e(i.arg)}var n;"object"==typeof t.process&&t.process.domain&&(f=t.process.domain.bind(f)),this._invoke=function(r,e){function t(){return new Promise(function(t,n){f(r,e,t,n)})}return n=n?n.then(t,t):t()}}function v(t,n){var r=t.iterator[n.method];if(r===a){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=a,v(t,n),"throw"===n.method))return P;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return P}var e=l(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,P;var i=e.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=a),n.delegate=null,P):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,P)}function i(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function c(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(i,this),this.reset(!0)}function f(n){if(n){var t=n[b];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,e=function t(){for(;++r<n.length;)if(y.call(n,r))return t.value=n[r],t.done=!1,t;return t.value=a,t.done=!0,t};return e.next=e}}return{next:d}}function d(){return{value:a,done:!0}}var a,s=Object.prototype,y=s.hasOwnProperty,g="function"==typeof Symbol?Symbol:{},b=g.iterator||"@@iterator",x=g.asyncIterator||"@@asyncIterator",m=g.toStringTag||"@@toStringTag",S="object"==typeof L,w=t.regeneratorRuntime;if(w)S&&(L.exports=w);else{(w=t.regeneratorRuntime=S?L.exports:{}).wrap=o;var _="suspendedStart",O="suspendedYield",E="executing",M="completed",P={},j={};j[b]=function(){return this};var F=Object.getPrototypeOf,A=F&&F(F(f([])));A&&A!==s&&y.call(A,b)&&(j=A);var I=n.prototype=h.prototype=Object.create(j);r.prototype=I.constructor=n,n.constructor=r,n[m]=r.displayName="GeneratorFunction",w.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===r||"GeneratorFunction"===(n.displayName||n.name))},w.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,n):(t.__proto__=n,m in t||(t[m]="GeneratorFunction")),t.prototype=Object.create(I),t},w.awrap=function(t){return{__await:t}},e(u.prototype),u.prototype[x]=function(){return this},w.AsyncIterator=u,w.async=function(t,n,r,e){var i=new u(o(t,n,r,e));return w.isGeneratorFunction(n)?i:i.next().then(function(t){return t.done?t.value:i.next()})},e(I),I[m]="Generator",I[b]=function(){return this},I.toString=function(){return"[object Generator]"},w.keys=function(r){var e=[];for(var t in r)e.push(t);return e.reverse(),function t(){for(;e.length;){var n=e.pop();if(n in r)return t.value=n,t.done=!1,t}return t.done=!0,t}},w.values=f,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=a,this.done=!1,this.delegate=null,this.method="next",this.arg=a,this.tryEntries.forEach(c),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=a)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(r){function t(t,n){return o.type="throw",o.arg=r,e.next=t,n&&(e.method="next",e.arg=a),!!n}if(this.done)throw r;for(var e=this,n=this.tryEntries.length-1;0<=n;--n){var i=this.tryEntries[n],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;0<=r;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,P):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),P},finish:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),c(r),P}},catch:function(t){for(var n=this.tryEntries.length-1;0<=n;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;c(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:f(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=a),P}}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(t,function(){return this}())},,function(t,n,r){r(221),t.exports=r(46).RegExp.escape},,,,function(t,n,r){var e=r(5),i=r(123),o=r(7)("species");t.exports=function(t){var n;return i(t)&&("function"!=typeof(n=t.constructor)||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&(null===(n=n[o])&&(n=void 0))),void 0===n?Array:n}},function(t,n,r){"use strict";var e=r(4),i=Date.prototype.getTime,o=Date.prototype.toISOString,u=function(t){return 9<t?t:"0"+t};t.exports=e(function(){return"0385-07-25T07:06:39.999Z"!=o.call(new Date(-5e13-1))})||!e(function(){o.call(new Date(NaN))})?function(){if(!isFinite(i.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":9999<n?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(99<r?r:"0"+u(r))+"Z"}:o},function(t,n,r){"use strict";var e=r(2),i=r(53);t.exports=function(t){if("string"!==t&&"number"!==t&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),"number"!=t)}},function(t,n,r){var c=r(74),f=r(127),a=r(117);t.exports=function(t){var n=c(t),r=f.f;if(r)for(var e,i=r(t),o=a.f,u=0;i.length>u;)o.call(t,e=i[u++])&&n.push(e);return n}},function(t,n,r){t.exports=r(118)("native-function-to-string",Function.toString)},function(t,n){t.exports=function(n,r){var e=r===Object(r)?function(t){return r[t]}:r;return function(t){return String(t).replace(n,e)}}},function(t,n,r){var e=r(1),i=r(220)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(166)}),r(67)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(50)(4);e(e.P+e.F*!r(48)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(137)}),r(67)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(50)(2);e(e.P+e.F*!r(48)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)(o)},function(t,n,r){"use strict";var e=r(1),i=r(50)(0),o=r(48)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var h=r(47),e=r(1),v=r(17),p=r(177),d=r(145),y=r(8),g=r(139),b=r(161);e(e.S+e.F*!r(125)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,e,i,o=v(t),u="function"==typeof this?this:Array,c=arguments.length,f=1<c?arguments[1]:void 0,a=void 0!==f,s=0,l=b(o);if(a&&(f=h(f,2<c?arguments[2]:void 0,2)),null==l||u==Array&&d(l))for(r=new u(n=y(o.length));s<n;s++)g(r,s,a?f(o[s],s):o[s]);else for(i=l.call(o),r=new u;!(e=i.next()).done;s++)g(r,s,a?p(i,f,[e.value,s],!0):e.value);return r.length=s,r}})},function(t,n,r){"use strict";var e=r(1),i=r(120)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(48)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(123)})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=[].join;e(e.P+e.F*(r(116)!=Object||!r(48)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(33),o=r(49),u=r(8),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(48)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(1<arguments.length&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);0<=e;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(1);e(e.P+e.F*!r(48)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(139);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);t<n;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(168);e(e.P+e.F*!r(48)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(143),a=r(45),s=r(78),l=r(8),h=[].slice;e(e.P+e.F*r(4)(function(){i&&h.call(i)}),"Array",{slice:function(t,n){var r=l(this.length),e=a(this);if(n=void 0===n?r:n,"Array"==e)return h.call(this,t,n);for(var i=s(t,r),o=s(n,r),u=l(o-i),c=new Array(u),f=0;f<u;f++)c[f]="String"==e?this.charAt(i+f):this[i+f];return c}})},function(t,n,r){"use strict";var e=r(1),i=r(50)(3);e(e.P+e.F*!r(48)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(21),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(48)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(77)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){var e=r(1),i=r(216);e(e.P+e.F*(Date.prototype.toISOString!==i),"Date",{toISOString:i})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(26)(i,e,r(217))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(27)(e,o,function(){var t=c.call(this);return t==t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(169)})},function(t,n,r){"use strict";var e=r(5),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=Function.prototype,o=/^\s*function ([^ (]*)/;"name"in i||r(10)&&e(i,"name",{configurable:!0,get:function(){try{return(""+this).match(o)[1]}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(180),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:94906265.62425156<t?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){var e=r(1),i=Math.asinh;e(e.S+e.F*!(i&&0<1/i(0)),"Math",{asinh:function t(n){return isFinite(n=+n)&&0!=n?n<0?-t(-n):Math.log(n+Math.sqrt(n*n+1)):n}})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(149);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(148);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1);e(e.S,"Math",{fround:r(179)})},function(t,n,r){var e=r(1),f=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,i=0,o=0,u=arguments.length,c=0;o<u;)c<(r=f(arguments[o++]))?(i=i*(e=c/r)*e+1,c=r):0<r?i+=(e=r/c)*e:i+=r;return c===1/0?1/0:c*Math.sqrt(i)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)*Math.LOG10E}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(180)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(149)})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(148),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(0<t?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(30),o=r(45),u=r(144),s=r(53),c=r(4),f=r(73).f,a=r(31).f,l=r(11).f,h=r(84).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(72)(y))==v,b="trim"in String.prototype,x=function(t){var n=s(t,!1);if("string"==typeof n&&2<n.length){var r,e,i,o=(n=b?n.trim():h(n,3)).charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,c=n.slice(2),f=0,a=c.length;f<a;f++)if((u=c.charCodeAt(f))<48||i<u)return NaN;return parseInt(c,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?c(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(x(n)),r,p):x(n)};for(var m,S=r(10)?f(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),w=0;S.length>w;w++)i(d,m=S[w])&&!i(p,m)&&l(p,m,a(d,m));(p.prototype=y).constructor=p,r(27)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(176)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(176),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(188);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),a=r(49),s=r(165),l=r(156),i=1..toFixed,o=Math.floor,u=[0,0,0,0,0,0],h="Number.toFixed: incorrect invocation!",v=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*u[r],u[r]=e%1e7,e=o(e/1e7)},p=function(t){for(var n=6,r=0;0<=--n;)r+=u[n],u[n]=o(r/t),r=r%t*1e7},d=function(){for(var t=6,n="";0<=--t;)if(""!==n||0===t||0!==u[t]){var r=String(u[t]);n=""===n?r:n+l.call("0",7-r.length)+r}return n},y=function(t,n,r){return 0===n?r:n%2==1?y(t,n-1,r*t):y(t*t,n/2,r)};e(e.P+e.F*(!!i&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){i.call({})})),"Number",{toFixed:function(t){var n,r,e,i,o=s(this,h),u=a(t),c="",f="0";if(u<0||20<u)throw RangeError(h);if(o!=o)return"NaN";if(o<=-1e21||1e21<=o)return String(o);if(o<0&&(c="-",o=-o),1e-21<o)if(r=(n=function(t){for(var n=0,r=t;4096<=r;)n+=12,r/=4096;for(;2<=r;)n+=1,r/=2;return n}(o*y(2,69,1))-69)<0?o*y(2,-n,1):o/y(2,n,1),r*=4503599627370496,0<(n=52-n)){for(v(0,r),e=u;7<=e;)v(1e7,0),e-=7;for(v(y(10,e,1),0),e=n-1;23<=e;)p(1<<23),e-=23;p(1<<e),v(1,1),p(2),f=d()}else v(0,r),v(1<<-n,0),f=d()+l.call("0",u);return f=0<u?c+((i=f.length)<=u?"0."+l.call("0",u-i)+f:f.slice(0,i-u)+"."+f.slice(i-u)):c+f}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(165),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(182)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(72)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(183)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("freeze",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(33),i=r(31).f;r(52)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(52)("getOwnPropertyNames",function(){return r(184).f})},function(t,n,r){var e=r(17),i=r(32);r(52)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5);r(52)("isExtensible",function(n){return function(t){return!!e(t)&&(!n||n(t))}})},function(t,n,r){var e=r(5);r(52)("isFrozen",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(5);r(52)("isSealed",function(n){return function(t){return!e(t)||!!n&&n(t)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(192)})},function(t,n,r){var e=r(17),i=r(74);r(52)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("preventExtensions",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(5),i=r(69).onFreeze;r(52)("seal",function(n){return function(t){return n&&e(t)?n(i(t)):t}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(153).set})},function(t,n,r){"use strict";var e=r(81),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(27)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(188);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(189);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u,c=r(68),f=r(3),a=r(47),s=r(81),l=r(1),h=r(5),v=r(21),p=r(70),d=r(71),y=r(119),g=r(158).set,b=r(150)(),x=r(151),m=r(190),S=r(133),w=r(191),_="Promise",O=f.TypeError,E=f.process,M=E&&E.versions,P=M&&M.v8||"",j=f[_],F="process"==s(E),A=function(){},I=i=x.f,L=!!function(){try{var t=j.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(A,A)};return(F||"function"==typeof PromiseRejectionEvent)&&t.then(A)instanceof n&&0!==P.indexOf("6.6")&&-1===S.indexOf("Chrome/66")}catch(t){}}(),N=function(t){var n;return!(!h(t)||"function"!=typeof(n=t.then))&&n},T=function(s,r){if(!s._n){s._n=!0;var e=s._c;b(function(){for(var f=s._v,a=1==s._s,t=0,n=function(t){var n,r,e,i=a?t.ok:t.fail,o=t.resolve,u=t.reject,c=t.domain;try{i?(a||(2==s._h&&C(s),s._h=1),!0===i?n=f:(c&&c.enter(),n=i(f),c&&(c.exit(),e=!0)),n===t.promise?u(O("Promise-chain cycle")):(r=N(n))?r.call(n,o,u):o(n)):u(f)}catch(t){c&&!e&&c.exit(),u(t)}};e.length>t;)n(e[t++]);s._c=[],s._n=!1,r&&!s._h&&k(s)})}},k=function(o){g.call(f,function(){var t,n,r,e=o._v,i=R(o);if(i&&(t=m(function(){F?E.emit("unhandledRejection",e,o):(n=f.onunhandledrejection)?n({promise:o,reason:e}):(r=f.console)&&r.error&&r.error("Unhandled promise rejection",e)}),o._h=F||R(o)?2:1),o._a=void 0,i&&t.e)throw t.v})},R=function(t){return 1!==t._h&&0===(t._a||t._c).length},C=function(n){g.call(f,function(){var t;F?E.emit("rejectionHandled",n):(t=f.onrejectionhandled)&&t({promise:n,reason:n._v})})},D=function(t){var n=this;n._d||(n._d=!0,(n=n._w||n)._v=t,n._s=2,n._a||(n._a=n._c.slice()),T(n,!0))},G=function(t){var r,e=this;if(!e._d){e._d=!0,e=e._w||e;try{if(e===t)throw O("Promise can't be resolved itself");(r=N(t))?b(function(){var n={_w:e,_d:!1};try{r.call(t,a(G,n,1),a(D,n,1))}catch(t){D.call(n,t)}}):(e._v=t,e._s=1,T(e,!1))}catch(t){D.call({_w:e,_d:!1},t)}}};L||(j=function(t){p(this,j,_,"_h"),v(t),e.call(this);try{t(a(G,this,1),a(D,this,1))}catch(t){D.call(this,t)}},(e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=r(76)(j.prototype,{then:function(t,n){var r=I(y(this,j));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=F?E.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&T(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new e;this.promise=t,this.resolve=a(G,t,1),this.reject=a(D,t,1)},x.f=I=function(t){return t===j||t===u?new o(t):i(t)}),l(l.G+l.W+l.F*!L,{Promise:j}),r(83)(j,_),r(77)(_),u=r(46)[_],l(l.S+l.F*!L,_,{reject:function(t){var n=I(this);return(0,n.reject)(t),n.promise}}),l(l.S+l.F*(c||!L),_,{resolve:function(t){return w(c&&this===u?j:this,t)}}),l(l.S+l.F*!(L&&r(125)(function(t){j.all(t).catch(A)})),_,{all:function(t){var u=this,n=I(u),c=n.resolve,f=n.reject,r=m(function(){var e=[],i=0,o=1;d(t,!1,function(t){var n=i++,r=!1;e.push(void 0),o++,u.resolve(t).then(function(t){r||(r=!0,e[n]=t,--o||c(e))},f)}),--o||c(e)});return r.e&&f(r.v),n.promise},race:function(t){var n=this,r=I(n),e=r.reject,i=m(function(){d(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i.e&&e(i.v),r.promise}})},function(t,n,r){var e=r(1),o=r(21),u=r(2),c=(r(3).Reflect||{}).apply,f=Function.apply;e(e.S+e.F*!r(4)(function(){c(function(){})}),"Reflect",{apply:function(t,n,r){var e=o(t),i=u(r);return c?c(e,n,i):f.call(e,n,i)}})},function(t,n,r){var e=r(1),c=r(72),f=r(21),a=r(2),s=r(5),i=r(4),l=r(169),h=(r(3).Reflect||{}).construct,v=i(function(){function t(){}return!(h(function(){},[],t)instanceof t)}),p=!i(function(){h(function(){})});e(e.S+e.F*(v||p),"Reflect",{construct:function(t,n){f(t),a(n);var r=arguments.length<3?t:f(arguments[2]);if(p&&!v)return h(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(l.apply(t,e))}var i=r.prototype,o=c(s(i)?i:Object.prototype),u=Function.apply.call(t,o,n);return s(u)?u:o}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(53);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(146)(o,"Object",function(){var t,n=this._k;do{if(this._i>=n.length)return{value:void 0,done:!0}}while(!((t=n[this._i++])in this._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){var u=r(31),c=r(32),f=r(30),e=r(1),a=r(5),s=r(2);e(e.S,"Reflect",{get:function t(n,r){var e,i,o=arguments.length<3?n:arguments[2];return s(n)===o?n[r]:(e=u.f(n,r))?f(e,"value")?e.value:void 0!==e.get?e.get.call(o):void 0:a(i=c(n))?t(i,r,o):void 0}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(187)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(153);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){var f=r(11),a=r(31),s=r(32),l=r(30),e=r(1),h=r(75),v=r(2),p=r(5);e(e.S,"Reflect",{set:function t(n,r,e){var i,o,u=arguments.length<4?n:arguments[3],c=a.f(v(n),r);if(!c){if(p(o=s(n)))return t(o,r,e,u);c=h(0)}if(l(c,"value")){if(!1===c.writable||!p(u))return!1;if(i=a.f(u,r)){if(i.get||i.set||!1===i.writable)return!1;i.value=e,f.f(u,r,i)}else f.f(u,r,h(0,e));return!0}return void 0!==c.set&&(c.set.call(u,e),!0)}})},function(t,n,r){var e=r(3),o=r(144),i=r(11).f,u=r(73).f,c=r(124),f=r(115),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),i=void 0===n;return!r&&e&&t.constructor===a&&i?t:o(p?new s(e&&!i?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&i?f.call(t):n),r?this:l,a)};for(var d=function(n){n in a||i(a,n,{configurable:!0,get:function(){return s[n]},set:function(t){s[n]=t}})},y=u(s),g=0;y.length>g;)d(y[g++]);(l.constructor=a).prototype=l,r(27)(e,"RegExp",a)}r(77)("RegExp")},function(t,n,r){"use strict";var l=r(2),h=r(8),v=r(136),p=r(128);r(122)("match",1,function(e,i,a,s){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=s(a,t,this);if(n.done)return n.value;var r=l(t),e=String(this);if(!r.global)return p(r,e);for(var i,o=r.unicode,u=[],c=r.lastIndex=0;null!==(i=p(r,e));){var f=String(i[0]);""===(u[c]=f)&&(r.lastIndex=v(e,h(r.lastIndex),o)),c++}return 0===c?null:u}]})},function(t,n,r){"use strict";var O=r(2),e=r(17),E=r(8),M=r(49),P=r(136),j=r(128),F=Math.max,A=Math.min,h=Math.floor,v=/\$([$&`']|\d\d?|<[^>]*>)/g,p=/\$([$&`']|\d\d?)/g;r(122)("replace",2,function(i,o,S,w){function _(o,u,c,f,a,t){var s=c+o.length,l=f.length,n=p;return void 0!==a&&(a=e(a),n=v),S.call(t,n,function(t,n){var r;switch(n.charAt(0)){case"$":return"$";case"&":return o;case"`":return u.slice(0,c);case"'":return u.slice(s);case"<":r=a[n.slice(1,-1)];break;default:var e=+n;if(0===e)return t;if(l<e){var i=h(e/10);return 0===i?t:i<=l?void 0===f[i-1]?n.charAt(1):f[i-1]+n.charAt(1):t}r=f[e-1]}return void 0===r?"":r})}return[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):S.call(String(r),t,n)},function(t,n){var r=w(S,t,this,n);if(r.done)return r.value;var e=O(t),i=String(this),o="function"==typeof n;o||(n=String(n));var u,c=e.global;if(c){var f=e.unicode;e.lastIndex=0}for(var a=[];;){var s=j(e,i);if(null===s)break;if(a.push(s),!c)break;""===String(s[0])&&(e.lastIndex=P(i,E(e.lastIndex),f))}for(var l="",h=0,v=0;v<a.length;v++){s=a[v];for(var p=String(s[0]),d=F(A(M(s.index),i.length),0),y=[],g=1;g<s.length;g++)y.push(void 0===(u=s[g])?u:String(u));var b=s.groups;if(o){var x=[p].concat(y,d,i);void 0!==b&&x.push(b);var m=String(n.apply(void 0,x))}else m=_(p,i,d,y,b,n);h<=d&&(l+=i.slice(h,d)+m,h=d+p.length)}return l+i.slice(h)}]})},function(t,n,r){"use strict";var f=r(2),a=r(192),s=r(128);r(122)("search",1,function(e,i,u,c){return[function(t){var n=e(this),r=null==t?void 0:t[i];return void 0!==r?r.call(t,n):new RegExp(t)[i](String(n))},function(t){var n=c(u,t,this);if(n.done)return n.value;var r=f(t),e=String(this),i=r.lastIndex;a(i,0)||(r.lastIndex=0);var o=s(r,e);return a(r.lastIndex,i)||(r.lastIndex=i),null===o?-1:o.index}]})},function(t,n,r){"use strict";var l=r(124),x=r(2),m=r(119),S=r(136),w=r(8),_=r(128),h=r(152),e=r(4),O=Math.min,v=[].push,u="split",p="length",d="lastIndex",E=4294967295,M=!e(function(){RegExp(E,"y")});r(122)("split",2,function(i,o,y,g){var b;return b="c"=="abbc"[u](/(b)*/)[1]||4!="test"[u](/(?:)/,-1)[p]||2!="ab"[u](/(?:ab)*/)[p]||4!="."[u](/(.?)(.?)/)[p]||1<"."[u](/()()/)[p]||""[u](/.?/)[p]?function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!l(t))return y.call(r,t,n);for(var e,i,o,u=[],c=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),f=0,a=void 0===n?E:n>>>0,s=new RegExp(t.source,c+"g");(e=h.call(s,r))&&!(f<(i=s[d])&&(u.push(r.slice(f,e.index)),1<e[p]&&e.index<r[p]&&v.apply(u,e.slice(1)),o=e[0][p],f=i,u[p]>=a));)s[d]===e.index&&s[d]++;return f===r[p]?!o&&s.test("")||u.push(""):u.push(r.slice(f)),u[p]>a?u.slice(0,a):u}:"0"[u](void 0,0)[p]?function(t,n){return void 0===t&&0===n?[]:y.call(this,t,n)}:y,[function(t,n){var r=i(this),e=null==t?void 0:t[o];return void 0!==e?e.call(t,r,n):b.call(String(r),t,n)},function(t,n){var r=g(b,t,this,n,b!==y);if(r.done)return r.value;var e=x(t),i=String(this),o=m(e,RegExp),u=e.unicode,c=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(M?"y":"g"),f=new o(M?e:"^(?:"+e.source+")",c),a=void 0===n?E:n>>>0;if(0===a)return[];if(0===i.length)return null===_(f,i)?[i]:[];for(var s=0,l=0,h=[];l<i.length;){f.lastIndex=M?l:0;var v,p=_(f,M?i:i.slice(l));if(null===p||(v=O(w(f.lastIndex+(M?0:l)),i.length))===s)l=S(i,l,u);else{if(h.push(i.slice(s,l)),h.length===a)return h;for(var d=1;d<=p.length-1;d++)if(h.push(p[d]),h.length===a)return h;l=s=v}}return h.push(i.slice(s)),h}]})},function(t,n,r){"use strict";r(198);var e=r(2),i=r(115),o=r(10),u="toString",c=/./[u],f=function(t){r(27)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(28)("anchor",function(n){return function(t){return n(this,"a","name",t)}})},function(t,n,r){"use strict";r(28)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(28)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(28)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),u=r(8),c=r(155),f="endsWith",a=""[f];e(e.P+e.F*r(142)(f),"String",{endsWith:function(t){var n=c(this,t,f),r=1<arguments.length?arguments[1]:void 0,e=u(n.length),i=void 0===r?e:Math.min(u(r),e),o=String(t);return a?a.call(n,o,i):n.slice(i-o.length,i)===o}})},function(t,n,r){"use strict";r(28)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(28)("fontcolor",function(n){return function(t){return n(this,"font","color",t)}})},function(t,n,r){"use strict";r(28)("fontsize",function(n){return function(t){return n(this,"font","size",t)}})},function(t,n,r){var e=r(1),o=r(78),u=String.fromCharCode,i=String.fromCodePoint;e(e.S+e.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,i=0;i<e;){if(n=+arguments[i++],o(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?u(n):u(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(155);e(e.P+e.F*r(142)("includes"),"String",{includes:function(t){return!!~i(this,t,"includes").indexOf(t,1<arguments.length?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(28)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(131)(!0);r(147)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(28)("link",function(n){return function(t){return n(this,"a","href",t)}})},function(t,n,r){var e=r(1),u=r(33),c=r(8);e(e.S,"String",{raw:function(t){for(var n=u(t.raw),r=c(n.length),e=arguments.length,i=[],o=0;o<r;)i.push(String(n[o++])),o<e&&i.push(String(arguments[o]));return i.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(156)})},function(t,n,r){"use strict";r(28)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(8),o=r(155),u="startsWith",c=""[u];e(e.P+e.F*r(142)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(1<arguments.length?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(28)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(28)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(28)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(84)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),u=r(30),i=r(10),o=r(1),c=r(27),f=r(69).KEY,a=r(4),s=r(118),l=r(83),h=r(79),v=r(7),p=r(195),d=r(160),y=r(218),g=r(123),b=r(2),x=r(5),m=r(17),S=r(33),w=r(53),_=r(75),O=r(72),E=r(184),M=r(31),P=r(127),j=r(11),F=r(74),A=M.f,I=j.f,L=E.f,N=e.Symbol,T=e.JSON,k=T&&T.stringify,R="prototype",C=v("_hidden"),D=v("toPrimitive"),G={}.propertyIsEnumerable,W=s("symbol-registry"),U=s("symbols"),V=s("op-symbols"),B=Object[R],q="function"==typeof N&&!!P.f,z=e.QObject,K=!z||!z[R]||!z[R].findChild,H=i&&a(function(){return 7!=O(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=A(B,n);e&&delete B[n],I(t,n,r),e&&t!==B&&I(B,n,e)}:I,J=function(t){var n=U[t]=O(N[R]);return n._k=t,n},$=q&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===B&&Y(V,n,r),b(t),n=w(n,!0),b(r),u(U,n)?(r.enumerable?(u(t,C)&&t[C][n]&&(t[C][n]=!1),r=O(r,{enumerable:_(0,!1)})):(u(t,C)||I(t,C,_(1,{})),t[C][n]=!0),H(t,n,r)):I(t,n,r)},X=function(t,n){b(t);for(var r,e=y(n=S(n)),i=0,o=e.length;i<o;)Y(t,r=e[i++],n[r]);return t},Q=function(t){var n=G.call(this,t=w(t,!0));return!(this===B&&u(U,t)&&!u(V,t))&&(!(n||!u(this,t)||!u(U,t)||u(this,C)&&this[C][t])||n)},Z=function(t,n){if(t=S(t),n=w(n,!0),t!==B||!u(U,n)||u(V,n)){var r=A(t,n);return!r||!u(U,n)||u(t,C)&&t[C][n]||(r.enumerable=!0),r}},tt=function(t){for(var n,r=L(S(t)),e=[],i=0;r.length>i;)u(U,n=r[i++])||n==C||n==f||e.push(n);return e},nt=function(t){for(var n,r=t===B,e=L(r?V:S(t)),i=[],o=0;e.length>o;)!u(U,n=e[o++])||r&&!u(B,n)||i.push(U[n]);return i};q||(c((N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var n=h(0<arguments.length?arguments[0]:void 0),r=function(t){this===B&&r.call(V,t),u(this,C)&&u(this[C],n)&&(this[C][n]=!1),H(this,n,_(1,t))};return i&&K&&H(B,n,{configurable:!0,set:r}),J(n)})[R],"toString",function(){return this._k}),M.f=Z,j.f=Y,r(73).f=E.f=tt,r(117).f=Q,P.f=nt,i&&!r(68)&&c(B,"propertyIsEnumerable",Q,!0),p.f=function(t){return J(v(t))}),o(o.G+o.W+o.F*!q,{Symbol:N});for(var rt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;rt.length>et;)v(rt[et++]);for(var it=F(v.store),ot=0;it.length>ot;)d(it[ot++]);o(o.S+o.F*!q,"Symbol",{for:function(t){return u(W,t+="")?W[t]:W[t]=N(t)},keyFor:function(t){if(!$(t))throw TypeError(t+" is not a symbol!");for(var n in W)if(W[n]===t)return n},useSetter:function(){K=!0},useSimple:function(){K=!1}}),o(o.S+o.F*!q,"Object",{create:function(t,n){return void 0===n?O(t):X(O(t),n)},defineProperty:Y,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:tt,getOwnPropertySymbols:nt});var ut=a(function(){P.f(1)});o(o.S+o.F*ut,"Object",{getOwnPropertySymbols:function(t){return P.f(m(t))}}),T&&o(o.S+o.F*(!q||a(function(){var t=N();return"[null]"!=k([t])||"{}"!=k({a:t})||"{}"!=k(Object(t))})),"JSON",{stringify:function(t){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);if(r=n=e[1],(x(n)||void 0!==t)&&!$(t))return g(n)||(n=function(t,n){if("function"==typeof r&&(n=r.call(this,t,n)),!$(n))return n}),e[1]=n,k.apply(T,e)}}),N[R][D]||r(26)(N[R],D,N[R].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(132),o=r(159),a=r(2),s=r(78),l=r(8),u=r(5),c=r(3).ArrayBuffer,h=r(119),v=o.ArrayBuffer,p=o.DataView,f=i.ABV&&c.isView,d=v.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(c!==v),{ArrayBuffer:v}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return f&&f(t)||u(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new v(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(a(this),t);for(var r=a(this).byteLength,e=s(t,r),i=s(void 0===n?r:n,r),o=new(h(this,v))(l(i-e)),u=new p(this),c=new p(o),f=0;e<i;)c.setUint8(f++,u.getUint8(e++));return o}}),r(77)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(132).ABV,{DataView:r(159).DataView})},function(t,n,r){r(57)("Float32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Float64",8,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Int8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint16",2,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint32",4,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}})},function(t,n,r){r(57)("Uint8",1,function(e){return function(t,n,r){return e(this,t,n,r)}},!0)},function(t,n,r){"use strict";var e=r(172),i=r(80);r(121)("WeakSet",function(t){return function(){return t(this,0<arguments.length?arguments[0]:void 0)}},{add:function(t){return e.def(i(this,"WeakSet"),t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(21),f=r(138);e(e.P,"Array",{flatMap:function(t){var n,r,e=o(this);return c(t),n=u(e.length),r=f(e,0),i(r,e,e,n,0,1,t,arguments[1]),r}}),r(67)("flatMap")},function(t,n,r){"use strict";var e=r(1),i=r(173),o=r(17),u=r(8),c=r(49),f=r(138);e(e.P,"Array",{flatten:function(){var t=arguments[0],n=o(this),r=u(n.length),e=f(n,0);return i(e,n,n,r,0,void 0===t?1:c(t)),e}}),r(67)("flatten")},function(t,n,r){"use strict";var e=r(1),i=r(120)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0)}}),r(67)("includes")},function(t,n,r){var e=r(1),i=r(150)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.G,{global:r(3)})},function(t,n,r){r(129)("Map")},function(t,n,r){r(130)("Map")},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(171)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{clamp:function(t,n,r){return Math.min(r,Math.max(n,t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{DEG_PER_RAD:Math.PI/180})},function(t,n,r){var e=r(1),i=180/Math.PI;e(e.S,"Math",{degrees:function(t){return t*i}})},function(t,n,r){var e=r(1),o=r(181),u=r(179);e(e.S,"Math",{fscale:function(t,n,r,e,i){return u(o(t,n,r,e,i))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)+(e>>>0)+((i&o|(i|o)&~(i+o>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>16,c=e>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>16)+((i*c>>>0)+(65535&f)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=r>>>0;return(n>>>0)-(e>>>0)-((~i&o|~(i^o)&i-o>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{RAD_PER_DEG:180/Math.PI})},function(t,n,r){var e=r(1),i=Math.PI/180;e(e.S,"Math",{radians:function(t){return t*i}})},function(t,n,r){var e=r(1);e(e.S,"Math",{scale:r(181)})},function(t,n,r){var e=r(1);e(e.S,"Math",{signbit:function(t){return(t=+t)!=t?t:0==t?1/t==1/0:0<t}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=+t,e=+n,i=65535&r,o=65535&e,u=r>>>16,c=e>>>16,f=(u*o>>>0)+(i*o>>>16);return u*c+(f>>>16)+((i*c>>>0)+(65535&f)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(21),u=r(11);r(10)&&e(e.P+r(126),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(186)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),f=r(187),a=r(33),s=r(31),l=r(139);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r,e=a(t),i=s.f,o=f(e),u={},c=0;o.length>c;)void 0!==(r=i(e,n=o[c++]))&&l(u,n,r);return u}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(53),u=r(32),c=r(31).f;r(10)&&e(e.P+r(126),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(186)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),o=r(3),u=r(46),i=r(150)(),c=r(7)("observable"),f=r(21),a=r(2),s=r(70),l=r(76),h=r(26),v=r(71),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},x=function(t,n){a(t),this._c=void 0,this._o=t,t=new m(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};x.prototype=l({},{unsubscribe:function(){b(this)}});var m=function(t){this._s=t};m.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var S=function(t){s(this,S,"Observable","_f")._f=f(t)};l(S.prototype,{subscribe:function(t){return new x(t,this._f)},forEach:function(e){var i=this;return new(u.Promise||o.Promise)(function(t,n){f(e);var r=i.subscribe({next:function(t){try{return e(t)}catch(t){n(t),r.unsubscribe()}},error:n,complete:t})})}}),l(S,{from:function(t){var n="function"==typeof this?this:S,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return i(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,e=new Array(n);t<n;)e[t]=arguments[t++];return new("function"==typeof this?this:S)(function(n){var r=!1;return i(function(){if(!r){for(var t=0;t<e.length;++t)if(n.next(e[t]),r)return;n.complete()}}),function(){r=!0}})}}),h(S.prototype,c,function(){return this}),e(e.G,{Observable:S}),r(77)("Observable")},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(3),u=r(119),c=r(191);e(e.P+e.R,"Promise",{finally:function(n){var r=u(this,i.Promise||o.Promise),t="function"==typeof n;return this.then(t?function(t){return c(r,n()).then(function(){return t})}:n,t?function(t){return c(r,n()).then(function(){throw t})}:n)}})},function(t,n,r){"use strict";var e=r(1),i=r(151),o=r(190);e(e.S,"Promise",{try:function(t){var n=i.f(this),r=o(t);return(r.e?n.reject:n.resolve)(r.v),n.promise}})},function(t,n,r){var e=r(56),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(56),o=r(2),u=e.key,c=e.map,f=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:u(arguments[2]),e=c(o(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var i=f.get(n);return i.delete(r),!!i.size||f.delete(n)}})},function(t,n,r){var o=r(199),u=r(167),e=r(56),i=r(2),c=r(32),f=e.keys,a=e.key,s=function(t,n){var r=f(t,n),e=c(t);if(null===e)return r;var i=s(e,n);return i.length?r.length?u(new o(r.concat(i))):i:r};e.exp({getMetadataKeys:function(t){return s(i(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(56),i=r(2),o=r(21),u=e.key,c=e.set;e.exp({metadata:function(r,e){return function(t,n){c(r,e,(void 0!==n?i:o)(t),u(n))}}})},function(t,n,r){r(129)("Set")},function(t,n,r){r(130)("Set")},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(171)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(131)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(51),o=r(8),u=r(124),c=r(115),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(146)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padEnd:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(193),o=r(133),u=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(o);e(e.P+e.F*u,"String",{padStart:function(t){return i(this,t,1<arguments.length?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(84)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(84)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(160)("asyncIterator")},function(t,n,r){r(160)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){r(129)("WeakMap")},function(t,n,r){r(130)("WeakMap")},function(t,n,r){r(129)("WeakSet")},function(t,n,r){r(130)("WeakSet")},function(t,n,r){for(var e=r(162),i=r(74),o=r(27),u=r(3),c=r(26),f=r(82),a=r(7),s=a("iterator"),l=a("toStringTag"),h=f.Array,v={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=i(v),d=0;d<p.length;d++){var y,g=p[d],b=v[g],x=u[g],m=x&&x.prototype;if(m&&(m[s]||c(m,s,h),m[l]||c(m,l,g),f[g]=h,b))for(y in e)m[y]||o(m,y,e[y],!0)}},function(t,n,r){var e=r(1),i=r(158);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(133),u=[].slice,c=/MSIE .\./.test(o),f=function(i){return function(t,n){var r=2<arguments.length,e=!!r&&u.call(arguments,2);return i(r?function(){("function"==typeof t?t:Function(t)).apply(this,e)}:t,n)}};i(i.G+i.B+i.F*c,{setTimeout:f(e.setTimeout),setInterval:f(e.setInterval)})},function(t,n,r){r(341),r(280),r(282),r(281),r(284),r(286),r(291),r(285),r(283),r(293),r(292),r(288),r(289),r(287),r(279),r(290),r(294),r(295),r(247),r(249),r(248),r(297),r(296),r(267),r(277),r(278),r(268),r(269),r(270),r(271),r(272),r(273),r(274),r(275),r(276),r(250),r(251),r(252),r(253),r(254),r(255),r(256),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(266),r(328),r(333),r(340),r(331),r(323),r(324),r(329),r(334),r(336),r(319),r(320),r(321),r(322),r(325),r(326),r(327),r(330),r(332),r(335),r(337),r(338),r(339),r(242),r(244),r(243),r(246),r(245),r(231),r(229),r(235),r(232),r(238),r(240),r(228),r(234),r(225),r(239),r(223),r(237),r(236),r(230),r(233),r(222),r(224),r(227),r(226),r(241),r(162),r(313),r(197),r(318),r(198),r(314),r(315),r(316),r(317),r(298),r(196),r(199),r(200),r(353),r(342),r(343),r(348),r(351),r(352),r(346),r(349),r(347),r(350),r(344),r(345),r(299),r(300),r(301),r(302),r(303),r(306),r(304),r(305),r(307),r(308),r(309),r(310),r(312),r(311),r(356),r(354),r(355),r(397),r(400),r(399),r(401),r(402),r(398),r(403),r(404),r(378),r(381),r(377),r(375),r(376),r(379),r(380),r(362),r(396),r(361),r(395),r(407),r(409),r(360),r(394),r(406),r(408),r(359),r(405),r(358),r(363),r(364),r(365),r(366),r(367),r(369),r(368),r(370),r(371),r(372),r(374),r(373),r(383),r(384),r(385),r(386),r(388),r(387),r(390),r(389),r(391),r(392),r(393),r(357),r(382),r(412),r(411),r(410),t.exports=r(46)},function(t,n){t.exports=function(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}}])</script><script src="/./main.a5fda8.js"></script><script>!function(){var e,t;e="/slider.27463f.js",t=document.createElement("script"),document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}()</script>



<!--  -->

<script>
  /* 标签页标题切换 */
  var originTitle = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function () {
    if (document.hidden) {
      document.title = "Do Something" + originTitle;
      clearTimeout(titleTime);
    } else {
      document.title = "Do Something" + originTitle;
      titleTime = setTimeout(function () {
        document.title = originTitle;
      }, 2000);
    }
  });
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">iOS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Book</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Fastlane</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">自动化</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">flutter</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">源码</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">性能</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Go</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">语言基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">RAC+MVVM</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">RXSwift</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Will Power</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Job Interview</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Written examination</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">知识结构</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">简历</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">动画</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">计算机基础</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">内购</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">错误</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
        
          
  	  		<div class="aboutme-wrap" id="aboutme">主要涉及技术：<br>iOS devloper <br>flutter<br>Go<br>more...<br></div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
<script type="text/javascript" src="/plugins/TweenMax/TweenMax.min.js"></script>
<script type="text/javascript" src="/plugins/TweenMax/HoverImg.js"></script>

<script>


  var hoverEffect = {
    "subNav": ".left-col .social a"
  }


  for (var x in hoverEffect) {
    // 初始化data-img属性值
    let $em = document.querySelectorAll(hoverEffect[x]);
    $em.forEach(($a) => {
      //console.log($a.href);
      if (isImageType($a.href)) {
        $a.setAttribute("data-img", $a.href)
      }
    })
    // 实现悬停元素预览图片效果
    let $a = document.querySelectorAll(hoverEffect[x] + "[data-img]");
    $a.forEach(($em) => {
      new HoverImgFx1($em)
    })
  }

</script>

  
<script type="text/javascript" src="/plugins/activate-power-mode/activate-power-mode.js"></script>
<script>
  POWERMODE.colorful = true; // make power mode colorful
  POWERMODE.shake = false; // turn off shake
  document.body.addEventListener('input', POWERMODE);
</script>

  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
    <script type="text/javascript" src="/plugins/live2d-widget.js/L2Dwidget.min.js"></script>
<script type="text/javascript">
  /**
   * 完整配置请参考：https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init
   */
  var pluginModelPath = "assets/", // 模型的文件路径，无需更改
    pluginRootPath = "/live2d_models/"; // 插件的路径，无需更改
  //特定的模型json文件名称
  var modelPathJson = {
    "epsilon2_1": "Epsilon2.1",
    "gf": "Gantzert_Felixander",
    "haru/01": "haru01",
    "haru/02": "haru02",
    "nietzsche": "nietzche"
  }

  
    var modelName = "hibiki";
  

  var modelJsonPath = "";
  if (modelPathJson[modelName]) {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelPathJson[modelName] +
      ".model.json";
  } else {
    modelJsonPath = pluginRootPath + modelName + "/" + pluginModelPath + modelName + ".model.json";
  }
  L2Dwidget.init({
    model: {
      jsonPath: modelJsonPath
    },
    display: {
       position: "right", 
       width: 145, 
       height: 315, 
       hOffset: 50, 
      
    },
    mobile: {
       show: false, 
       scale: 0.6 
    },
    react: {
       opacity: 0.8 
    }
  })

</script>

  
  
</body>

</html>
